{"title":"Aotu.io","description":"凹凸实验室(Aotu.io) 始建于2015年，是一个年轻基情的技术社区组织。<br/>O2面向多终端技术体系，致力于构建沉淀与分享包括但不限于交互、页面制作技巧、前端开发、原生APP开发等方面的专业知识及案例。","language":"zh-cn","link":"https://aotu.io","pubDate":"Thu, 14 Jan 2021 15:40:01 GMT","lastBuildDate":"Thu, 14 Jan 2021 16:03:17 GMT","generator":"hexo-generator-json-feed","webMaster":"凹凸实验室","items":[{"title":"凹凸技术揭秘 · Taro · 开放式跨端跨框架之路","link":"https://aotu.io/notes/2021/01/14/taro-history/","description":"承载 Web 的主战场转移2017 年 1 月 9 日凌晨，微信正式推出小程序，为移动端家族增加了新的业务形态和玩法，当大家还在探讨这一新兴平台能做什么的时候，京东率先上线了「京东购物」小程序，随后，更多的电商行业执牛耳者纷纷入驻小程序，从此，承载电商的主战场逐渐从需要自建流量的移动端 APP 向小程序倾斜。 小程序的出现，为电商行业的研发带来了巨大的挑战。继微信之后越来越多的头部流量互联网公司纷纷盯上小程序这一蛋糕，相继推出了各自的小程序平台，比如京东、阿里、百度、字节跳动、360等等，为了让我们的电商业务能快速移植到这些小程序平台，帮助我们的业务快速拓展渠道，我们开始了新的尝试。 我们开始尝试使用技术的手段，探索一种能够统一所有平台的新技术。 披荆斩棘——初代架构诞生用 React 写小程序？前面有提到，为了解决各大小程序平台带来的多端开发的痛点问题，社区先涌现出了 WePy 和 mpvue，那我们为什么不直接采用，而要选择“造轮子”呢？ 在当时的前端界言及前端框架，必离不开依然保持着统治地位的 React 与 Vue，这两个都是非常优秀的前端 UI 框架，而且在网上也经常能看到两个框架的粉丝之间热情交流，碰撞出一些思想火花，让社区异常活跃。 而我们团队也在 2017 年勇敢地抛弃了历史包袱，非常荣幸的引入了 React 技术栈。这让我们团队丢掉了煤油灯，开始通上了电，远离了刀耕火种的前端开发方式。为了解决当时业务环境对极致性能以及低版本 IE 浏览器兼容性的要求，我们还研发出了一款优秀的类 React 框架 Nerv ，并因此对 React 开发思想以及技术栈理解更加深刻。 遗憾的是，当时社区并没有一款使用 React 开发小程序的框架。 与小程序的开发方式相比，React 明显显得更加现代化、规范化，而且 React 天生组件化更适合我们的业务开发，JSX 也比字符串模板有更强的表现力。那时候我们开始思考，我们能不能用 React 来写小程序？ 理性地探索通过对比体验 小程序和 React ，我们还是能发现两者之间相似的地方，比如生命周期、数据更新方式以及事件绑定，都具有非常多相似的地方，这为我们使用 React 来小程序提供了非常良好的基础。 但是，我们也应该看到小程序和 React 之间的巨大的差异，那就是模板。在 React 中，是使用 JSX 来作为组件的模板的，而小程序则与 Vue 一样，是使用字符串模板的。这是两种完全不一样的东西，也是我们方案探索上的巨大障碍。所以，为了实现使用 React 来写小程序这一目标，我们必须解决两者之间巨大差异的问题。 解决差异既然微信不支持 JSX，那我们只需要将 JSX 编译成小程序模板不久可以在微信上运行了吗，这一步可以通过 Babel 来实现。 Babel 作为一个 代码编译器 ，能够将 ES6/7/8 的代码编译成 ES5 的代码，其的编译过程主要包含三个阶段： 解析过程，在这个过程中进行词法、语法分析，以及语义分析，生成符合 ESTree 标准 虚拟语法树(AST) 转换过程，针对 AST 做出已定义好的操作，babel 的配置文件 .babelrc 中定义的 preset 、 plugin 就是在这一步中执行并改变 AST 的 生成过程，将前一步转换好的 AST 生成目标代码的字符串 再次回到我们的需求，将 JSX 编译成小程序模板，非常幸运的是 babel 的核心编译器 babylon 是支持对 JSX 语法的解析的，我们可以直接利用它来帮我们构造 AST，而我们需要专注的核心就是如何对 AST 进行转换操作，得出我们需要的新 AST，再将新 AST 进行递归遍历，生成小程序的模板。 以上仅仅是我们转换规则的冰山一角，JSX 的写法极其灵活多变，我们只能通过穷举的方式，将常用的、React 官方推荐的写法作为转换规则加以支持。 初代架构诞生经过我们一次次的探索，我们已经可以将类 React 代码转成可以在小程序环境运行的代码了。但是我们激动之余，冷静下来继续思考，我们还能不能干点别的有意思的事情呢。 我们发现，在平常的工作中，我们业务通常有一些“多端”的需求。就是同一个业务或页面，需要同时适配 小程序、H5 、甚至 React Native 。这个时候，你就会发现，差不多的界面和逻辑，你可能需要重复写上好几轮。 因此，我们希望希望在解决使用 React 开发微信小程序的同时，还能同时是适配到 H5 端、移动端、以及各平台的小程序。Write once, run anywhere，相信是所有工程师的梦想。 但是仔细思考我们又会发现，仅仅将代码按照对应语法规则转换过去后，还远远不够，因为不同端会有自己的原生组件，端能力 API 等等，代码直接转换过去后，并不能直接执行，还需要运行时的适配。因此，我们按照微信小程序的组件库与 API 的标准，在其他端（H5、RN）分别实现了组件库和 API 库。 Taro 从立项之初到架构稳定差不多用了三个月左右的时间，从最初的激烈讨论方案，各种思想的碰撞，到方案逐渐成型，进入火热的开发迭代，再到现在的多个平台小程序端、H5 端和 RN 端的顺利支持，Taro 的未来已来。 初露锋芒——GitHub 开源2018 年 6 月 7 日，多端统一开发框架 - Taro 正式开源。 作为首个支持以 React 语法写微信小程序并适配到多端的开发框架，Taro 一鸣惊人。 开源不到两个月，在 GitHub 上有 6600 多个 Star，连续数周霸榜 Github Trending；同时已经处理近 300 个 Issue ，还有 100 多个在等待反馈与优化；在公司内、外主动反馈的使用 Taro 的项目已有十多个。 截至 2019 年 12 月 18 日，Taro 已拥有 22254 Stars 和 250 名 Contributors，社区主动提交的开发案例 150+：taro-user-cases，其中不乏多端案例。 截止 2021年 1 月 11 日，Taro 已拥有 27914 Star ，位列小程序开发框架前列。 Taro 团队不断跟进社区里提出的问题和反馈，一直保持着高速迭代，并围绕 多端适配、开发体验以及社区共建 三个方面持续优化 Taro 框架。 为了方便开发者快速开发项目，我们基于 Taro 推出了业内首款小程序多端组件库 Taro UI， 在多端适配方面，我们一直持续跟进，成为社区适配端最多的小程序开发框架。 为了更好的开发体验，我们支持了 React Hooks、CSS Modules、Mobx 等。 在社区共建方面，我们推出了 Taro 论坛、Taro 物料市场等平台，后面发布了 社区共建计划。 在跟进业务的同时，我们还需要不断跟进社区里提出的问题和反馈，因而就要不断加班加点地去完成，虽然有时会觉得很累，但是技术上的成就感以及能帮助到更多开发者时的满足感还是不断地激励着我们前进，让 Taro 项目越来越好。 筚路蓝缕——一段痛苦摸索的升级之旅Taro 在 GitHub 上开源之后虽然收获了非常多的赞誉，短短的时间内就突破了 10000 Stars，但由于 Taro 初期的自定义组件架构设计得非常复杂，导致使用组件开发的时候总会引起非常多的问题，一直为许多用户诟病。 在 Taro 设计的初期，由于微信小程序刚推出的自定义组件功能并不完善，实现不了传入自定义函数等问题，无法满足组件化灵活使用的需求，所以 Taro 的组件化架构是采用 template 标签来实现的。 使用 template 方案来实现的组件化架构在通常情况下运行良好，但面对复杂循环嵌套输出组件的时候则问题频出，主要原因是： JS 逻辑与模板隔离，需要分别处理，导致组件传参非常麻烦，难以对齐 template 实现的自定义组件无法嵌套子组件 所以，在 Taro 最初的时光，自定义组件的问题一直是我们抹不去的痛，作为官方团队，在痛苦思索解决方案的同时，还要面对社区不断的问题反馈和质疑，让我们总觉得前途一片灰暗。 但前人的经验告诉我们，不能就此放弃，鲁迅先生曾经说过「此后如竟没有炬火，我便是唯一的光」。我们在 template 方案挣扎良久之后，终于还是将目光投向了小程序自带的自定义组件身上。 正所谓山穷水复疑无路，柳暗花明又一村，小程序的自定义组件恰好有了一波更新，经过数个日夜加班探索之后，之前困扰我们的问题都得到了一一解决，完美实现了新的自定义组件架构，带来了更加稳定的版本。 在新的架构中，我们会把 Taro 的组件直接编译成小程序的原生组件的 Component 方法调用，再通过运行时的适配，来对组件参数、生命周期适配、以及事件传入等进行处理，借助小程序的组件化能力来实现 Taro 的组件处理。 经过这一版方案重构之后，Taro 的稳定性与可靠性得到了质的飞跃，社区的好评声不断，而 Taro 的关注数也得到陡峭的增长。这一版架构方案也成了 Taro 持续时间最久的方案，为 Taro 日后成为「一款值得信赖」的多端方案打下了坚实的基础。 这是一段筚路蓝缕的艰苦创业之旅，对于 Taro 团队来说也是一段非常宝贵的经验。没有一直一帆风顺的旅途，唯有不轻言放弃和勇于开拓才能云开见日，让我们走的更远。 高歌猛进——不断地突破自我 在完成了自定义组件架构的改造之后，Taro 开始了全速发展之路。 在 2018 年 11 月份，Taro 推出了 1.1 版本，完成了百度、支付宝小程序的适配支持，成为业界首个同时适配多个小程序平台的多端开发框架，并且在适配期间，Taro 团队和百度、支付宝小程序官方团队建立了联系，为对方小程序的发展提出了非常多的建设性意见。与此同时，Taro 成为百度小程序官方推荐使用框架之一。 而短短一个月之后，2018 年 12 月份，Taro 火速推出了 1.2 版本，这是一个非常具有创新意义的版本，在这个版本中，Taro 首创了小程序原生代码反向转换技术，能够将小程序原生代码反向转换成 Taro 代码。原有的微信小程序通过 Taro 转换，就能快速移植到其他平台，这为业务的快速扩张提供了巨大的想象空间，为业务的高效交付提供了极大的助力。 而「京东快递」业务正是反向转换特性成功应用的一个典范案例。最初「京东快递」只有微信小程序平台，通过 Taro 的反向转换特性，以极低的成本快速移植到百度、头条小程序平台，并且可以只维护一份代码，同时维护 3 端应用，极大地降低了维护成本。 在 Taro 1.2 发布之后，Taro 在业界收获了巨大的赞誉和关注：GitHub 上 Stars 数量超过 19000 粒，NPM 下载量也稳居同类开发框架之首，同时 Taro 团队也和腾讯、百度、华为等数十家业界巨头的研发团队展开了深入和有效的合作。 时间匆匆而逝，来到了 2019 年 6 月，时隔半年，我们终于发布了 Taro 1.3，这是我们酝酿最久的版本：经历了横跨 6 个月的开发时间，近 2000 次的代码提交，同时有近百位开发者的共同参与。在 Taro 1.3 中，我们不仅仅带来了对 QQ 小程序的支持，同时还支持了快应用，成为业界支持平台最多的多端开发框架，而更重要的是，在这个版本中我们成功将业界火热的 React Hooks 搬到了 Taro 中，支持让用户使用 React Hooks 的方式来开发小程序，成为业界首创。 从 Taro 正式版发布，到 Taro 1.3，可以看出 Taro 一直不断使用创新的理念打磨自我，以创新为使命，为业界带来体验优异的多端开发解决方案。 拥抱变化——为未来思考 尽管 Taro 一直保持超高的迭代速度，但自从自定义组件架构改造之后，Taro 的整体架构设计没有发生太大变化，这让 Taro 在这个时刻在变化的时代稍显佛系，且对于一个时刻想要突破自己的技术团队来说，常规性质的维护工作，显然无法安抚我们躁动的心，毕竟人的梦想，是永远不会停止的，所以我们决定启动一系列的颠覆式重构设计。 我们首先从 CLI 开始入手进行改造，众所周知，原来 Taro CLI 的编译构建系统是自研的，整个构建系统逻辑复杂，要考虑的边际条件众多，这就导致了以下问题： 维护困难，每次需要新增一个功能，例如支持解析 Markdown 文件，就需要直接改动 CLI，不够灵活 难以共建，CLI 的代码非常复杂，而且逻辑分支众多，让很多想要一起共建的人难以入手 可扩展性偏低，自研的构建系统，设计之初没有考虑到后续的扩展性，导致开发者想要添加自定义的功能无从下手 基于以上问题，我们决定使用 Webpack 来实现编译构建，于是诞生了 2.0。 Taro 2.0 的 CLI 将会变得非常轻量，只会做区分编译平台、处理不同平台编译入参等操作，随后再调用对应平台的 runner 编译器 做代码编译操作，而原来大量的 AST 语法操作将会改造成 Webpack Plugin 以及 Loader，交给 Webpack 来处理。 相较于旧的构建系统，新的小程序编译带来了以下优势： 利于维护，大量的逻辑交由 Webpack 来处理，我们只需要维护一些插件 更加稳定，相较于自研的构建系统，新的构建会更加稳定，降低一些奇怪错误的出现概率 可扩展性强，可以通过自行加入 Webpack Loader 与 Plugin 的方式做自己想要的扩展 各端编译统一，接入 Webpack 后，Taro 各端的编译配置可以实现非常大程度的统一 可以看到新的构建系统会有很大的进步。同时，更重要的是，基于 Webpack，我们可以在小程序中尝试更多的特性与技术，例如通过 tree shaking 来优化代码包大小等等，让小程序开发更加与业界发展同步，让 Taro 更加拥抱社区。 Taro 2.0 只是一个开始。 在 10 年代最后一场 GMTC 全球大前端技术大会上，Taro 团队向大家展示了 小程序跨框架开发的探索与实践 的艰辛旅程，同时也提前曝光了正在紧密开发中的 Taro Next。 那是一个完全区别于以往的版本，一条与现在 Taro 截然不同的道路，预示着 Taro 正在革自己的命。 节物风光不相待，桑田碧海须臾改。 20 年代呼啸而来，下一个 10 年，很多框架都会死去，很多技术也会焕然而生，没有什么是不变的，唯一不变的只有变化，我们能做的也只能是拥抱变化，为未来思考。 乘风破浪——新架构起航正如前文所提到的，Taro 迎来了全新的架构。 不同于 Taro 1、2 时代的架构，新的架构主要基于运行时，我们都知道使用 React 开发 web，渲染页面主要依靠的是 react-dom 去操作 DOM 树，而 React Native 依靠的是 Yoga 布局引擎，但是我们却能通过 React 将他们联系在一起，这主要是通过抽象的 Virtual DOM 技术来实现的，通过 Virtual DOM 达到跨平台统一的目的。而小程序中虽然没有直接暴露 DOM 和 BOM API，但是我们却可以类比 React 和 React Native 的思想，在小程序中模拟实现 DOM 以及 BOM 的 API，从而实现直接将 React 运行到小程序环境中的目的，这就是 Taro 新架构的由来。 在新架构加持下，Taro 不再仅局限于 React 阵营，可以不再限制使用的框架语法，而 Taro 官方内置了 React、Nerv、Vue2、Vue3 四种框架的支持。 Taro2 到 Taro3，是一次技术的跃迁，也是一次创新的胜利，更是 Taro 团队不断探索，永不止步精神的体现。Taro 这艘大船又重新杨帆起航，带着初心再次出发。 乘风破浪破浪会有时，直挂云帆济沧海。 众擎易举——开放式架构自 2020 年 7 月初 Taro 正式发布了 Taro 3，至 12 月半年时间已然略去。期间我们不断地修复着问题，同时也在构想着下一个 minor 版本。 面对小程序平台越来越多的大环境，Taro 是选择偏安一隅，只支持部分的主流小程序，还是成为所有小程序平台\b开发、多端转换的基础设施，Taro 在 v3.1 给出了答案：开放式架构。 基于 Taro 3 的架构，对于单一平台的兼容性代码分布于 Taro 核心库的各个角落，涉及编译时与运行时等部分。支持一个新的平台需要改动所有的这些地方，开发复杂度高，同时社区也难以参与贡献。 因此我们萌生了打造一个开放式框架的想法。目标是可以通过插件的形式扩展 Taro 的端平台支持能力： 插件开发者无需修改 Taro 核心库代码，即可编写出一个端平台插件。 插件使用者只需安装、配置端平台插件，即可把代码编译到指定平台。 开发者可以继承现有的端平台插件，然后对平台的适配逻辑进行自定义。 我们把内置支持的 6 个平台封装成了插件，CLI 默认会全部加载这些插件。封装的过程中，我们检索了各小程序最新的组件、API，并全数进行更新与支持，对齐各小程序最新的能力。而借助开放式架构，我们编写了若干端平台插件，开发者安装后即可使用。 结语开源不易，贵在坚持。Taro 一路走来，有众多开发者相伴，进入过 中国活跃度 Top 5 的开源项目，像河水不断奔涌向前的 Taro 既争先也争滔滔不绝。 Taro 团队衷心感谢各位参与过本项目开源建设的朋友，无论是为 Taro 提交过代码、建设周边生态，还是反馈过问题，甚至只是茶余饭后讨论、吐槽 Taro 的各位。","pubDate":"Thu, 14 Jan 2021 15:40:01 GMT","guid":"https://aotu.io/notes/2021/01/14/taro-history/","category":"凹凸"},{"title":"凹凸技术揭秘 · 基础服务体系 · 构筑服务端技术中枢","link":"https://aotu.io/notes/2021/01/14/exa-server/","description":"前言凹凸实验室从最初的前端团队成长为如今的全端团队，意味着我们不仅关注前端的技术能力，也重视全端及全栈的能力。在这一篇，我们从前端团队角度出发，阐述我们最初搭建服务端体系遇到的一些困难，已构建的服务体系架构，以及如何更好地助力业务增长。 些许似曾相识首先，我们来看下日常工作中存在的一些场景。 场景A：在某些业务中，底层数据团队提供的数据接口并没有提供 HTTP 调用，需要去寻找其他服务端团队来封装，这时候需要等待其他团队排期，可能造成业务无法正常上线； 场景B：前端页面性能卡顿，由于调用接口过多，需要等待其他服务端团队聚合数据； 场景C：我们在一些项目需要SSR，前后端需要复用统一套模板； 场景D：我们内部孵化了一些项目，需要接口服务，需要等待其他服务端团队支持。 这些场景的背后，我们急需组建一个服务端研发团队来承担部分的业务服务开发以及更好地帮助团队未来发展。 成型在团队组建上，主要采用「内部选拔」 + 「外部招聘」2 种方式。在团队发展上，我们主要经历了 3 个阶段。 雏形在最初的阶段，选择以 NodeJS 作为服务端编程语言，主要以下有 2 点考虑： 团队大部分同学熟悉 Javascript，能够快速学习 NodeJS，上手成本较低； 在 SSR 方面有天然的优势，前后端能够共用部分代码。 在这个阶段，我们快速孵化了一系列的系统和平台，比如 Mock 平台、前端监控平台、兜底平台等等，主要目标丰富前端研发体系，提升前后端的开发及协作效率，同时也沉淀了一些 NodeJS 中间件。 成长在服务开发效率、性能、稳定、安全等方面有了一定的沉淀之后，我们开始思考如何更加规范服务开发，更加高效地支撑业务增长。 在这个阶段，我们不仅输出了「研发规范」、「研发流程」、「开发框架」等一系列的知识体系，也搭建了「部署平台」、「通用管理平台」等相关研发平台。在业务开发上，我们用 NodeJS 实现了「天狗」游戏服务、用 OpenResty 实现了「数据聚合服务」、在某些频道上采用了 SSR 等等。 赋能在设计中台中，我们沉淀了大量的通用服务，比如「页面」、「图片」、「编译」相关的服务，部分服务赋能给了其他团队，比如说我们将页面智能设计相关的服务赋能给了「江湖平台」、「智铺」等产品。 在公司内部，大部分的服务端团队技术栈主要是 Java，在服务间调用采用了集团内部自研的 JSF 协议。而我们团队主要技术栈依然以 NodeJS 为主，给其他团队提供 HTTP 调用，与 Java 在接入方式、限流、代码提醒等方面存在较大差异，也无法很好利用集团内大量的中间件。 在这个阶段，我们引入了 Java 技术栈，形成了以「NodeJS + Java」为主要服务端语言的技术体系。针对部分领域服务，我们提供了 Java 版本的 JSF 服务实现，方便第三方团队沟通合作。 体系结构经过几年的沉淀，我们团队在服务端领域构建出了初步的体系结构。 服务端研发体系的建设，主要目标是为了提升团队代码的下限，提升开发效率，提高服务交付质量，促使团队共同成长。 构建一套服务端研发体系，主要围绕 8 个方面展开，包含研发规范、研发平台、研发流程、文档建设、团队管理、监控告警、中间件管理以及基础设施。 在整体服务架构上，我们日常的开发采用分层结构的模式，尽可能去抽离出通用的服务逻辑，输出更多的积木，降低我们的开发和维护成本。 以下从「业务支撑」和「技术建设」方面去简单阐述我们近几年在服务端领域的一些探索和实践。 业务支撑业务是团队的立命之本，只有在业务的快速增长中才能不断去验证和优化我们整个服务体系，保证整体服务的可靠性。 羚珑服务羚珑全称羚珑智能设计平台，提供一站式在线设计服务：一键抠图、免费抠图、商品打腰带、改尺寸、商品主图设计、线上广告banner设计、店铺首页设计、活动页设计、页面设计、互动营销设计、小程序设计、动图视频设计、视频广告设计、商品主图视频设计、海报设计、公众号配图设计、二维码名片设计、DM传单设计、物流面贴设计、易拉宝设计、张贴海报设计等等。提供海量精美模板和免费素材，免费设计，另设有企业专区，是致力于成为商家经营的设计合作伙伴的平台。 其下的羚珑智能页面设计是集结业内各色资深电商行业设计师，提供一站式专业智能页面和小程序设计服务的平台。整个架构服务轻量化、模块化，更便捷拓展专区业务场景。服务架构如下： 整体架构分为 Web 应用层、接口层、服务层和数据层四部分，这样拆分能做到入口统一，在部署上单点部署让发布更加便捷，独立部署则降低模块更新对整体服务的影响： Web 应用层：包括羚珑及其他的平台应用； 接口层：提供网关服务，应用层的请求经由网关，通过权限校验，转发到各个模块去； 服务层：主要分为下面四部分： 服务通信：异步通信使用 MQ，RPC 通信采用 HTTP 调用的方式； 业务模块：也即服务的核心逻辑，它们被按照功能逻辑划分成不同的模块，模块内独立地处理大部分功能，达到高内聚低耦合的效果； 基础服务：支撑业务模块的基础功能，统一把控用户与权限； 服务管理：用于服务辅助，提升服务的稳定性、健壮性和灵活性。 数据层：服务主要使用到了 MongoDB 和 Redis，前者为主要存储，后者用于数据缓存。 项目使用 Typescript 开发，遵循统一的接口规范，保证出入参的风格统一，模块化的设计让服务运维和迭代轻松，在功能上，支持专区和场景的插拔式拓展，让业务变得无限可能。 数据聚合服务在电商的业务中，比如频道、大促活动这种类型的业务会经常使用到商品组、广告组的数据，在通用的接口里面会出现较多冗余的字段，特别在批量查询服务的时候，整个响应包会比较大。 我们采用 OpenResty 实现了 GraphQL 服务，数据按需加载，能够有效减少数据包大小；数据自动兜底，能够保障服务可用性，尤其在大促期间底层服务出现响应慢的情况下。 技术建设必要的基础建设和技术探索，是为了更好地帮助业务和团队面向未来。 以下围绕「Talos部署平台」和「通用管理平台」来阐述我们在服务端方面的一些基础建设。 Talos 部署平台Talos 部署平台基于内部的 JDOS 平台开发而来，主要是提供应用资源管理和部署功能，解决部署难、开发效率低、服务运维成本高等问题，使研发同学更专注于开发。 主要架构图如下： 我们从「资源管理」、「应用部署」这两个方面来简单介绍下该平台。 资源管理 项目分组功能，可方便开发者管理以及查看分组下应用、流量、资源占用等情况。 静态网站部署支持将静态网站应用部署至同一后端应用中，浏览器访问时根据域名或者前置路由匹配对应文件，达到节省资源，提高资源利用率的目。 除此之外，还有其他的一些功能： 提供 Talos 网关，方便服务转发及挂载； 提供 MongoDB 可视化面板功能，方便开发同学查看线上数据库，提供只读、读写等权限； 提供全流程监控功能，包括应用创建、部署、容器调整等，运行过程中 cpu、磁盘、负载等超过阈值也会告警； 其他还有容器数量调整、大促时上线限制、通知等功能。 应用部署支持多环境部署，可设置测试、预发、生产等环境，每个环境下有各自单独的配置文件、配置属性字段等，支持一键部署、回滚、下线等操作，部署界面如下图： 支持不同项目类型部署，如 NodeJS、静态站点、自定义部署等。 支持不中断部署，利用 JDOS 的滚动更新接口，控制流程切换，将应用容器分为前后两批滚动更新，确保更新过程中应用不会中断。 通用管理平台在开发过程中，往往需要硬编码一些数据，而大多数的数据在以后的维护、运营中时不时需要更新。过去我们经常被这些琐碎的修改数据给占用了些时间，降低了编码效率。解决这个问题有两种方式，第一种在数据库中存储变更数据，开发对应服务端接口进行 CRUD。这种方式我们需要的资源有数据库、服务端开发、网关域名，这么看来得不偿失了。而第二种就是在平台中动态配置表单，定义数据结构，再录入数据，同时平台提供统一的 CRUD 网关 API。在上述的背景下，通用内容管理平台应运而生。下面来看看提供了哪些实用的功能！ 通用管理平台提供了表单、数据创建，满足了大部分配置管理功能；同时提供了权限管理功能，可以供产品/运营同事更新数据，摆脱让开发同学修改数据/版本发布的烦恼。 数据表单 - 数据结构定义 为什么要有表单，而不是直接存 JSON 数据呢？想象下在 MongoDB 数据库中，假如不能使用 Mongoose 等 ORM 框架进行数据的定义，只能通过阅读数据或者通过分离的文档进行理解表结构设计的意义，那样一定非常痛苦。 表单的功能主要分为表单的字段设计、用户权限管理和表单标识编辑。其中字段设计提供了类似于关系型数据库的 Schema 设计，用户可以创建对应表结构的字段的类型、默认值，甚至可以通过正则表达式对数据进行校验。 数据 - 数据存储数据模块提供的功能包括了数据录入、数据同步（不同环境）、版本管理和获取 API 链接的功能。 数据录入：录入数据时根据表单的字段规则进行校验，防止同一个表单内的数据不一致情况； 数据同步：平台上提供了两个环境，预发和正式。用户可以进行两个环境的数据全量同步和部分同步； 版本管理：像大多数内容管理平台一样，为了防止用户的误操作或者是恢复旧版本数据，提供了该功能； API 链接：在录入数据之后，通过该链接便可以访问录入的数据。 以上介绍了通用管理平台的功能点，在实践中有大量的应用接入，其中便有羚珑、Jelly、Taro、Quark 等等优秀的项目。 结语目前为止，我们在服务端领域的积累和沉淀还只是冰山一角，需要进一步探索和沉淀，未来会更聚焦服务积木化，输出更多可复用、可赋能的积木，为业务增长保驾护航。","pubDate":"Thu, 14 Jan 2021 14:26:01 GMT","guid":"https://aotu.io/notes/2021/01/14/exa-server/","category":"凹凸"},{"title":"凹凸技术揭秘 · Tide 研发平台 · 布局研发新基建","link":"https://aotu.io/notes/2021/01/06/taro-ide-n-tide/","description":"背景随着前端技术领域的高速发展，前端开发也变得越来越复杂。业务扩张，小程序平台井喷式增加，都导致开发者肩上的负担越来越重。为了提升研发效率，减少人力浪费，我们开发了开放式跨端跨框架解决方案 Taro，支持使用 React/Vue/Nerv 等框架来开发 微信 / 京东 / 百度 / 支付宝 / 字节跳动 / QQ 小程序 / H5 等应用，将一份代码直接转换到多个不同终端，有效避免了将一份代码手动适配到多个平台的重复劳动。 一个项目的完整生命周期一般包括：项目创建，代码开发，测试，部署发布，以及后期的监控。作为一个多端解决方案，Taro 有效提升了多端应用的开发效率，但对于开发以外的环节就无能为力了。 如何提升研发流程整体的效率？技术先驱们早已给出了答案：Integrated Development Environment（集成开发环境），也就是通常说的 IDE。 举个例子，C 语言程序运行前，需要经过预处理、编译、汇编、链接等步骤，最后生成可执行文件。但在 Visual Studio 等 IDE 中，点击一个按钮就能完成上面所有的流程。Taro 尚没有一款类似的产品将项目的研发流程与生命周期进行整合，这给了我们施展拳脚的机会。 另一方面，虽然集成开发环境在开发者群体中是较为小众的概念，却并不妨碍它成为 SaaS 领域的热点之一。不论是国内的 CODING，各厂商的小程序开发者工具，还是远在国外的 CodeSandbox，都阐述了各自对于集成开发环境的理解。资本市场也对他们的答案给予了肯定。 到这里，我们的目标就清晰了。为了提升研发效率，也为了探索技术产品化与商业化，我们要做一款Taro 的集成研发环境，利用它来串联研发流程、整合研发流程中的系统、工具，实现整个研发流程的体系化、规范化，促进研发物料在体系内的流转，这就是 Taro IDE 项目。 探索“路漫漫其修远兮，吾将上下而求索”。 我们希望通过 Taro IDE 串联研发流程，同时，由于 VSCode 在代码编辑器领域如日中天，短时间内很难做出 VSCode 的替代品，我们考虑在不触及代码编辑环节的基础上，整合研发流程中的工具、系统，将常用操作 GUI 化，屏蔽研发流程及前端工程的复杂度。 基于上面的想法，我们打造了 Taro IDE，它具有以下功能：快速开发，本地测试，发布中心，物料中心，以及应用监控。 Taro IDE 是基于 Electron + React 打造的桌面客户端。基于 Electron 提供的原生能力，Taro IDE 可以在本地创建项目、启动小程序开发者工具，并进行小程序的发布、体验版设置等。 Taro IDE 满载着我们的希望上线了。本期望它可以乘风破浪，一举成名，然而上线后的统计数据却给我们上了生动的一课：我们的想法还是太年轻、简单，甚至有些幼稚了。在多次开会复盘后，我们将这次失利归因为下面三点： 缺乏核心卖点。用户可以轻易找到替代方案达到相同效果； 体验问题。项目的交互细节经不起仔细推敲，使用体验并不顺畅； 缺乏反馈渠道。项目上线，由于缺乏获取用户反馈的渠道，后期的优化工作无法展开。 带着这次上线失利的教训，我们走上了寻找核心卖点的旅途。 打磨根据我们的对 Taro 开发者的抽样统计，在使用 Taro 的项目中，具有多端需求的项目占到了一半以上。 通过将一份代码转换到多个平台，Taro 解决了多端项目的研发效率问题。但在小程序多端开发过程中，我们需要同时打开多个小程序开发者工具，面对如此多的窗口，调试时难免手忙脚乱，这是多端应用开发过程中显而易见的痛点。如果有一个多端调试工具，一键切换调试平台，必然能够大大提升研发效率和体验。 技术调研阶段，业界并没有可供参考的方案。在反编译友商的小程序开发者工具后，我们发现各平台小程序开发者工具的实现基本如出一辙，并且都遵循了微信小程序的标准。即使有少数的差异，也可以在 Taro 层或者工具层抹平。也就是说从技术层面上来讲，多端调试器是可行的。 具体说来，在调起调试器之前，首先需要将小程序跑起来，为此我们需要提供一个小程序运行环境。参照微信小程序的设计，小程序的运行环境主要包括模拟器和 AppService： 模拟器负责通过 webview 中还原小程序页面的展示效果，即视图层； AppService 是另外的一个 webview，负责模拟小程序行为，管理小程序启停等生命周期，数据存储等，是逻辑层。 调试面板则负责提供调试小程序组件、本地存储、AppData 等能力，这需要将 webview 与调试面板通过 Chrome Devtools Protocol 连接起来。 开发阶段，出于开发生态的考量，我们采用 Electron 作为底层技术，而不是微信开发者工具中的 NW.js。调试器内运行的小程序基于多进程的架构，视图层（页面）与 数据层（AppService） 运行在不同的 webview 中，互不干扰，相互之间经由 JSON RPC 进行通信。 基于上面的原理，我们完成了 Taro 小程序的多端调试器，可以一键切换小程序平台进行调试。由于项目采用了 B/S 架构，很方便适配到多种多样的使用场景，如 Cli 命令调用，通过 Taro 2.0 的插件 API 调用，或者是在 Taro IDE 中使用。 在调试器完工之后，我们发布了 Taro IDE 2.0。相比 1.0 版本，2.0 添加了调试器功能并优化了性能和体验。上线后，Taro IDE 的使用数据稍有好转，但依然没有达到理想状态。 调试器可谓是我们在 IDE 探索过程中的无心插柳之作。谁都没有想到，调试器能力竟成为了后期串联研发全流程的关键碎片。 正轨在失利后，我们在每个失眠的夜问自己：”IDE 应该怎么做？“，可这无异于问道于盲。在短暂的彷徨后，我们决定进行用户调研，快速编辑了一份 Taro &amp; Taro IDE 调研问卷，向所有使用过的用户进行投放。 调查结果显示，我们过于低估桌面客户端的安装门槛了。Taro IDE 1.0、2.0 都是基于 Electron 开发的桌面应用，动辄几百 M 的体积已经拦住了大量的非刚需用户，更不用说它还存在前面提到的问题了；其次，基于 Electron 的 Renderer/Main + IPC 架构看似方便，事实上却会导致大量的逻辑耦合。综合上面两个原因，我们下定决心，要将应用改造为 B/S 架构，降低用户的使用门槛。 到这里，我们已经围绕项目研发流程，完成了 GUI 化的项目创建、测试、发布等研发流程，调试器能力的开发。距离完整的开发者工具，就只差一个编辑器了。 一款没有代码编辑器的 IDE 是没有灵魂的。纵使我们在前端工程化领域努力耕耘，也无法与 Visual Studio、Eclipse 等知名开发者工具比肩。我们开始思考：能否基于已有的能力，做一些更厉害，更有影响力的事情？直到发现 Eclipse Theia 项目，我们知道，机会来了。 从最开始，我们就一直在做大而全的事情。从项目的创建，到发布等流程，我们需要考虑不同用户的使用环境，对特殊场景做额外处理，慢慢地将 Taro IDE 项目变得臃肿不堪，却忘记我们最初只是想要一个集成开发环境，想要串联研发流程而已。 孙子说得好：“能用众力，则无敌于天下矣。”如果我们只负责抽象研发流程，而将研发流程的具体逻辑交给专业的研发同学。不同部门之间形成合力，IDE 核心的工作量会大大降低，业务支持也会更为专业。 Eclipse Theia 是一款云和桌面端的 IDE 平台，提供了一系列构建 IDE 的工具，不仅编辑体验酷似 VS Code，还支持 VS Code 的插件生态；基于 InversifyJS 的底层还具有极强的扩展性，完美符合我们的要求。 因此，我们基于 Theia 源码，结合内部的业务及使用场景，对 Theia 进行拓展，增加了插件系统、布局系统、和业务上下文模块，让业务方简单、灵活地深度定制 IDE 的功能和界面。 拓展完成后，我们基于 Theia 打造底层 IDE 框架，提供通用研发流程接口，其他团队则通过插件机制，定制专属的研发流程，如 Taro 项目研发流程，H5 营销项目研发流程等，最后打包成对应的场景化 Cloud&amp; Desktop IDE。至此，我们完成了从 Taro IDE 到公共 IDE 底层框架的转变。 成果为配合项目形态的转变，我们还联合品牌设计的同学，将技术品牌由 Taro IDE 升级为 Tide，期待它能像 Tide Hunter 一样，一个大招搞定全场。 目前，Tide 项目的核心模块已经开发完毕，并通过插件适配了 Taro 项目研发全流程，在部分业务开展试点。 展望如果说在前端模块化标准、方案出现以前，前端界尚处于刀耕火种的阶段；那么在前端工程化蓬勃发展的今天，前端行业正在逐步向成熟的工业化转变。 未来会如何？我们倾向于认为，未来会是大数据、智能技术大展身手的时代。不仅如此，我们也已经进行技术布局，借助智能的力量，对传统的产研流程发起彻底的改革，我们称之为智能化的前端研发体系，Tide 正是其中的基础设施之一。 什么是智能化前端研发体系？ 前端研发人员在收到业务设计稿后，通过 Deco 智能代码，得到基础的 UI 还原稿。对于其中的修改点，则可在羚珑页面可视化平台中进行调整。过后将调整后的 UI 代码导入到线上 Tide 环境中二次开发，填充数据、逻辑等代码，运用 Taro 能力，将业务上线到众多不同的业务平台中。最后，上线业务中可以再次向夸克设计资产沉淀大量优质物料，提升未来智能代码能力的准确性。 我们将继续完善 Tide 核心架构，将 Tide 拓展到其他的研发场景，帮助业务方快速高效定制自己的场景化 IDE，提升研发效率；除此之外，我们还将提供基于 Docker 的部署方案，帮助业务方实现实现研发上云。 “锦江春色来天地，玉垒浮云变古今”。 前端领域的发展日新月异，各种技术框架层出不穷，2021 年，变化的种子已经埋下，让我们一起拥抱更好的未来。","pubDate":"Wed, 06 Jan 2021 16:00:01 GMT","guid":"https://aotu.io/notes/2021/01/06/taro-ide-n-tide/","category":"凹凸"},{"title":"凹凸技术揭秘 · 夸克设计资产 · 打造全矩阵优质物料","link":"https://aotu.io/notes/2021/01/06/quark-design-asset/","description":"1、诞生背景近几年围绕业务中台化的场景，涌现了很多中台，有面向开发者的，有面向产品的，有面向运营团队的，但是却缺少一个可以提供给设计师协作的中台，设计师与开发、交互的协作仍处于源文件交换的原始刀耕火种时代。 上下游之间的合作成本高，没有统一的规范性。往往一个视觉稿会经历反反复复的改版，文件的传输只能使用网盘管理，没有一个统一存储和管理的平台。项目团队的设计规范落地效果不佳，公共的设计素材共享不便，同时各个团队的设计资产无法共享流通，资源无法进行整合，甚至存在重复设计等问题。 我们通过分析当前的痛点，参照现有的协作流程以及未来的发展趋势，是否可以有一套供各个角色都能使用的设计物料平台呢？按照这个思路，我们开发出了一套京东自己的设计资产管理平台，命名它为「夸克」。夸克在物理学上是构成物质的基本粒子，夸克相互结合组成万物，我们是用夸克来比喻那些构成组件、模块、页面、网站的所有物料，是我们星辰大海中的重要基石。 2、平台介绍夸克平台是数字化设计资产管理平台，集物料收集、拓展、外接与输出能力于一身，内容涵盖组件、模版、图标、字体、动效、图片、素材、VI等。 夸克平台目前提供 Sketch 插件、WEB 端和 CLI 端三种形式进行物料收集与共享，覆盖产品、设计、研发、运营和商家等用户人群。 夸克平台为每个项目设立物料管理空间，各个团队持续丰富夸克平台各类型设计资产，统一在线管理和协作，最大化提升业务整体设计效率，从而达到增效降本的目标。 3、平台能力3.1 DSM能力近几年设计系统作为重要的设计资产及解决方案，其被重视的程度与日俱增。由于原始的设计方法已经无法满足爆发式增长的设计需求，设计师开始寻求工程化的解决方案。于是引入原子设计理论（Atomic Design）解决问题，即使用一种有条理创建模式库的方法，结合软件开发的组件化思想，从最原始的原子出发，逐层构筑更高级别的组织，很好地解决了模块化和规模化的问题，这就是设计系统的前身。 3.1.1 什么是设计系统设计系统是由设计语言和模式库构成，在设计原则的指导下，通过统一的协作语言和科学的管理方法组织起来，并创建体验一致的用户界面的系统。 设计语言： 设计系统的基础，与品牌识别和情感相关，包含颜色、字体、图标等基础设计原子； 模式库： 一系列由设计原子组成的可复用的组件，模板等。 3.1.2 DSM 资产库在设计系统中，设计语言和模式库就好比「原子设计理论」中的原子、分子、组织、模板、页面，他们是保证团队协作一致性的基础，而设计规范更像是一份说明文档，指导设计师在设计过程中遵循一定的规则。 夸克作为数字化的设计资产平台，需要解决设计系统数字化的问题。 那设计系统中，有哪些可被数字化存储的物料资产呢？结合目前流行的 Sketch 设计软件来看，我们可以给设计语言和模板库做个映射，看看 Sketch 原生支持哪些设计系统中的原子物料。 Sketch 之所以能打败 PhotoShop 成为最流行的 UI 设计工具之一，是因为软件大量运用了「复用」的工程化思想解决设计问题，如 Symbols, TextStyle, LayerStyle, SharedStyles 等 Symbol：类似于工程中的代码组件，并提供组件嵌套、实例化等开发流程中常见的操作； Color：在 Sketch 中不单单是颜色的色值，还包含渐变色及图片填充； TextStyle：针对文本图层的共享样式，类似于 CSS 中的公共 SCSS Font Mixins； LayerStyle：针对容器图层的共享样式，包含 Background、BoxShadow、BorderRadius 信息。 3.1.3 如何沉淀 DSM 数字化资产我们借助 Sketch 图层解析的能力，开发了「夸克 Sketch 插件」，将视觉稿中的抽象信息序列化为可存储的数据，并以项目库的形式承载 Sketch 视觉稿中沉淀的数字化资产。 基于 Sketch 目前支持的共享设计元件，我们将 DSM 物料分为六大类： 组件：图层或图层组，即 Layer、LayerGroup、Symbols； 模板：跟组件类似，但颗粒度更大，普遍以页面的形式沉淀，即 Artborad； 图标：图标类型的矢量图形，即 Path； 颜色：色值、渐变色、图片填充； 字符样式：SharedStyles 中的 TextStyles； 图层样式：SharedStyles 中的 LayerStyles。 DSM 数字资产本质上是 Sketch 视觉稿中的共享设计元件，得益于 Symbols 和 SharedStyles 自带的同步能力，团队成员在调用组件物料时，能及时同步最新的组件规范。当视觉规范发生变更，如主题色，字体样式调整，使用到这些共享样式的视觉组件也会同步被更新，这非常利于设计流程中的协作。 从设计系统到 DSM，再到最终研发的视觉代码还原，通过 DSM 的建立，设计的产出有了统一标准，开发迭代的效率也得到显著提升，设计师也能更专注于深耕体验和细节，实现设计向产品的赋能。 3.2 组件库所有页面或应用，从底层分解开来，都是由各种大大小小的组件所构成。随着公司业务的扩展，面对各式各样的前端业务需求，我们需要一套标准化、规范化的组件，以提高我们的开发效率且给业务赋能，夸克组件库就应运而生了。 对于开发者而言，夸克组件库分为「基础组件库」、「业务组件库」、「自由组件库」三类。 3.2.1 基础组件库基础组件库（也指 Taro UI），是一套居于 Taro 框架开发的多端 UI，包括：通用类、布局类、导航类、数据输入类、数据展示类、反馈类、手势类等多种样式类型。我们针对设计师跟开发者都有对应的使用方式。 设计师可以通过下载源文件或插件的方式来使用： 开发者可以通过在 Taro 文件中引入组件的方式来使用组件，例如： 1import &#123; AtButton &#125; from &apos;taro-ui&apos; 每个组件都有详细的参数可以供开发者配置与参考，而且基础组件具有以下特性： 多端适配：一套组件可以在微信小程序、京东小程序、百度小程序、H5 等多端适配运行； 组件丰富：提供丰富的基础组件，覆盖大部分使用场景，满足各种功能需求； 按需引用：可按需使用独立的组件，不必引入所有文件，可最小化的注入到项目中。 3.2.2 业务组件库业务组件库是由夸克平台官方出品的一套标准化、规范化的电商导购类组件库。通过梳理出日常商城业务中的常用业务组件，最终形成一套可快速复用、便捷维护、功能覆盖全面的组件库。业务组件的 UI 更是由 JDC 设计师设计，提供多种配色方案、多种排版模式、多项自定义调整样式，足以满足大部分日常页面需求。 业务组件本质上是一个使用 Taro 框架开发的代码包，居于 Taro 的多端支持能力，可以完美适配微信小程序、京东小程序、百度小程序、H5 等环境。在项目中，开发者可以通过 tarball 的组件方式安装使用，也可以直接下载代码包使用。 3.2.3 自由组件库自由组件库是由开发者自由开发，不依赖夸克组件开发框架、不需要遵守夸克组件开发文档规范，最终以独立代码包或 NPM 在线安装的方式，共享到夸克平台，提供给其他开发者或开发团队下载使用的组件类型。 在夸克平台，开发者可以上传并管理自己开发的自由组件，也可以使用搜索去下载其他人共享的组件。 3.3 字体库字体库是物料中不可或缺的一部分，个性化的字体不仅能提升用户的良好体验，还可以提升项目的设计品牌化和个性化等。 3.3.1 版权字体下载夸克字体库将字体分为八类，包含黑体、宋体、仿宋、楷体、圆体、书法体、手写体和装饰体。然后将京东的授权字体和开源免费字体进行分类归纳，一共收录了2000+的字体包源文件和1000+的字体家族。 使用者可以通过关键字检索或者类别筛选（繁简/字形）查找京东版权字体家族，点击右侧「下载」按钮便可直接下载使用。 3.3.2 在线字体生成往往一个字体包文件是偏大的，虽然小的字体可以有十几K，但是大的字体可以去到上百兆，直接使用会出现加载慢、体验差、浪费流量等问题，而且在我们的应用场景里一般不会使用到一个字体包里的全部字体。 因此，夸克平台的字体库提供了字体切片的功能。它可以对字体包文件进行按需提取，然后将提取的片段生成一个新的字体格式文件，从而大幅的降低了字体包文件大小。 4、对外赋能4.1 物料市场平台目前提供了物料市场功能，它将所有物料进行扁平化搜索，缩短使用路径，赋予更便捷的对外能力。目前已有300+京东各设计团队入驻，涉及400+业务线，共同组成物料资源共享生态，实现设计资源互通共赢。 4.2 羚珑智能页面设计夸克平台将组件库能力服务于可视化搭建，通过夸克平台为「羚珑智能设计平台的页面设计」输送组件物料，优化研发效能发挥，助力用户可视化地快速搭建页面。 4.3 京东内部其他设计团队平台还将能力持续输出到京东内部其他团队中，如京东首页项目、京东数科、京东金融、7Fresh等。用物料原材料的方式不断提供快速发展的动力。 5、未来展望未来，会有更丰富多样的数字资产沉淀。物料种类在未来还会继续拓宽，让数字资产的触角涵盖更广，比如后续会考虑接入音效物料，视频物料，版权信息等。 同时，会强化更多端的触达能力，在物料的沉淀与输出赋予多端化、云端化。比如扩展资产沉淀的方式，增加 Figma 和 AdobeXD 等插件工具，尽可能地融入现有设计工作流中，为设计师提供便捷的获取和沉淀物料的能力。还可以与兄弟中台进行上云协作，作为中台上云产品的一部分，赋予云端产品全矩阵物料的能力。","pubDate":"Wed, 06 Jan 2021 13:01:06 GMT","guid":"https://aotu.io/notes/2021/01/06/quark-design-asset/","category":"凹凸"},{"title":"凹凸技术揭秘 · Deco 智能代码 · 开启产研效率革命","link":"https://aotu.io/notes/2020/12/31/deco/","description":"1、背景介绍近几年中台的兴起，团队围绕业务中台化这个场景，将我们已有的诸多能力进行解构、重组、积木化，希望能将拆解后的积木进行体系化地串联，从而达到降本增效的目的。 对于电商平台来说，每年都需要面临大量的大促活动页面需求，对于如何提高页面产出效率，大家都不约而同采用「页面可视化搭建」解决方案。对应的，我们也构建了「羚珑可视化页面搭建平台」。但近两年大促活动定制化需求井喷，平台有限的组件模块已无法满足产品运营需求，前端工程师也无法再用「复用」的思想简单地解决问题。当业务发展到一定程度，有限的人力以及冗长的开发流程更是无法满足蓬勃发展的业务需求。 我们需要「求变」，传统的人力密集型研发无法解决的问题，是否能用智能化的思想来解决呢？顺着这个方向，我们把目标瞄准了「前端智能化」，希望借助 AI 和机器学习的能力拓展前端能力圈，打通设计与研发的工作流程，实现规模化生产。 2、项目介绍Deco 智能代码项目是团队在「前端智能化」方向上的探索，我们尝试从设计稿生成代码（DesignToCode）这个切入点入手，对现有的设计到研发这一环节进行能力补全，进而提升产研效率。 在一个日常需求开发流程中，往往需要遵循固定的一套工作流程，产品提交需求 PRD，交互设计师根据 PRD 输出交互稿，再由视觉设计师输出产品视觉稿，接着再进入前端开发工作流。对于前端工程师来说，输入源是视觉稿 + PRD，输出结果是可上线的页面代码。 Deco 期望解决的是上述流程中，对于前端工程师而已相对低价值，以及可用复用思想处理的工作： UI 视觉稿还原，即页面重构，编写 HTML + CSS； 可复用的业务逻辑绑定； 以「设计稿生成代码」为切入点，我们需要用智能化的解决方案来替代传统的人工页面重构（分析图层样式+切图等），期望能从视觉稿原始信息中提取结构化的数据描述，进而再与智能布局等算法结合，输出可维护的页面代码。 3、技术方案设计稿智能生成代码能力的核心是如何生成一份「结构化的数据描述」信息，这份数据称为 D2C Schema。 Deco 设计稿智能生成代码主要做了两件事情： 从视觉稿中提取「结构化的数据描述」； 将「结构化的数据描述」表达成代码； 本质上，Deco 智能代码是通过设计工具插件从视觉稿原始信息中提取结构化的数据描述（D2C Schema），然后结合规则系统、计算机视觉、智能布局、深度学习等技术对 D2C Schema 进行处理，转换为布局合理且语义化的 D2C Schema JSON 数据，最后再借助 DSL 解析器转换为多端代码。 Deco 智能代码的核心链路构成了团队「前端智能化」探索的核心技术体系，围绕产研流程的体系化建设，结合 Cloud IDE、Taro 多端统一解决方案、设计研发资产平台，以及羚珑智能设计等能力，实现一个良性的产研闭环，为整体的工程链路降本提效。 4、智能代码技术分层Deco 智能代码核心链路现阶段主要包含组件识别、图层处理、布局算法以及语义化处理四大分层，下面会围绕这些细分的分层展开内部实现原理的剖析。 4.1 组件识别层组件识别层负责识别设计稿图片中的元素，包括业务组件识别、基础组件识别以及区块识别。通过识别能力，输出设计稿中与现有组件库组件匹配的部分，进行组件推荐与复用，并辅助后续处理层处理，比如语义处理层等根据组件属性进行语义化命名，提高生成代码的可用性。 4.1.1 组件识别组件识别层借助了AI能力，使用深度学习目标检测算法来进行识别，输入设计稿导出的图片，输出图片中的组件类别及组件位置。 4.1.2 数据集数据集是使用深度学习处理问题的大头，我们汇集了羚珑平台活动页数据、大促会场设计稿以及Relay平台数据，构建了含有2w+样本的组件识别数据集。其中，引入了自动化标注，通过对使用组件搭建的羚珑页面进行Dom结构解析，获得绝对精准的标注数据，减少人工标注成本。 为了进一步地丰富数据集，解决组件之间数量不均衡的问题，采用了自动化样本生成方案，基于Quark 官方业务组件库以及大促会场沉淀的 jdcop 大促原子组件库，支持十类样本生成。采用组件模版搭配随机属性的方式，由组件组成完整的页面，并在导出的过程中自动进行标注。 4.1.3 区块识别移动端设计稿大部分高宽比过长，有达到 10:1 以上的，且分布不均，不利于目标检测识别，由此，首先将页面划分为区块，区块识别算法基于传统图像处理流程，使用边缘检测以及漫水填充算法获得连通区域，设置过滤阈值留下楼层大小的识别框。 区块识别算法应用于图层处理层自动成组，优化图层的嵌套结构，助力于布局算法产生更合理的组件结构树。此外，将未识别区域自动划分为新楼层。通过固定高度限制，临近区块组合为一个更大粒度的区块，达到将不等高度的设计稿划分为高度相差不大的几个区域的效果，再投入目标检测网络进行识别。 4.2 图层处理层图层处理层主要将设计稿中的图层进行分离、合并、提取元信息，同时结合组件识别层智能成组、分类，导出第一份 Deco Schema DSL。Deco 工作流就像软件工程里的管道与过滤器设计模式，设计稿就是管道的入参，管道中的流就是每一阶段生成的 DSL，管道的输出是一份语义化代码。 图层处理层通过借助组件识别层的 AI 能力，智能识别设计稿每个区块，将区块内的图层信息合成一个组，再通过区块匹配算法自动匹配区块与图层，实现了设计稿的自动成组，成组数据有利于布局算法判断区块的层级信息和父子关系。 一份 Sketch 文稿是由若干图层元信息（分为 Document 和 Pages 等）和资源文件（主要是图片）组成的一个压缩文档（文件后缀为“.sketch”），我们通过对图层元信息进行加工处理后得到一份供布局算法服务处理的 DSL。 通过开发 Sketch 插件，使用 Sketch 提供的 API 能够帮助我们去操作 Sketch 里的文稿，拿到图层信息后，对这些数据加工、筛选等处理。图层信息的处理主要是分为两层： 设计稿加工层： 复制出一份原样的设计稿，在这份复制的设计稿上进行各种加工的操作； Symbol 解耦，将文稿中的 Symbols 解耦为实际的图层组； 筛选不可见图层，过滤掉设计师隐藏的图层以及空图层组； 图层合并，将一些特殊的图层或图层组合并，并转为图片； 蒙层处理，蒙层下的图片如果超出蒙层范围需要裁剪，同时蒙层下的图层位置和宽高信息需要重置。 图层信息处理层： 提取图层中有用的信息，比如样式处理、文字拆分、图层层级等； 图层信息的转化，比如将图片的 base64 位字符串数据转为 CDN 图片地址； 无用图层检测，将一些无样式或透明样式的图层去除； 图层打平处理，将图层数据由树状的层级打平为一维的结构； 成组信息筛选，将未成组的数据通过比对位置和大小将其归类到已成组的数据中。 下图是对图层信息的处理流程： 除了对图层信息的基础处理之外，我们建立了一系列的数据导出的优化规则，用于增加布局以及语义的合理性。比如在一些大促设计稿上，复杂背景图的设计可能是在一个图层组下由若干个矢量图形组成（如下图），如果原封不动地将这些图层导出，会给布局带来很多复杂度和不确定性。 在合图的这一流程中，针对一个图层组下所有图层都是矢量图形的情况，我们会将它合成为一张图片，这样会大大减轻布局的困难度。最终合图效果如下图： 当然，上面提到的这些优化规则并不能满足所有的情况，毕竟设计师是自由的。为了提高布局和语义的合理性，我们对入参的设计稿提了一些规范协议供设计师以及开发者使用。 4.3 布局算法层4.3.1 为什么需要布局算法布局算法是建立在输入源符合 Deco Schema 规范的数据，该数据规范可以通过 Deco Sketch 插件对视觉高进行处理，最终会导出设计元素信息。 经过 Deco Sketch 插件导出的元素数据，都是以左上角 (0, 0) 为坐标原点坐标的绝对定位为基础的元素信息，并且在一般情况下（无主动编组、无AI识别等等情况 ）元素都是扁平化的，也就是元素间没有从属关系。 在前端开发过程中，绝对定位布局无论是扩展性、可读性都达不到开发要求，那么如果不解决，就成为 一次性代码 。因此，需要布局算法来提高生成代码的扩展性、可读性，供后续二次开发使用。 4.3.2 布局层核心算法布局算法层的设计包含三大层：数据结构转换层、布局推导层、样式计算层。 4.3.2.1 数据转换层数据结构转换层是将 Deco Schema JSON 数据转换为类似 DOM 树的结构，可以进行节点插入、删除、查找操作。 下面是 LayoutNode 基本数据结构： 12345678910111213141516171819202122232425LayoutNode &#123; ...省略节点属性 ...部分节点方法 appendChild (child) &#123;&#125; prependChild (child) &#123;&#125; insertAfter (insertedChild, afterChild) &#123;&#125; insertBefore (insertedChild, beforeChild) &#123;&#125; replaceChild (newChild, replacedChild) &#123;&#125; removeChild (child) &#123;&#125; get x () &#123;&#125; get y () &#123;&#125; get width () &#123;&#125; get height () &#123;&#125; get offsetLeft () &#123;&#125; get offsetTop () &#123;&#125; get previousSibling () &#123;&#125; get nextSibling () &#123;&#125; intersect (node) &#123;&#125; contains (node) &#123;&#125; disjoint (node) &#123;&#125; tangent (node) &#123;&#125; hitTest (node) &#123; ...&#125; 4.3.2.2 布局推导层布局推导层则是进行行列分割推导，总体上包含：空间布局算法、投影布局算法、背景图布局算法、特征检测布局算法、坐标推导算法、背景图层及冗余图层检测算法等等。 空间布局算法 投影布局算法 其中特征检测包括标题、列表、Tab 等等一些列常见的布局检测。 4.3.2.3 样式计算层样式计算层，是对经过布局推导层得到的结果进行一系列的计算，而 Deoc 样式大部分布局采用 Flexbox，有些特殊情况需要使用绝对定位。在布局推导之后，Layout 结构已经有了明晰的层级关系及相邻关系。 基于层级关系，可以通过坐标计算得出 Flexbox 主轴、侧轴；基于相邻关系，可以计算出相邻之间的 margin 等等样式。 4.4 语义化层当设计稿数据经过布局算法处理后我们就能获得结构较为良好的代码，但此时我们会发现由于节点元素缺乏相应的语义化类名，代码依然不具备很好地可读性。为了最终能得到可以二次开发的代码，我们需要在布局算法层之后加入语义化处理层来让代码拥有良好的语义性。 语义化层首要解决的问题就是如何为元素节点加上具有语义化的类名。 为了实现这一目标，我们可以先回顾一下在我们开发的时候是如何给元素节点加上类名的，以如下的单个商品图为例。 上图是一个商品图的示例，我们会通过图片、价格、图片下方文案等因素来判断出这是一个商品，然后我们就可以给这一个区域赋予类名 goods ，而区域内的节点，比如图片可以赋予类名 goods_pic ，图片下方文案可以赋予类名 goods_tit ，价格可以赋予类名 price ，这就是我们为元素节点添加类名的一般逻辑。 可以看出，通常我们去确定一个区域，一个组件的语义时，我们需要依据区域内节点的语义组合才能进行判定，比如上面的商品组件，需要依靠内部的图片、价格、文案等元素才能确定语义，从而确定类名。因此，语义化的处理方式，就是从容器元素的子节点出发，先确定子节点的语义，然后再推断出容器元素的语义，一层层往上进行推断，最终推断出整棵节点树完整的语义。 在语义化层，我们主要的处理对象就是经过布局算法层处理后的 JSON Schema 数据，我们称之为布局树，此时布局树已经具备了良好的结构，我们可以对它进行语义化推断操作。推断的流程就是从树的叶子节点出发，一层层向上冒泡到枝节点，最后再冒泡到根节点。 目前我们进行推断的依据主要是节点的位置、样式、大小、兄弟节点等因素，同时会结合不同节点的类型，组合一些智能化手段进行辅助推断。例如，最小叶子节点一般可能为图片、文本两种类型，针对文本我们可以通过 NLP 的方式去分析文本的词性、语义；针对部分图片，我们可以使用图片分类或识别的方式确定图片分类或者提取图片上的关键信息进行图片的语义判定。 为了确定每个节点的语义，我们需要组合一系列的规则对现有的事实（样式、位置等信息）进行推理，而同时，经过一些规则推理后又会得到新的事实，又需要经过其他规则推理之后才能得到最后确定的结果。所以，这是一个基于规则推理的推理系统，我们可以通过实现一个正向链的推理引擎，来帮助我们进行推理决策。 例如，推断上述商品组件的过程，首先我们先找到具备价格因素的文本节点，命名为 price ，然后我们找到 price 附近，在树中所处层级相近的图片节点，并且该图片节点符合商品图大小的要求，这样我们就能基本确定同时包含价格和符合商品图特征的容器为商品容器，再根据容器中元素个数，图片附近是否有一段文本，以及对文本的 NER 分析，我们就能确定这段文本是否是商品名，从而确定其语义化类名。 在整个语义化层中，上述的判定规则只是冰山一角，我们结合整个电商场景，分析了大量设计稿与线上案例后总结了大量的判定规则来帮助我们进行合理化语义命名，同时在语义化过程中采用 NLP 分析、图片分类及识别等 AI 手段，我们将在后续专门撰写相关文章为大家进行具体介绍。 当然，得到节点类名只是语义化先阶段初步的成果，在未来我们将持续挖掘语义化，为后续字段逻辑绑定等实现打下坚实基础。 5、阶段性成果目前，在组件识别层、图层处理层、布局算法层和语义化层这四大核心模块我们已经去取得了关键性突破，已经可以实现对 Sketch 设计稿进行分析，将其转化成结构良好，具备语义化的，可以二次开发的代码，初步实现了设计稿到代码还原重构的阶段。 我们已经在大量的电商大促设计稿上进行测试，布局还原程度可达 90% 以上，而最终产出的代码可用率可以达到 80%，我们已经推动在部分内部业务中尝试进行使用。 6、未来展望未来，在上述核心模块完善的同时，我们将加入线上可视化编辑器，允许开发者对生成的代码进行人工干预调整，从而得到更好的代码，同时我们也将探索加入字段绑定和逻辑绑定的功能，让代码可以具备业务逻辑，让 Deco 具备 T3 左右工程师的水平，进一步提升产研的效率。 Deco 是一粒种子，也许它此时刚刚发芽，但我们对它期许颇多，我们希望通过 Deco 来探索前端智能化的道路，探索 AI 与前端结合的各种可能性，更重要的是，我们希望能够通过 Deco 开启产研的效率革命，在各种前端工程化、平台、方法论趋于完善的当下，探索为业务降本增效的另一种方式。 Deco 的未来，值得期待。","pubDate":"Thu, 31 Dec 2020 09:00:00 GMT","guid":"https://aotu.io/notes/2020/12/31/deco/","category":"人工智能"},{"title":"凹凸技术揭秘·羚珑页面可视化·成长蜕变之路","link":"https://aotu.io/notes/2020/12/31/ling-atom-design/","description":"前言京东零售集团 · 用户体验设计部打造的「羚珑智能设计平台」于 2019 年 5 月为内部运营及商家推出了智能页面设计工具，羚珑智能页面设计是一款在线可视化页面搭建平台，拥有在线搭建 PC、H5、小程序等多平台页面能力，覆盖频道页、活动页、店铺页、滑屏宣传页、答题类、互动游戏类、小程序等多个应用场景，为商家、运营人员提供在线服务，让不懂设计、不懂代码的用户也可以一键上线页面。 基于「Taro」强大的多端能力，能够实现一次搭建，生成 H5、小程序、RN等跨端应用，极大地解决重复开发的问题，提高开发效率。 聊聊羚珑智能页面设计的历史业务中求突破在 2017 年以前，京东线上大量的 PC 频道页都是通过手工开发的，开发周期非常长，当时公司内部也有一个 CMS 系统，前端开发完的页面，需要通过这个系统进行发布上线。整个页面的开发依赖这个系统，并且需要在线上完成这些工作。另外还要录入一些数据坑位，才能预览到页面。当时为了解决前端的开发效率，我们把线上开发及数据坑位录入的工作，搬到本地通过一系列自研工具完成。完全颠覆了整个频道页的开发方式，整体的开发思路沿用至今。 日积月累，我们手上已经开发了非常多的频道页，而且到后面发现，很多页面都非常相似，只是一些样式上的差异。当发现工作重复的时候，应该是造车的时候了，可以让我们跑得更快。 搭建平台雏形羚珑智能页面设计的前身，它只能说是一个页面拼装系统，有一位频道运营的同事找过来，希望能快速开发一个页面，问：“能不能把线上的某几页面中的不同楼层拼在一起，快速上线几个页面”，很显然对于不懂技术的人来说似乎非常简单的事情，但是对于我们开发来说，并非\b如此简单。我们尝试把不同页面的代码找出来，快速开发一个新的页面，发现很多问题，如样式冲突、脚本冲突等一系列问题。 于是后面我们对已有的页面，进行楼层级的改造，改造后的楼层，能够独立运行，并且不同的代码及样式只作用于当前楼层，这样，不同楼层组合出来的页面，能够正常显示。 经过改造后的公共楼层，为了让用户能够自由组合楼层去拼装出一个页面，我们搭建了一个在线可视化平台，把所有公共楼层以列表形式展示出来，支持通过拖拽形式组装页面，支持一些常规的属性配置，如公共头部、颜色等，基本上能满足部分用户诉求。 真正的可视化之路页面拼装系统的痛点页面拼装系统，它主要解决了开发及用户的一小部分诉求，离真正的可视化之路，还很远。很快拼装系统暴露了它一些问题： 在技术层面，由于楼层的粒颗度不够小，要做一些布局上的调整，需要调整到代码才能支持，缺乏一定的灵活性。以及使用过时的技术栈 jQuery，后期维护成本也非常高。 在用户运营方面，在我们的平台上不支持根据真实的数据预览效果，系统只是完成了页面框架搭建的事情。 在数据录入方面，还是难以摆脱前面提及的 CMS 系统，用户需要回到 CMS 系统上面填写真实的素材，所以存在不同系统之间的切换。 可视化编辑器设计思路给合拼装系统的一些问题，我们开始重新设计一款真正基于组件化的页面搭建平台。 羚珑智能页面可视化编辑器，包括几个基本核心要素：组件库、设计器、属性编辑。 组件库分为基础组件和业务组件，由于 PC 页面比较复杂，有布局的概念，所以我们需要设计一套布局系统，借鉴于业界优秀的栅格设计思想，再结合我们页面的实际情况，完成了页面的框架与基础组件设计。业务组件穷举了大量线上页面，把常用的组件进行组件化改造，并且支持灵活的属性配置。 设计器负责组件拖拽、组件加载、渲染逻辑、组件树操作、动态属性注入等功能。通过高阶组件的方式，能帮助我们轻松给组件添加一些特定功能。 属性编辑，组件每个属性都对应着一个类型，那么它属性数据编辑的方式也不一样。我们设计的类型基本覆盖所有组件。另外还设计了一套条件规则，让属性之间能够联动显示。 实际上要完成一个高可用的可视化编辑器，需要了解的知识点与细节非常之多，这里不做详细展开介绍。 经过近一年的沉淀，频道页开发已经从人工开发，全面转型为可视化，目前京东线上大部分频道页都是通过自助搭建方式完成上线。 编辑器全面升级2019年初，借鉴于过去在公司内可视化领域取得了小有成绩，我们产品方向重新定位为聚焦商家在线上经营过程中的页面设计需求，希望通过降低页面上线门槛，从而提高商家、运营人员上线页面的效率，因此，对页面可视化编辑器进行了一次迁往移动端的升级。整个视觉风格及交互方式，都进行了全面升级，去除了复杂的布局，用户使用起来更加便捷。 组件库升级我们把组件库升级为一个全新的平台「Quark」，它作为一个独立的设计资产平台。为编辑器提供组件、图标库等物料，目前已经沉淀的官方组件有50多个，200多种布局形态，能够满足大部分页面需求。同时还支持公司内部其他研发团队开发自己的组件，接入到我们的可视化平台中，通过我们的上线页面服务上线。 属性面板升级配置体验影响用户搭建效率： 用户在日常使用编辑器时，需通过更改组件配置项以满足页面个性化需求。我们发现，组件配置项的面板结构复杂、组件配置项理解成本高、操作方式不符合用户习惯等体验问题已经严重影响了用户的配置体验与搭建效率。 旧版组件配置项面板： 分类以「功能」、「样式」、「数据」做区分，用户理解成本高，经常出现同一配置项出现在多个分区的情况，极大增加了用户的操作成本。 新版组件配置项面板： 重新定义了面板结构规范，从用户配置操作行为区分，划分为「组件名称」、「组件布局」、「数据录入」、「样式配置」与「楼层配置」5大区域，不仅利于用户理解，缩短了用户的操作路径，对于产品本身而言，清晰的布局划分与功能定义还提效了新增组件的配置项拆解工作。 改版前 v.s 改版后 配置项面板整体结构分区、配置项元件化示意 元素编辑器当我们的官方组件无法满足用户个性化需求的时候，我们思考着能否为用户提供一种自定义组件的能力，所以元素编辑器应运而生。它提供了一个自定义画板的能力，用户可以自由拖拽一些基础元素，如文本、图片、图形等，添加上一些自定义事件和动画，一个生动的的自定义组件，便能轻松完成。 设计资产沉淀设计师沉淀了上千套模板提供给用户使用，这些模板全部接入「羚珑」智能图片设计能力，用户能够直接在线修改图片素材内容，轻松实现高质量的页面。另外我们的模板还支持智能配色，用户可以根据配色方案进行页面整体换肤。 羚珑智能作图为解决用户做图的痛点，羚珑页面编辑器与羚珑图片编辑器深度结合，为用户提供在线图片编辑的能力，用户无须使用一些做图软件，便能在线上完成图片编辑。 多应用场景适配活动场景我们的活动页是如何完美适配移动端和桌面端的呢？ 一个移动端页面要适配桌面端，通常的做法是通过响应式的手段来实现，这种方式比较简单粗暴，但是效果其实并不好，例如移动端的首焦图，如果在桌面端等比放大，那将会占满首屏，用户体验极差。 所以我们采取了一系列的转换规则来实现： 举个例子 PC端的内容其实是跟移动端的内容做了对应关系。并且根据端的特性做了一系列通用的变换规则。比如秒杀商品中秒杀倒计时与商品在移动端为上下布局，而在PC端则为左右布局，商品单元在移动端为一排2个，在PC端则增加为一排4个。 转化的规则是什么？拉伸： 在布局不发生改变、内容没有增减的情况下进行拉伸，如广告组模块： 文本： 文本内容较重要时我们会做无增减的拉伸，当空间位置受限，同时文本内容又不是非常关键的信息时会选择文本截断的方式进行拉伸。 图片： 一般来说细节图去做等比拉伸，这样尽最大可能的保证两端效果的一致性。 由于移动端宽高比相比 PC 端要小很多，为了保证在大屏上的效果不至于出现“霸屏”的情况，还会有取舍的进行裁切。 模块： 移动端通常会将一个楼层划分为一个模块，对应到PC端会将模块在横向进行拉伸。 布局改变： 布局发生改变时需要将元素进行重排 如头图banner模块，如果采取等比拉伸的策略会导致头图特别高，在 PC 端影响第一屏的页面效率，如果采取裁切的形式将会影响图片的展示效果，所以采取图片内元素重排的形式进行变化。 锚点导航模块在移动端是横向的导航，上滑页面时会吸附到页面的顶部，而在 PC 端我们一般会吸附在页面的侧边固定位置。 内容增减： 单元重复展示模块一般会用内容增加和删减的形式来处理，比如商品模块在 PC 端横向空间比较大的情况下会多展示单元格数。 结合这些转换规则，能让用户只要搭建一次页面，便能快速同时生成两端活动页，投放到移动、PC端平台，节省运营成本。 互动营销场景过去商家想做一个互动类的页面，基本上是很难实现的。有着成本高、开发周期长等问题。互动营销场景为了解决这一系列痛点，把互动玩法进行组件拆解，再通过页面可视化平台进行配置上线。原来一个互动玩法从方案到上线大概需要一个月左右，现在通过可视化搭建方式只需要十分钟，大大提高了效率。 小程序场景我们是京东内部首个小程序可视化搭建平台，借助「Taro」的跨端能力，我们平台天然具备了发布跨端小程序页面的能力，结合京东「开普勒平台」的黄金流程，快速产生一套完整的电商小程序代码。支持发布微信、百度等多个小程序平台，完成「九阳」、「戴森」等多个商家小程序上线。 店铺场景店铺场景下，我们实现了三个重要的应用场景： 店铺首页，为商家提供店铺首页搭建的能力，并实现了把设计结果与「京东智铺」的素材打通，满足商家店铺首页装修诉求。 店铺推广，一个基于元素编辑器扩展的场景，提供滑屏类页面活动搭建的能力，提供了极具个性化宣传页能力。 店铺购物小程序，以中心化小程序的形式为商家提供私域流量工具，提供丰富的营销工具，如抽奖、关注有礼、全景馆等多种玩法。 编辑器积木化为何要做编辑器积木化？ 随着场景越来越多，编辑器的代码逻辑也变得非常复杂，不同场景都有一些特殊的功能逻辑，每个场景又分为模板搭建端和用户使用端，在编辑器中的表现形式不同，而且编辑器与平台的业务逻辑强耦合。 公司内部很多平台，都有可视化搭建的诉求，如果重新开发一个可视化编辑器，少则至少需要半年时间。如果直接复用我们的编辑器积木，将会大大提升效率。也减少公司内部重复造车的情况。 我们编辑器的研发团队人力有限，不能及时满足各场景的需求，扩展性差。 改动一个小小的功能，整个编辑器都需要发布，如果出问题，所有场景都受影响。 编辑器的功能越来越多，体积也随之上升，时间久了，整个编辑器变得非常臃肿。 为了解决这些问题，我们进行了一次编辑器的架构全面升级 基于配置的插件化架构我们将编辑器划分为：主设计器 + 插槽区域，分别用两种颜色表示： 主设计器：负责编辑器核心逻辑，配置文件解析、插件加载器、组件加载、全局状态管理等； 插槽区域：编辑器会预留几个主插槽位置用来加载插件功能； 我们大致来了解一下整个编辑器的工作流程： 编辑器读取配置文件，配置文件是对整个编辑器的描述，包括所有插件的配置。 编辑器中提供几个核心位置以插槽的形式，读取配置文件中的插件。 编辑器的功能抽离成一个个插件文件，通过异步的形式进行加载，这样做的好处是可以按需加载、逻辑解耦、有利于提高系统的扩展性。 每个插件加载可以动态注入到编辑器应用中，同时它能够共享编辑器的状态，完成插件之间通讯以及调用编辑器的数据和方法。 编辑器实际上只做一件事情，就是页面描述的生成，其他业务逻辑交业务侧做，这样的好处是能使编辑器完全解耦独立运行。只需要做一些与编辑器、插件的通信接口，就能快速使用起来。 各使用场景只需要关注自己的编辑器应用配置即可，互相不影响，包括插件个性化升级。 对外赋能应用目前，我们的编辑器积木化解决方案已经应用在京东内部其他平台当中，如京东数科江湖平台、京东ME行业版平台等，作为页面设计引擎助力各平台的商业化快速发展。 结语目前为止，业界有很多优秀的页面可视化产品，为何一直没有尽头，一直有新的平台出现，但都没有最终极的解决方案，那是因为没有真正的「银弹」，只有适应业务发展的产品，才是最适合的。未来我们将会往智能化页面设计的方向努力，必然会擦出新的火花，敬请期待！ 参考 羚珑组件智能编辑新体验 揭秘羚珑页面-多端智能转换 智能页面引擎全新亮相 页面设计中台初长成——架构篇","pubDate":"Thu, 31 Dec 2020 04:00:00 GMT","guid":"https://aotu.io/notes/2020/12/31/ling-atom-design/","category":"凹凸"},{"title":"凹凸技术揭秘·羚珑智能设计平台·逐梦设计数智化","link":"https://aotu.io/notes/2020/12/25/ling-ai-design/","description":"1、简介羚珑智能设计平台是由京东零售集团用户体验设计部打造的在线设计服务平台，专注于泛零售领域的设计，帮助客户解决日常经营过程中所碰到的各类设计需求，例如商品上新时的商品主图视频、各种节日大促时的商品主图更新，还有直播带货场景时所需要的各种设计物料等等。 羚珑致力于成为泛零售领域商家、运营生意经营中的设计好伙伴，助力他们实现设计数智化，从而实现设计层面的降本提效、提升设计结果（广告图、视频、页面等）的商业转化效果，这是我们的愿景和使命。 从技术和功能形态层面，我们把设计数智化分成了两个方向，一个方向是「模板化设计」，另一个方向是「程序化设计」。 2、模板化设计「模板化设计」的核心目标：是实现线下设计物料的数字化，在数字化设计资产的基础之上，构建广告图、短视频等可视化设计能力，为我们的终端用户提供所见即所得的在线设计 SaaS 平台。「模板化设计」为客户提供三大核心设计能力：图片、动图、视频，还有常用的在线设计辅助工具，此外通过能力的整合打包，以「羚珑企业专区」的产品形态为企事业单位提供完整的数智化设计、可视化设计的解决方案。 2.1 图片设计，让泛零售营销场景下的广告图触手可得我们提供了大量契合泛零售垂直领域的设计模板，只要客户有卖货做设计的需求，便总能在羚珑平台上找到所需要的，配合功能体验持续迭代的「图层编辑器」，用户只需根据图片使用场景选择心仪的设计模板，进行所见即所得的简单操作，即可快速制作可直接用于投放的广告图；同时还提供「尺寸扩展」、「智能配色」等功能，帮助用户丰富广告图最终的设计效果，满足更多的使用场景。 「图片设计」的能力目前还提供了嵌入式使用的 PaaS 解决方案，第三方的系统平台可以借助该方案来集成羚珑的图片可视化设计能力，构建自己业务的设计解决方案。目前「嵌入式图片设计」方案被京东内部多个核心营销平台所采用，例如商家装修店铺时使用的智铺，通过接入羚珑的图片设计能力，支持商家高效低本地完成店铺装修所需设计素材的制作。 2.2 动图设计，简单两步让静态图动起来5G 高速网络的逐渐普及，流量和速度的大幅度提升，Web 应用、APP 以往对媒体素材尺寸、性能的苛刻要求将逐渐成为历史，越来越多的场景开始尝试使用动图视频来丰富视听效果，提升商业转化率。相比静态广告图的制作，动图需要设计师具备动画方面的专业知识，设计成本要高出数倍。羚珑平台提供的动图可视化设计，由专业设计师将常用的动效沉淀为可复用的数字资产，再通过与图片模板的精心设计和组合，从而得到用户可以直接拿来即用的通用的动图模板，用户只需要替换主图、填写利益点文案，简单的两步操作即可生成效果突出的动态广告图，大幅度降低了设计的门槛和成本。 2.3 视频设计，轻松制作视听带感的短视频素材视频相较动图，它具有更细腻的动态效果，还可以加入带感的背景音乐，是视听表现最为丰富的媒体素材，具有极高的设计制作成本。羚珑提供的视频可视化设计解决方案，抹平了成本鸿沟，让用户依然能够像制作静态广告图一般简单高效地制作视频。视频可视化设计解决方案，提供了两个核心的编辑器。一个是面向专业设计师的后台编辑器，帮助他们实现动态素材（GIF、AE 动画、帧动画等）的数字化管理，同时提供了灵活的图层控制、丰富的动效和动效素材以及特殊音效，让设计师最大限度的发挥创意，创作视频模板。 另一个是面向终端用户使用的前台编辑器，基于设计师已经设计好的视频模板，用户通过组合图片和文案，即可高效制作视听效果俱佳的短视频。 羚珑提供的动图设计、视频设计能力，与图片设计一样，在京东内部系统平台也得到广泛的集成应用。 2.4设计工具箱，为你打磨实用的图片后期处理利器想对已有图片做后期加工处理么？来看看羚珑的设计工具箱吧。 一键智能抠图 -在线抠图，不用PS也能获得透底图 商品打腰带-商品图批量打腰带，省时不费力 图片批量编辑-批量裁剪、修改尺寸和压缩转格式 ….2.5 企业专区，让每一个企业拥有完整的在线设计解决方案 面向企事业单位提供设计数智化赋能的 SAAS 服务，提供了包括素材在线管理、标准化合图、快速页面搭建、自定义组件编辑在内的一整套解决方案，让企业无须投入开发成本，即可在日常运营的固定位置更新以及组织促销活动等场景中，规范化、流程化、标准化地进行设计输出。 羚珑企业客户 - 乐信（https://www.lexin.com/） 3、程序化设计「程序化设计」的核心目标是利用大数据挖掘、人工智能等技术手段，结合用户的设计画像，为不同的人群输出不同风格的设计手法，助力千人千面等精准营销场景，提升转化率，所用到的技术主要包括数据挖掘、计算机视觉、机器学习。 「程序化设计」最大的特点是「极速」和「无人运营」，适用于需要海量快速生成图片的业务场景。在京东的一个典型应用场景是京东 APP 首页焦点图的千人千面，其针对不同用户结合用户画像生成不同的设计结果，每天处理数以亿计的图片生成请求，这些依赖人工运营是根本无法达成的。 基于「程序化设计」相关技术能力的应用，我们达成了设计大幅度降本提效的基本目标，以往设计师可能半天才能做好 1 张广告图，现在 1 台机器的 1 个进程，每秒就能做好几张图，大大节约了设计成本。 除了降本提效，设计结果商业效果的提升也是「程序化设计」十分重要的目标。 我们已经开始在广告图片商业价值层面进行探索和论证：根据不同用户的画像、设计偏好，生成不同风格的广告图片，从而进一步提高广告图片的商业点击率（CTR）。这种依据用户画像、设计偏好进行程序化设计的新模式，我们称其为推荐型设计。 智能推荐型设计是一个复杂的系统工程，可以拆解成若干个图片智能化相关的技术课题，接下来为大家稍作介绍。 3.1 设计画像3.1.1缘起在推荐搜索模型构建中，我们会为用户构造大量的标签，比如像年龄、性别、城市、品牌偏好、品类偏好等，这些标签最后勾勒出一个用户的形象，我们把它定义为机器识别的数据化形象，行业内的叫法是用户画像。 借鉴于用户画像，我们开始思考用户在图片视觉领域是否存在类似的偏好，更通俗讲人的审美是否会因为每个人而不一样？ 3.1.2论证关于用户设计审美偏好的答案，有一篇文章（ 《浙大女教授扎心发现：可乐包装上的字体可能正在算计你的钱包》）的结论让我们印象深刻：使用圆润可爱的字体会更能让用户对可乐产生喜爱的情感，进而让用户产生消费！ 这篇文章告诉我们，除了内容，设计本身似乎也能影响商业转化率，我们决定在京东实际的业务场景使用一系列的AB测试实验，依靠数据来进一步佐证它的结论。 实验一：不同字体曲率对CTR影响研究 场景：APP的核心入口首页banner图上 通过监测数据我们得到一些结论： 儿童品类或女性偏好度较高的品类可以考虑通过圆润属性的字体来提升用户对商品的喜爱程度； 品牌认知度较弱的品类可以考虑用过圆润属性的字体来提升用户的喜爱程度； 针对女性用户/25岁以下的年轻用户进行营销时，可以更多考虑通过圆润属性的字体来提升用户对商品的喜爱程度。 不同年龄的男性女性对于字体的偏好也不太一样 实验二：不同色系对CTR影响研究 场景：APP/PC的核心入口首页banner图上 实验三：不同布局对CTR影响研究 场景：APP/PC的核心入口首页banner图上 基于以上实验的数据分析后，我们得出一个结论：不同人群在设计上确实存在偏好关系。 3.1.3实践标签（偏好）数据加工的流程：首先客户端埋点上报用户的操作行为数据（主要是点击、浏览、搜索等），其次对数仓hive表中的数据做清洗、特征计算，然后标签落库，最后提供相应接口。 步骤一、数据清洗 前端上报的数据落在数据仓库里，点击、曝光流量模型里面包含了各个业务的埋点数据，而我们需要清洗出针对于广告焦点图的用户行为序列数据！ 用户行为序列数据模型示例 user 模板id 时间 场景 sku_id 曝光次数 点击次数 x_747b7b44d9bc2 01 2020.11.1 App首焦 23111 12 3 x_747b7b44d9bc2 02 2020.11.1 Pc首焦 21222 12 3 x_747b7b44d9bc2 03 2020.11.2 xxx 2333 4 1 x_747b7b44d9bc2 04 2020.11.2 xxxx 8333 3 0 … … … .. … … … 模板标签模型示例 名称 字段 字段类型 枚举值示例 模板组ID ps2id string 5c122d3d82acdd181d18292c 预览图 url array [‘URL1’,’URL2’] 场景类型 scene int 1-首焦 设计类型 design int 1-图片；2-页面 色系 color string 蓝色 布局 layout string 左图右文 按钮 button string 有 背景风格 bgstyle string 简约 步骤二、统计分析 重行为难题： 当我们在给用户构建品牌偏好时，经常会关注到用户在该品牌下产生了哪些“重”行为？“重”行为可以理解成用户为了做某件事付出了比较高的操作成本，比如用户是否特意搜索了某个品牌的商品。 我们在讨论设计画像方案的时候，几乎找不到方法去定义这种“重”行为，所以常规的套路好像并不适合用来构建设计画像！ 经过讨论后，我们决定返璞归真回到最初的统计学的方式，假定如果用户点击某个颜色的广告图多，那就证明用户对于该颜色存在一定的偏好，然后借助于显著性检验来验证数据是否显著，得以确定最后的标签权重！ 显著性检验： 显著性检验作为判断两个乃至多个数据集之间是否存在差异的方法被广泛应用于各个科研领域。 步骤三、标签落库 当我们跑出来用户标签数据后，最后其实只是一个工程问题，把相应的数据落到对应的表里。然而实际情况却要复杂的多，仍然会存在问题：数据量偏少，不足于覆盖大部分用户！ 接着又衍生出了 look alike 这种人群标签的方法，也就是我们的用户可能是完全没有数据的新用户，这个时候期望通过匹配相似人群的标签作为最后的标签结果。 算法模型 除了统计学的思路，我们还在探索用另外一种方式去构建设计画像，使用模型训练输出标签。之前也说过偏好问题可以认为是一个分类问题。 常用的分类模型主要有以下两种： 分类模型 优点 缺点 决策树 根据决策树可以很容易地构造出规则，而规则通常易于解释和理解；决策树可很好地扩展到大型数据库中，同时它的大小独立于数据库的大小；决策树模型的另外一大优点就是可以对有许多属性的数据集构造决策树。 处理缺失数据时的困难，过度拟合问题的出现，以及忽略数据集中属性之间的相关性等。 朴素贝叶斯 有稳定的分类效率。对小规模的数据表现很好，能够处理多分类任务，适合增量式训练，尤其是数据量超出内存时，我们可以一批批的去增量训练。对缺失数据不太敏感，算法也比较简单，常用于文本分类。 需要知道先验概率，且先验概率很多时候取决于假设，假设的模型可以有很多种，因此在某些时候会由于假设的先验模型的原因导致预测效果不佳。 目前我们正在尝试使用决策树类模型 XGBoost 实现标签训练输出，它支持各种语言调用，支持单机和分布式，支持 libsvm 的稀疏矩阵的数据格式。 3.1.4展望和目标设计画像是智能设计基础能力中的一环，结合程序合图，为不同的人群输出不同风格的设计手法，助于千人千面、千人千场等精准营销场景，提升商业转化率。 3.2 实时合图我们面向开发者、第三方系统平台提供了服务端快速合成图片的接口，开发者可以根据自身的业务诉求集成羚珑的程序化设计能力，构建自己的设计引擎。 「实时合图」在京东最大的应用场景是京东 APP 首焦轮播广告图的千人千面，根据不用访客的用户画像和购买行为数据分析，实时合成并推送精准的广告图，提升其商业转化率（CTR）。 它的核心就是通过 C 去实现了合图的底层引擎，然后通过 NGINX 扩展的形式注入到 NG 里面，通过 LUA 脚本来控制各个业务上层的逻辑配置。 此外，羚珑实时合图方案的一大亮点在于 CDN 兜住了绝大多数请求，能有效降低真正回源的请求量。 CDN是一种加速内容分发网络，通过多节点的形式，让用户访问到离用户最近的节点资源，从而达到让内容快速呈现给用户的技术，简而言之，我们可以理解为缓存。 3.3 智能配色在羚珑网站上作图，都能体验到智能配色的功能，从而大大提高图片丰富性，做到一键切换图片风格。 基于图像智能识别技术，对图像色值进行精准识别，通过像素级别的色值替换，实现图片色彩风格的智能变换，保证配色结果的风格与质量。 3.4 智能抠图智能抠图基于京东drawbot和 么么照 的能力进行构建，前者擅长商品抠图，后者适合人像抠图。目前这两种抠图能力都可以在羚珑平台上体验，另外也提供接口方式内外赋能。 3.5 智能排版基于知识图谱的推理能力，我们构建了一套适用于泛零售领域的广告图片排版技术，通过知识图谱可以让图形在任意尺寸下自动适应画布，并添加合适的图元。 3.5.1任意尺寸Banner图合成我们建立了一套基于知识推理的方法，从简单到复杂的递推迁移实现了banner图任意版式结构的构图，利用机器学习算法学习大量的优秀设计师模板中的布局参数，智能化的构建出符合人眼审美的排版构图，使用模型的泛化能力实现了任意尺寸的版式合图能力。 3.5.2任意形状图形排列为了增加素材的丰富性与层次感，我们对一些基本图形或文字进行叠加组合，生成复合型的素材，使用场卷积堆叠算法，对图元生成卷积核在目标区域内卷积扫描，填充并目标轮廓区域，实现了任意形状轮廓的图元排列与叠加效果。 3.6智能背景尺寸拓展是设计需求中经常碰到的一个痛点，一张广告图片，经常因为要下发到不同的客户端，需要做不同尺寸的版本。这个过程我们会碰到一个很大的问题，静态的背景图片没有办法很好的适应于各种尺寸中，它不像矢量素材一样，可以任意的放大或缩小，而矢量背景素材却又具有很大的设计成本。因此，我们希望可以利用程序算法动态生成任意尺寸的好看好用的背景图素材，它具有矢量背景素材的特性，又具有极低的生产成本，这是羚珑智能背景课题研究的初衷，是实现 AI 无人化设计的难题之一，我们现在就在路上。 利用机器生成的背景，在创意层面会有一定的局限性。我们觉得以下几种类型的抽象背景素材具有机器生成的可行性。 3.6.1粒子 + 渐变将大量的粒子和深色的渐变相叠加, 可以生成类似科幻大片中的背景效果图, 非常适合用作电子产品的背景图。通过对粒子大小, 色彩混合模式, 随机性等参数的修改, 可以生成更多特殊氛围效果。 3.6.2形状组合纯形状组合的背景具有很强的通用性, 可用于各种品类的商品, 它是由算法生成一些随机形状组成, 并根据用户喜好风格匹配一套配色方案对图形进行着色。 3.6.3渐变+装饰用装饰图形和渐变背景色融合也是常用的背景生成方案, 通过对装饰图形类型、层数、融合模式、位置等参数修改, 使得这类背景图生成方案通用性极强, 可以演化出千变万化的背景素材。 3.7 风格识别我们基于深度学习，构建了风格识别的预测模型，可以从图片信息识别出风格特征元素，自动判别图片设计风格。风格识别的技术，能够在类似京东 APP 首焦广告图千人千面等精准化营销场景中得到应用落地。 3.8智能识色一款颜色提取工具，通过提取图片像素点的 RGB 值，再做一个归类排序，最后通过算法由 RGB 转化为普通人可理解的颜色（红、蓝、黄、绿等）。 #### 3.9 美学评估模型美学评估我们处于调研阶段，未来应该会结合智能生成来作为自动生成图片评分的标准之一。 4、结语 - 智能设计的未来羚珑目前基于数字化的设计资产，解决了设计效率和设计成本问题，但背后依然依赖设计师的资产输入。未来我们想实现真正意义上的无人化设计，利用大数据挖掘分析和机器学习等技术手段，打造一个虚拟的「AI设计师」，让它能够和现实中的设计师一样，做出好看且效果好的广告图或短视频。未来的人类设计师，可以花更多的时间去理解业务和思考设计创意，把很大一部分的设计执行工作交给「AI」。 参考文献： 图像质量评估模型","pubDate":"Fri, 25 Dec 2020 04:00:00 GMT","guid":"https://aotu.io/notes/2020/12/25/ling-ai-design/","category":"人工智能"},{"title":"凹凸实验室的过去与未来","link":"https://aotu.io/notes/2020/12/24/aotu-5-year/","description":"凹凸实验室的过去与未来 凹凸实验室隶属于京东零售用户体验设计部（JDC），成立于 2015 年秋冬之交，诞生自深圳前海之滨，至今已走过 5 个年头，5 年的时光穿梭而过，凹凸实验室也不断发展壮大，从曾经专注前端的团队成长为如今涵盖前后端、全栈、算法、测试各类方向的全能型研发团队，工作模式也从传统的人力密集型研发转向创新型平台体系化研发，如今，凹凸的各类技术输出与沉淀在业界影响深远。 星火2015 年，凹凸实验室的前身多终端研发部成立刚好一年，彼时的多终端研发部，虽然是一个拥有 20 多位开发人员的独立前端研发部门，但更多的是在支撑着公司内部的各种业务的研发，从微信手 Q 的购物业务到京东商城的营销活动、拍拍网，以及京东云的大改版，业务的类别五花八门，作为一个工线支持部门，每天在各类业务开发中穿插，协助各类业务需求的开发。 2015 加入凹凸实验室的同仁 在此期间，部门也产生了很多精品业务，凭借着在 H5 动画方面的造诣，在京东内部小有名气，每到一些大促的时间节点都能收到很多的业务需求，这让团队开始在京东内部开始崭露头角。 H5 动画作品合集 在这一阶段我们也产生了很多优秀的文章，不完全列举： 精致化页面重构，by NONO 以电影之眼看CSS3动画（一），by 凹凸一姐 以电影之眼看CSS3动画（二），by 凹凸一姐 前端优化不完全指南，by 暖暖 同时，在沉淀了大量精品的 H5 业务之后，我们也开始尝试打造一个可视化搭建工具 HiPage，通过拖拽搭建的方式就能将沉淀的 H5 动画元素组合出新的 H5 页面，实现快速上线，得到业务方的一阵惊叹。这是我们第一个颇具意义的技术产品，它既服务好了业务方，也满足了我们作为技术人员对技术的追求，同时也为我们埋下了关于团队方向思考的引子。 作为技术团队，我们一直在思考，我们所能做的是否仅仅只是服务好业务就够了？或者换一个角度，作为一个工线部门，我们除了努力把业务做好，还能再做些什么？ 2015 年 9 月，一个燥热的周五晚上，在白石洲的鸡煲大排档里，关于上面的问题，关于团队的发展，关于团队的未来，团队里的几位大佬一边吃着鸡煲，一边激烈讨论。最终，留着一头飘逸长发的老黄掐灭手里的烟说道，“我们要做深圳最知名的前端团队”，在场的大家听罢后都陷入了沉思。 彼时落入大家心中的是一点点星火，似乎点亮一丝丝前方的光明，但是，星星之火，可以燎原。 一个月后，凹凸实验室正式成立，朝着 “要做深圳最知名的前端团队” 这个目标，团队的所有小伙伴都充满干劲。很快，我们和设计师通力合作，设计了沿用至今的团队 Logo。 同时也确定了我们的团队的理念：开放、开源，凹凸实验室的名字也来源于此，这一理念灌注在团队血液中，为之后的技术产品研发奠定基础。全新的团队官网也建立起来了，这个官网承载了不仅仅是团队小伙伴的技术文章，同时也是一个个关于技术梦想的追求。团队内也开始举办各类技术分享、编程马拉松，组织各小组的 Code Review，整个团队的技术氛围开始形成，凹凸如一个蹒跚习步的孩童，不断摸索，不断向前，磕磕碰碰，但不失朝气。 沉舟侧畔千帆过，病树前头万木春。 成长回顾我们思考的疑问，我们在建设一个具有一定规模的前端团队的时候，其目的是否仅仅是服务好业务？ 我们给出的答案是否定的。 正如凹凸灵魂导师老黄的文章《关于前端团队架构的思考》中所说的。 这个就好比一个人活着不能止于「有食可进有衣可穿」这种基础的物质条件，团队也同样有「精神层面」的内涵，具体如： 影响力 创新力 技术视野 这些「精神层面」的东西看似很虚，但实际上会以另外一些形式正向的反馈给团队，间接影响团队服务业务的过程甚至结果。建设团队在公司内外的影响力，可以营造团队的专业口碑，吸引优秀的专业人才主动加盟，而优秀的人才对于团队高效处理业务需求或研发需求的能力具有促进作用。 于是我们开始关注如何服务好业务的同时，提炼我们自己的技术产品，以业务为盾，以技术产品为剑，去打造我们梦想中的技术团队。 从业务中来，到业务中去时间来到 2015 年末，此时凹凸承接的业务呈现暴涨的趋势，各类业务接踵而至，为了更好地应对业务增长带来的人力瓶颈，我们加速探索前端工程化，期望使用工程化的手段来解决前端模板化、组件化、自动化开发的问题，并推出了凹凸实验室第一个比较完善的开源产品 Athena。当然以现在的眼光来看 Athena 并不是一个优秀的产品，它的文档很糟糕，可扩展性几乎为 0，但在当时还是支撑起了团队大部分业务的开发，为业务研发增效提供源源不断的动力。请参见我们是如何做好前端工程化和静态资源管理。 在打磨好工程化工具后，我们团队也终于迎来了非常重量级的业务——京东商城 PC 首页改版，此时 PC 首页依然承载着非常多的流量，改版的工作备受重视，而同时首页的复杂度特别是对性能、体验、稳定性的要求远远超出了我们过往的项目，秉承团队过往打造精品业务的理念，我们想要将 PC 首页这个项目做到全方位的极致。所以承接项目的小伙伴压力山大，在奔赴北京熬了一个多月后，项目终于顺利上线。当双 11 前夕，线上首页稳定顺畅地出现在办公室一个个显示器上的时候，我们难掩心中的激动，互相击掌庆祝彼此的胜利。具体请参见京东2016版首页改版前端总结。 而在 PC 首页上线之后，为了进行更好地项目管理，同时保证项目流程自动、稳定地运行，我们开发了统一上线平台，可以进行项目管理、自动构建、构建后代码 diff 、项目操作日志以及一键发布和回滚等操作，极大地规范了项目流程管理工作，同时将项目的上线统一进行管控，大大降低了项目出现线上问题的可能性，开始为工程化补全串联研发流程的工作，也为后续我们开发一站式云端产研平台提供了宝贵经验。 但是工程化带来的提效，远远跟不上业务需求增加的速度，为了应对层出不穷的业务需求，17 年，我们在 HiPage 的基础之上，继续探索页面可视化搭建，期望通过建设高可用的可视化搭建引擎，配合海量的（想象中）模板和组件，产出一套 No Code 系统，让运营或者可以自己搭建页面直接上线。于是诞生了内部代号为「Atom」 的页面搭建平台，帮助内部快速上线了几千个页面，凹凸实验室在业务方那儿成为了“活儿好”的代名词。 同样是 17 年，随着京东商城业务的蓬勃发展，传统的设计师作图，业务方套模板生产广告图等物料的方式已然非常落后，生产效率低下极度依赖人力，同时也无法满足越来越多的个性化图片需求，为了应对这样的场景，我们开始打磨羚珑智能设计平台，通过海量图片模板和基于用户数据实时合图能力，解放了设计师的双手，也节约了业务方获得高质量图片的成本，让每个人都能轻松完成图片制作。 拥抱开源技术的初心依然是 17 年，这一年我们在不断提升业务支持，围绕业务打磨技术产品的同时，在开源上我们也在不断奋进。这一年京东商城的前端主流技术栈还停留在 jQuery，而对于我们的业务来说已经无法忍受 jQuery 带来的研发效率低下的困境，我们开始探索新的技术栈，经过缜密的调研后，开始着手开发类 React 框架 Nerv，在内部业务经过一番验证后，开始在 GitHub 开源。凭借着当时团队大牛澈哥的出口转内销的推广策略，Nerv 开源第一天登上 GitHub 的 trending 榜，迅速斩获了上千 Star，这对于以开源为理念的我们来说，无疑是振奋人心的。请参见Nerv - 京东高性能前端框架。 时间匆匆忙忙来到 18 年，彼时对于业务来说又迎来新的挑战，各类小程序平台层出不穷，为了应对业务拓展渠道的需求，我们开始探索多端统一开发解决方案，并迅速推出了 Taro，实现开发一次，同时生成多端应用，凭借着对 React 语法的独特支持和一天 3 个版本火线迭代的速度，Taro 成为诸多开发者喜爱的解决方案，帮助很多业务上线多端应用，Taro 也成为凹凸实验室的一张技术名片。请参见多端统一开发框架 - Taro。 Taro stars 数破 2w 庆祝会 向全栈迈进而为了应对内部业务的数据服务请求，以及内部诸多的自研平台系统，凹凸实验室又自建了后端研发团队，为各大系统平台提供坚实的后端服务，为业务封装各类微服务方便调用，同时也在数次大促节点抗住了流量压力，团队的技术栈已经不再局限于前端了，开始向全栈模式转变。 平台化转型18 年 19年，我们在不断对我们的各类工具系统进行打磨，做好能力储备。而与此同时，中台的概念兴起，我们团队也开始探索设计研发在中台领域的地位，开始打造公司的设计中台。我们深刻地认识到团队除了对人才的培养之外，更应该关注团队研发资产的沉淀，工具、平台系统、研发组件这些都是团队宝贵的研发资产。而除了不断进行研发能力建设和储备的同时，我们应该将这些已有的能力积木串联起来，成体系化地对外进行赋能，从而实现传统的人力密集型研发向创新型平台体系化研发的转变。 破局2020 年，20 年代的第一年，从开年就注定是不寻常的一年。这一年我们也从宝安中心的龙光大厦搬到了前海内的卓越前海壹号。 今年，是凹凸实验室成立的第 5 年，5 年过去，团队的技术沉淀已然成型，曾经“开放、开源”的初心理念也未曾忘却。而在这一年我们对团队的能力积木做了一次重新的梳理，并思考如何进行体系化串联。 造积木回顾过往，我们已经做了非常多的技术储能，并且团队的技术产品发展是全方位地进行，从智能设计到产品研发，基本每个领域都有我们探索的印记。 在图片和视频能力上，我们打造了 羚珑智能设计，可以通过海量图片模板和基于用户画像的智能算法实现图片和视频的智能生成。 在多端适配与框架能力上，我们打造了 Nerv，并从 Nerv 的中孵化出了 Taro， 可以实现一次开发，生成多端应用。 在可视化搭建能力上，我们从 HiPage 时代开始一步步探索， 到 Atom 时代可以搭建各类营销页面，再到现如今的羚珑可视化搭建，可以直接拖拽生成多端应用，并且覆盖营销、店铺等诸多场景。 在研发资产沉淀能力上，我们打造了 夸克资产平台，已经沉淀了海量的研发组件、图片、字体、动效等研发资产。 在数据可视化能力上，我们打造了 树懒平台，可以对业务统计和监控数据进行可视化查阅。 在服务端能力上，我们打造了专业的 服务端团队和系统，为各类业务和平台需求提供专业可靠的服务端能力支撑。 盖大厦我们拥有诸多的能力积木，但是如果不能进行体系化串联，我们就不能进行产品化包装，以及对外进行技术赋能。 我们发现，纵观整个产研流程，将我们的能力积木放入之后，在某些环节依然有所缺失，例如，从设计师到研发，我们没有很好地进行对接，当有个性化需求需要开发以及需要进行研发组件沉淀时，我们依然需要人工将设计稿进行还原然后进行业务逻辑绑定开发，不仅仅是滞后我们的研发效率，同时对我们的设计研发体系来说也是一种断层，所以，今年我们进行了 设计稿一键生成代码 的探索，尝试对设计研发这一环节进行能力补全，同时提升我们的产研效率。 而同时，在研发流程上，我们只有 Taro 本身是远远不够的，Taro 只能解决代码开发本身和部分工程化的问题，只是研发流程中的一环，而研发流程则是包括开发、调试、测试、上线、统计监控完整的链路，为了打通研发流程全链路，同时统一研发环境，今年我们又开始进行了 一站式云端集成研发平台 即 Cloud IDE 的探索，尝试将业务研发、资产沉淀搬到云端，仿佛在走一遍统一上线平台的老路，但却是完全不一样的风景。 设计稿一键生成代码 与 一站式云端集成研发平台 成为了补全产研体系化建设的两块拼图，让产研流程可以成体系化进行串联。 目前我们现有的产研流程，首先设计稿通过智能代码能力一键生成可二次开发的代码，代码导入 Cloud IDE 中进行开发调整，最后可以通过 Taro 生成多端应用，这是一个线性的过程，而同时，在此过程中也能快速沉淀设计研发资产，设计研发资产也能作为智能代码智能识别的样本数据，沉淀设计资产又可以提供给可视化搭建平台，直接搭建出多端应用，同时羚珑智能设计将为应用提供个性化的图片和视频，丰富应用的运营能力。由此，实现了一个良性的产研闭环。 目前，我们整体的能力全景图如下。 启下立足业务，技术储能是过去五年凹凸实验室的主题。 而智能化设计研发体系将绘制凹凸实验室未来 5 年的技术产品的梦想画卷。 接下来我们将通过【凹凸技术揭秘】系列文章，为大家分享、剖析凹凸的关键技术布局，希望能为业界带来更多的思想碰撞，也希望能吸引更多有志青年加入我们，共同实现关于技术关于产品关于团队的梦想。 年光似鸟翩翩过，世事如棋局局新，唯有不忘初心，坚守本心，方能乘风破浪，济沧海。 其他感谢一直关注凹凸实验室的读者，为了提供更优质的内容，希望您能抽出几分钟时间，完成一个小调查，明年凹凸公众号的内容由你决定。点击直达 加入凹凸实验室开放、开源、专业、有爱、有梦的大家庭？点击直达 还没有关注「凹凸实验室」的读者们，关注我们吧，我们一个月只有 4 次推送机会，我们很珍惜每一次推送，不会让你失望的。微信搜索「凹凸实验室」关注即可。","pubDate":"Thu, 24 Dec 2020 10:00:00 GMT","guid":"https://aotu.io/notes/2020/12/24/aotu-5-year/","category":"凹凸"},{"title":"京喜小程序首页瘦身实践","link":"https://aotu.io/notes/2020/11/30/jx-code-slim/","description":"前言在 web 开发场景，减少代码体积虽然是性能优化的一个方向，还没到锱铢必较的程度。但是在小程序场景，由于代码包上传阶段限制了主包 2M 和总包 16M（近期微信官方正在内测将总包上限调整至 20M ）的尺寸，超过就会面临无法发版的风险，代码包体积的优化就变得特别重要了。京喜小程序首页作为微信购物的大入口，承载大量流量，功能复杂模块众多，又要与其他核心业务和公共组件共享 2M 的主包空间，因此代码包瘦身的工作在持续不断进行，否则无法满足业务的快速增长。本文将结合以往优化策略与最近一次的瘦身实践，分享小程序代码瘦身的经验与思考。 常见的瘦身方式京喜首页项目是一个优化良好的项目，对于常见的优化措施，已经有过很好的实践，就让我们我们先回顾一下有哪些常见的优化策略吧： 代码分包：将相对独立的页面和组件拆分到分包，可以解决主包体积受限问题； 依赖分析：移除未引用的页面、组件和其他文件； 避免使用本地资源：除了兜底图片，其他都尽可能使用 url 的方式，由于 base64 图本质上是将信息编码成长字符串，也会占用很多空间，不建议使用； 对所有类型的文件都进行压缩并清理注释，包括了：js、wxml、wxss、json； 此外，京喜首页团队还针对 Taro 开发场景进行了如下优化： 分析出编译后每个文件的高频重复代码（如处理兼容性的 pollyfill 代码），拆分生成公共文件，替换原引用以实现共用。 标准和工具在开始正式介绍瘦身实践之前，我们先来明确一下代码包体积的衡量标准和统计方式吧。 小程序上传代码以代码包尺寸为准，所谓 2M 的限制，就是指该尺寸不能超过 2048KB。 从信息传输角度来说，Gzip 等压缩工具可以进行很多信息化编码优化，因此一些内容重复是可以容忍的，但是由于我们的目标是为了解决小程序上传限制，就只有对代码包尺寸锱铢必较了。 在开发者工具-详情-基本信息-上次预览或上次上传，可以查看到最近一次的代码包体积，本文接下来所介绍的优化都是以缩小这个体积为目的。 但是代码上传生成模板速度很慢，如果每次都要根据这里的数据来统计体积变化，效率太低了。 在未改动项目配置的情况下，我们就可以间接以代码目录的文件体积大小作为变化参照。怎么方便的统计文件体积呢？这里我用了tree-cli，利用它提供的参数，可以输出具备尺寸统计和排序功能的代码文件清单： 12345npm install -g tree-cli// 目标目录cd target-directory// 输出文件为 size-analysis.mdtree -s --sort=size -o size-analysis.md 清单内容格式如下： 12345678910111213.├── [ 1000] index.js├── [ 500] index.wxss├── [ 500] index.wxml├── [ 500] index.json├── [ 4000] components│ ├── [ 4000] child│ │ ├── [ 1000] index.js│ │ ├── [ 1000] index.wxml│ │ ├── [ 1000] index.wxss└── └── └── [ 1000] index.json 6500 bytes used in 2 directories, 8 files 瘦身实践前面说到京喜首页优化措施都做的很好了，下面即将分享的是一些不那么常见的优化方式，优化空间有大有小，想要优化小程序代码包，建议先尽量完成前文提到的优化方案，这样获得的收益最明显，然后再来看接下来提到的这些方式吧~ 一、字体和颜色的全局共用小程序文档内关于继承样式的说明为：继承样式，如font,color, 会从组件外继承到组件内。 分析项目现状，我们通常会把字体定义放在公共 css 文件内，随着页面或组件引入公共 css，font 也将被重复引入，可以通过改造，把 font 的定义仅放在 app.wxss 内，取消组件和页面的引入，可以达到减少整体代码包体积的目的。 关于这一项首页项目体积减少1%，预估整个项目还有 20kb 左右的 font 定义可清理。 如果有全局的颜色定义，也可以进行类似的优化。 二、样式补全功能的使用作为 web 开发者，对 -webkit- 这种前缀一定不陌生，为了适配不同浏览器内核，通常我们会在编译阶段使用 autoprefixer 进行样式的自动补全。 而小程序开发者工具也提供了样式补全的能力：详情-本地设置-可以勾选「上传代码时样式自动补全」 这个补全和我们在编译时做的有什么不同吗？ 关键在于它实现的时机：如果是本地模板上传前，那么应该和我们编译的补全效果一样；如果是在上传模板后，也许可以借此减掉补全内容所占的尺寸。 结合小程序代码包传递过程和样式补全时机，大概有以下3种情况： 阶段一补全： 阶段二： 或者是阶段三： 为了验证猜想，来做一个实验吧，比较「 项目编译不补全样式+开发者工具设置样式补全」 vs「 项目编译补全样式+开发者工具不设置样式补全」，模板体积统计如下： 可见前者比后者少了 58kb，这说明，开发者工具提供的样式补全不是在阶段一做的，不然模板体积应该和我们自己做的编译补全基本一致。 那么，就可以愉快的去掉编译补全，使用小程序开发者工具提供的能力了。 不过这样改动会出现一个小问题，开发者工具内的样式是未经补全处理的，个别样式会有点问题，测试就发现 mask-border-source 无效，而相应真机因为已添加样式补全没有问题。为了不出现预览误会，建议给这种尚未支持的样式手动写上 -webkit- 前缀，保证开发和真机表现一致。 三、小心 Sass!sass/less 等工具使得 css 的编写变得更加流畅，函数和变量的引入也让 css 有了一点工程化的意味。但是你有没有观察过 sass 的编译实现呢？ 123456789101112// a.scss，作为被引用方.banner &#123; // 样式定义 color: red;&#125;$COLOR = red // 变量定义（函数定义类似）// b.scss，作为使用方@import 'a.scss';.banner_wrapper &#123; background: white; color:$COLOR;&#125; 关注b.sass的编译后： 123456789// a.scss的引用消失了，内容被整合到文件内.banner &#123; // a.scss内的样式定义会被拷贝进来 color: red;&#125;.banner_wrapper &#123; background: white; color:red; //变量定义会被按值替换&#125; 这里出现的问题是：我们是否需要.banner被拷贝进来呢 为了避免多引入不需要的样式定义，有以下几个方向： 按功能拆分 a.scss 内的样式定义，按需引入。 使用 @include 语法，将 banner 的定义变成一个变量，按需引入。 而在小程序场景，wxss 语法支持 @import，实现了极弱版的模块化，使得我们可以再加一个角度解决上面的问题： 绕过 sass 编译，使用小程序的 @import 语法，引入需要的样式定义。（关于如何绕开 sass 编译，可以考虑使用注释片段，或者白名单筛选识别） 四、多端场景的冗余代码移除京喜首页项目使用 Taro 开发，需要适配 H5/微信小程序/QQ小程序等多端场景，利用 Taro 提供的环境变量能力，可以在方法内部实现多端差异处理，比如下面这段： 1234567891011init()&#123; if(process.env.TARO_ENV === 'weapp'&#123; // 微信小程序逻辑 this.initWeapp() &#125;else if(process.env.TARO_ENV === 'h5')&#123; // H5页面逻辑 this.initH5() &#125;&#125;initWeapp()&#123;...&#125;initH5()&#123;...&#125; 小程序端打包后代码： 12345init()&#123; this.initWeapp()&#125;initWeapp()&#123;...&#125;initH5()&#123;...&#125; 但是，环境变量方式没办法处理 initH5 这种方法定义，导致也被打包进来了。 因此，我们需要更强大的差异打包：京喜首页利用内部的 wxa-cli 工具提供的条件编译能力，通过注释段落标记，圈注出多端内容，实现了代码片段层面的差异打包，细节如下： 12345678910111213init()&#123; if(process.env.TARO_ENV === 'weapp'&#123; // 微信小程序逻辑 this.initWeapp() &#125;else if(process.env.TARO_ENV === 'h5')&#123; // H5页面逻辑 this.initH5() &#125;&#125;initWeapp()&#123;...&#125;/* wxa if:type=='h5' */ 标记h5端代码开始位置initH5()&#123;...&#125;/* /wxa */ 标记注释结束位置 打包后代码： 1234init()&#123; // weapp内 this.initWeapp()&#125;initWeapp()&#123;...&#125; initH5 消失了，代码更瘦了 五、整理 log为了调试方便，你的项目内有没有打很长的 log，类似于这种： 1console.log('==============xx接口异常============') 经过测试，首页代码文件内有 5KB 的内容是 log 语句，可以试着优化一下： 及时移除开发调试用 log 信息类 log 约定长度更短的格式 六、良好的编码策略有没有同样的逻辑需求，可以用更短更优雅的写法来实现呢？ 关于代码分析是个很复杂的话题，暂时列一个结论相对明确的写法吧 格式化数据时数据的存取和中间变量问题123456789101112131415161718192021function format(list)&#123; let result = [] list.forEach(item =&gt; &#123; const &#123; a, b, c: f, d, e, &#125; = item result.push(&#123; a, b, f, d, e, &#125;) &#125;) return result 可以利用 lodash 的 pick 方法改写成： 1234567import &#123; pick &#125; from 'lodash/pick'function format(list)&#123; return list.map(item=&gt;(&#123; ...pick(item,'a','b','d','e'), f:item.c &#125;)) 七、样式命名编译优化京喜首页项目由于 H5 端混搭老项目，为了避免类名冲突，采用了形如block-name__element--modifier的 bem 命名规则。在开发中进一步发现，一些类似 navbar-content__item 的常见命名偶尔撞车，为了避免冲突，类名就越写越长，而小程序代码包的尺寸影响也在悄悄增大。 为了解决命名冲突的问题，将类名 hash 化是个好办法，css-modules 就是个成熟的插件，可以通过配置规则，对样式名编译出「文件名+内容相关」的独特化 hash。 但是研究下它的实现，会发现对代码尺寸的影响不容乐观，看一个编译后例子： 1234567import style from './index.module.map.scss.js' //js文件，增加一句jsMap的引入&lt;view className=&#123;style.banner&#125;&gt;&lt;/view&gt; // wxml文件，每处类名都比原类名增加了`style.`的引用 .hash &#123; xx &#125; // wxss文件， 类名被hash化，减少的具体尺寸为:原类名-hash module.exports = &#123; banner : hash &#125; // 新增了一个map文件，实现原名与hash名的映射，增加的具体尺寸为:原类名+hash 计算整体内容变化： js 内新增引入 map 语句：增加一句代码 wxml 内：原为 n 个类名，现为 n 个「style.+原类名」，增量为 n 个style. map 文件 与 wxss 文件合计：map 内有 n 个原类名与 hash 映射， wxss 现为 n 个 hash ， 减去原来的 n 个原类名 ，合计增量为 2n 个 hash 可见引入 css-modules 会导致整体代码尺寸增加。 会不会觉得这个新增的 map 文件的作用特别熟悉呢？ 在我们压缩 js 文件时，会有一个 sourceMap 文件，它保留了原始命名和代码位置，可以方便定位和 debug。 css-modules 实现的 map 文件，在我看来作用和 sourceMap 的命名索引差不多，对于代码逻辑来说，除了保持原类名的引用信息，它好像也没什么用了，在尺寸敏感场景，就可以考虑去掉 map 文件，还是上文的示例，如果可以实现成这样就好了： 12345678910// import style from './index.module.map.scss.js' js文件取消map的引入// wxml文件&lt;view className=\"hash\"&gt;&lt;/view&gt; // 对style.banner进行求值并替换 // wxss文件.hash &#123; xx &#125; // 这里不变module.exports = &#123; banner : hash &#125; // 删掉不要 网上遍寻没有相关的处理，只能自己造轮子开搞了。 由于当前主要目的是对小程序代码瘦身，H5 端文件处理和小程序也有一些差异，所以暂时只对小程序场景造了插件，取名 weapp-css-modules ，github 地址在这里：https://github.com/o2team/weapp-css-modules 大概思路是： 完成小程序的 css-modules 实现 在此基础上进行 map 移除的相关简化逻辑 进一步的，考虑到小程序组件内默认样式隔离的特性，对 hash 化的命名再次缩短，变成单字母编排。 如果是只开发小程序端，可以借此实现小程序样式命名相关的代码瘦身，而对于 Taro 开发的多端场景，还可以同时解决 h5 端的命名冲突问题。 还是上面的例子，下面是 weapp-css-modules 编译后效果： 12345678910// js文件let style = &#123;&#125; // 不引用map，加入对不规范引入style的兼容// wxml文件&lt;view className=\"a\"&gt;&lt;/view&gt; // 对style.banner进行求值并替换，加入单字母编排// wxss文件.a &#123; xx &#125; // 因为小程序组件样式隔离，所以可以最短化类名module.exports = &#123; banner : hash &#125; // 删掉不要 京喜首页项目通过改造组件采用 css-modules 写法，加上 weapp-css-modules 编译，代码相对尺寸减少了 10%，还是很有效果的，感兴趣的同学可以试用一下。 总结关于代码瘦身，想提一下信息学中熵的概念：熵反映信息的无序程度，一段信息无序程度越低，它的熵值越低，可被压缩的空间越大；无序程度越高，熵值越高，可被压缩的空间越小。而数据压缩或者是代码瘦身的过程，就是通过优化信息存储方式以逼近它真实的熵值。 从这个角度来说： 「字体和颜色的全局共用」和「样式补全功能的使用」是借用小程序提供的能力，信息量没变； 「小心 Sass」、「多端场景的冗余代码移除」是减少不用的信息； 「整理 log」和「样式命名编译优化」是凝练有效信息； 看起来最不好归类的是「良好的编码策略」，它是在编码阶段对信息的梳理和整合，也算凝练有效信息吧。 以上就是京喜首页项目这次代码瘦身的主要方式了，除此之外的删除不用文件、整合公共文件这些体力活，我就不再啰嗦了。通过以上方式，京喜首页代码在原本优化良好的基础上，实现了再次减重30%的目标，希望能给小程序开发者们带来有价值的信息和思考。 参考资料 [1] CSS Modules: https://github.com/css-modules/css-modules [2] Tree-Cli: https://github.com/MrRaindrop/tree-cli [3] 小程序工程化探索: https://mp.weixin.qq.com/s/_NSJTQ-4-8gTnwTVK-tn0A [4] 微信小程序 限制2M的瘦身技巧与方法详解: https://blog.csdn.net/wlanye/article/details/73457700","pubDate":"Mon, 30 Nov 2020 09:00:00 GMT","guid":"https://aotu.io/notes/2020/11/30/jx-code-slim/","category":"小程序"},{"title":"因为 Vue Ref 提案，我又刷了遍 label 语法","link":"https://aotu.io/notes/2020/11/23/vue-ref-sugar-javascript-label/","description":"label 0x0：Vue Ref 提案近日，Vue 作者在社区提交了一份Ref 语法糖的提案，引发了社区的争议。 关于 Ref 提案，它是将原本应该使用 ref() 调用的方式，通过 label 语法 ref: 进行简化编写，并在编译期间进行转换，所以这个本质上是个语法糖，示例如下， 原写法： 12345678&lt;script setup&gt;...const count = ref(0) // ref调用const inc = () =&gt; &#123; count.value++ &#125;&lt;/script&gt;&lt;template&gt; &lt;Foo :count=\"count\" @click=\"inc\" /&gt;&lt;/template&gt; 新提案写法： 12345678910&lt;script setup&gt;...ref: count = 1 // 使用label语法function inc() &#123; count++&#125;&lt;/script&gt;&lt;template&gt; &lt;button @click=\"inc\"&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt; 这个提议最大的争议在于，新提案的写法是符合 JS 语法，但却不符合 JS 的语义，按照 label 的语义，ref: count = 0 里的 ref: 是无任何意义的，既在运行时不做解析，但在 Vue 的 script setup 下却赋予了 ref() 的功能！ label 语法通常很少被使用，以至于部分人在看到新提案的写法后认为是 Vue 的新魔法，纷纷表示学不动或认为应该将 Vue 的写法叫 VueScript。 在看到 ref 提案后又回想起多年来未曾用过的 label 语法，本篇主要介绍及回顾下汇编、C、JavaScript 语言的 label 语法和使用。 label 0x1：汇编语言汇编语言主要是汇编指令(语句)组成，一条指令有四个组成部分，如下： 12[label: ] mnemonic [operands] [;comment]标号:（可选）+ 指令助记符（必需）+ 操作数（通常是必需的）+ 注释（可选） 示例： 1L0: mov ax,0; 这是一条汇编指令 标号（label）是一种标识符，是指令的位置标记。标号位于指令的前端，表示指令的地址。 默认情况下，CPU 是顺序加载并执行程序。但是，在实现类似条件跳转、循环等功能时，就需要使用跳转指令+lablel 来实现，汇编语言中有多种跳转指令，这里以 jmp 为例，语法如下： 1jmp label(目标地址) 示例一： 1234L1: mov ax,0 ... jmp L1; 不断地循环 示例二： 12345 mov ax,0 mov ecx,5;循环5次L1: inc ax loop L1 label 是伪指令，嵌入源代码中的命令，由汇编器识别和执行，不在运行时执行。 label 0x2：C 语言label 语法如下： 1label: statement 在汇编语言中将 label 当作指令的位置标记，C 语言中也是如此，C 语言使用 goto 语句配合跳转到指定的 label 处，类似汇编的 jmp 效果，goto 语法如下： 1goto label 示例 12345678void func() &#123; int a; a=0; loop: a++; if(a&lt;10) goto loop; // 使用goto实现循环 printf(\"%d\",a);&#125; 由于 goto 的自由和灵活，在程序上可随意跳转，在使用不当的情况下会破坏“结构化”，不但带来编程的混乱,而且容易出错，所以在很多语言教学上都不建议使用。 label 0x3：JavaScript 语言label 语法如下： 1label: statement; 语法同 C 语言，但是 JS 没有 goto 语句，不能像 C、汇编那样随意跳转，JS 的 label 语法只能配合 break、continue 进行使用，单独使用时无意义。在 JS 里 continue/break label 应该算是一个阉割版 goto 语句。配合 continue 使用时，语法如下： 1continue label; 示例： 1234567891011var i, j;loop1: for (i = 0; i &lt; 3; i++) &#123; //The first for statement is labeled \"loop1\" loop2: for (j = 0; j &lt; 3; j++) &#123; //The second for statement is labeled \"loop2\" if (i === 1 &amp;&amp; j === 1) &#123; continue loop1; &#125; console.log(\"i = \" + i + \", j = \" + j); &#125;&#125; 特别注意：continue label 后的 label 必须紧跟着 for、while 一起时才可以，否则会报错，如下： 123456// × 错误loop1: &#123; for (;;) continue loop1;&#125;// √ 正确loop1: for (;;) continue loop1; 配合 break 使用时，语法如下： 1break label; 相比 continue ，break label 的使用灵活会更大，可以和 For、While、Switch、Block 语句配合，如下： 1label: ForStatement | WhileStatement | SwitchStatement | BlockStatement 示例一： 123456789101112var i, j;// 使用for while switch等loop1: for (i = 0; i &lt; 3; i++) &#123; //The first for statement is labeled \"loop1\" loop2: for (j = 0; j &lt; 3; j++) &#123; //The second for statement is labeled \"loop2\" if (i == 1 &amp;&amp; j == 1) &#123; break loop1; &#125; console.log(\"i = \" + i + \", j = \" + j); &#125;&#125; 示例二： 123456789// label: 语句块outer_block: &#123; inner_block: &#123; console.log(\"1\"); break outer_block; // breaks out of both inner_block and outer_block console.log(\":-(\"); // skipped &#125; console.log(\"2\"); // skipped&#125; 单独使用 label label 在不配合 continue、break 使用时无意义，解释器会直接忽略 label，示例： 12test: 1 + 1;// 2 label 0x4：最后label 语法在高级语言中的存在感都非常低，主要还是因为高级语法已经提供了非常多的控制语句，绝大部分场景下已经不需要使用 label、goto 这种相对直接的跳转。label 的作用本质上还是代码位置标记，以便类似 goto 的语句进行跳转，虽然大部分情况都是不建议使用，但有时 goto 可以大幅度简化代码量（如：跳出多层嵌套，跳出多层循环场景），在保证代码足够清晰明确下，偶尔使用也是可以的。 回到文章开头，关于 Vue Ref 提案之所以引起许多开发者的注意跟讨论，主要还是因为修改了 label 的语义，尽管符合 JS 语法，但为 label 增添的非标准语义，会让部分开发者陷入混乱，增加心智负担。 讨论传送门：New script setup and ref sugar","pubDate":"Mon, 23 Nov 2020 16:00:00 GMT","guid":"https://aotu.io/notes/2020/11/23/vue-ref-sugar-javascript-label/","category":"JavaScript"},{"title":"React 入门儿","link":"https://aotu.io/notes/2020/11/12/react-indoor/","description":"谁都没有看见过风，更不用说你和我了。但是当纸币在飘的时候，我们知道那是风在数钱。 React 影响着我们工作的方方面面，我们每天都在使用它，只窥其表却难以窥其里。正所谓看不如写，本篇文章的目的就是从原理层面探究 React 是如何工作的。 工具在写文章之前，为了方便理解，我准备了一个懒人调试仓库 simple_react ，这个仓库将 benchmark 用例（只有两个 ^ ^）和 React 源码共同放在 src 文件夹中，通过 snowpack 进行热更新，可以直接在源码中加入 log 和 debuger 进行调试。当然这里的“源码”并不是真的源码，因为 React 源码中充斥着巨量的 dev 代码和不明确的功能函数，所以我对源码进行了整理，用 typescript 对类型进行了规范，删除了大量和核心流程无关的代码（当然也误删了一些有关的 ^ ^）。 如果你只是希望了解 React 的运行流程而不是写一个可以用的框架的话，那么这个仓库完全可以满足你学习的需要。当然，这个仓库基于 React16.8 ，虽然这个版本并不包括当前的航道模型 Lane 等新特性，但是是我个人认为比较稳定且更适合阅读的一个版本。 （如果希望调试完整的源码，也可以参考 拉取源码 通过 yarn link 来进行 debug） 文章结构 fiber 架构设计及首次渲染流程 事件委托机制 状态的更新 时间片 在了解 React 是如何工作之前，我们应该确保了解几点有关 React 的基础知识。 Why Framework首先，我们需要知道使用框架对于开发的意义是什么。如果我们还处于远古时期使用纯 JS 的阶段，每次数据的改变都会引发组件的展示状态改变，因此我们需要去手动的操作 DOM 。如果在某一秒内，数据异步的连续改变了几十次，根据展示逻辑我们也需要连续对 DOM 进行几十次修改。频繁的 DOM 操作对网页性能的影响是很大的，当然，创建 DOM 元素和修改 DOM 元素的属性都不过分消耗性能，主要在于每次将新的 DOM 插入 document 都会导致浏览器重新计算布局属性，以及各个视图层、合并、渲染。所以，这样的代码性能是十分低下的。 可以试想这样一个场景。对于一个前端列表组件而言，当存在 3 条数据的时候展示 3 条，当存在 5 条数据的时候展示 5 条。也就是说 UI 的呈现在某种程度上必然会和数据存在某种逻辑关系。如果 JS 能够感知到关键数据的改变，使用一种高效的方式将 DOM 改写成与数据相对应的状态。那么于开发者而言，就可以专注于业务逻辑和数据的改变，工作效率也会大幅提高。 所以， 框架 最核心的功能之一就是 高效地 达成 UI层和数据层的统一。 React 哲学React 本身并不是框架， React 只是一个 JavaScript 库，他的作用是通过组件构建用户界面，属于 MVC 应用中的 View 视图层。 React 通过 props 和 state 来简化关键数据的存储，对于一个 react 组件函数而言，在 1 秒内可能被执行很多次。而每一次被执行，数据被注入 JSX ， JSX 并不是真实的 DOM ，在 React 中会被转换成 React.createElement(type, props, children) 函数，执行的结果就是 ReactElement 元素 ，也即是 虚拟DOM ，用来描述在浏览器的某一帧中，组件应该被呈现为什么样子。 Virtual Dom VirtualDom 并非 React 专属，就像 redux 也可以在非 React 环境下使用一样，它们只是一种设计的思路。 事实上， React 在使用 fiber 架构之前的 Virtual Dom 和 diff 过程要相对直观一些。但是在引入了 fiber 架构之后整个流程变得冗长，如果单纯想了解 VirtualDom 和 diff 过程的原理也可以通过 simple-virtual-dom 这个仓库来学习。 VirtualDom 的本质是利用 JS变量 对真实 DOM 进行抽象，既然每一次操作 DOM 都可能触发浏览器的重排消耗性能，那么就可以使用 VirtualDom 来缓存当前组件状态，对用户交互和数据的变动进行批次处理，直接计算出每一帧页面应该呈现的最终状态，而这个状态是以 JS变量 的形式存在于内存中的。所以通过 VirtualDom 既能够保证用户看到的每一帧都响应了数据的变化，又能节约性能保证浏览器不出现卡顿。 第一次渲染 First Render首先我们应该注意到 React(浏览器环境) 代码的入口 render 函数 1ReactDOM.render(&lt;App /&gt;, domContainer) 这个 render 过程中， React 需要做到的是根据用户创造的 JSX 语法，构建出一个虚拟的树结构（也就是 ReactElement 和 Fiber ）来表示用户 期望中 页面中的元素结构。当然对于这个过程相对并不复杂（误），因为此时的 document 内还是一片虚无。就思路上而言，只需要根据虚拟 DOM 节点生成真实的 DOM 元素然后插入 document ，第一次渲染就算圆满完成。 createReactElement通常我们会通过 Babel 将 JSX 转换为一个 JS 执行函数。例如我们在 React 环境下用 JSX 中写了一个标题组件 123&lt;h1 className='title'&gt; &lt;div&gt;Class Component&lt;/div&gt;&lt;/h1&gt; 那么这个组件被 Babel 转换之后将会是 123React.createElement('h1', &#123; className: 'title' &#125;, [ React.createElement('div', null, [ 'Class Component' ]]) 传统编译讲究一个 JSON 化，当然 JSX 和 React 也没有什么关系， JSX 只是 React 推荐的一种拓展语法。当然你也可以不用 JSX 直接使用 React.createElement 函数，但是对比上面的两种写法你就也能知道，使用纯 JS 的心智成本会比简明可见的 JSX 高多少。我们可以看出， React.createElement 需要接收 3 个参数，分别是 DOM 元素的标签名，属性对象以及一个子元素数组，返回值则是一个 ReactElement 对象。 事实上， JSX 编译后的 json 结构本身就是一个对象，即使不执行 React.createElement 函数也已经初步可以使用了。那么在这个函数中我们做了什么呢。 一个 ReactElement 元素主要有 5 个关键属性，我们都知道要构建成一个页面需要通过 html 描述元素的类型和结构，通过 style 和 class 去描述元素的样式呈现，通过 js 和绑定事件来触发交互事件和页面更新。 所以最重要的是第一个属性，元素类型 type 。如果这个元素是一个纯 html 标签元素，例如 div ，那么 type 将会是字符串 div ，如果是一个 React 组件，例如 12345function App() &#123; return ( &lt;div&gt;Hello, World!&lt;/div&gt; )&#125; 那么 type 的值将会指向 App 函数，当然 Class组件 也一样（众所周知 ES6 的 Class 语法本身就是函数以及原型链构成的语法糖） 第二个属性是 props ，我们在 html 标签中写入的大部分属性都会被收集在 props 中，例如 id 、 className 、 style 、 children 、点击事件等等。 第三个第四个属性分别是 key 和 ref ，其中 key 在数组的处理和 diff 过程中有重要作用，而 ref 则是引用标识，在这里就先不做过多介绍。 最后一个属性是 $$typeof ，这个属性会指向 Symbol(React.element) 。作为 React 元素的唯一标识的同时，这个标签也承担了安全方面的功能。我们已经知道了所谓的 ReactElement 其实就是一个 JS 对象。那么如果有用户恶意的向服务端数据库中存入了某个有侵入性功能的 伪React 对象，在实际渲染过程中被当做页面元素渲染，那么将有可能威胁到用户的安全。而 Symbol 是无法在数据库中被存储的，换句话说， React 所渲染的所有元素，都必须是由 JSX 编译的拥有 Symbol 标识的元素。（如果在低版本不支持 Symbol 的浏览器中，将会使用字符串替代，也就没有这层安排保护了） ok，接下来回到 render 函数。在这个函数中到底发生了什么呢，简单来说就是创建 Root 结构。 enqueueUpdate从设计者的角度，根据 单一职责原则 和 开闭口原则 需要有与函数体解耦的数据结构来告诉 React 应该怎么操作 fiber 。而不是初次渲染写一套逻辑，第二次渲染写一套逻辑。因此， fiber 上有了更新队列 UpdateQueue 和 更新链表 Update 结构 如果查看一下相关的定义就会发现，更新队列 updateQueue 是多个更新组成的链表结构，而 update 的更新也是一个链表，至于为什么是这样设计，试想在一个 Class Component 的更新函数中连续执行了 3 次 setState ，与其将其作为 3 个更新挂载到组件上，不如提供一种更小粒度的控制方式。一句话概括就是， setState 级别的小更新合并成一个状态更新，组件中的多个状态更新在组件的更新队列中合并，就能够计算出组件的新状态 newState。 对于初次渲染而言，只需要在第一个 fiber 上，挂载一个 update 标识这是一个初次渲染的 fiber 即可。 1234567891011121314151617181920212223242526// 更新根节点export function ScheduleRootUpdate ( current: Fiber, element: ReactElement, expirationTime: number, suspenseConfig: SuspenseConfig | null, callback?: Function) &#123; // 创建一个update实例 const update = createUpdate(expirationTime, suspenseConfig) // 对于作用在根节点上的 react element update.payload = &#123; element &#125; // 将 update 挂载到根 fiber 的 updateQueue 属性上 enqueueUpdate( current, update ) ScheduleWork( current, expirationTime )&#125; Fiber作为整个 Fiber架构 中最核心的设计， Fiber 被设计成了链表结构。 child 指向当前节点的第一个子元素 return 指向当前节点的父元素 sibling 指向同级的下一个兄弟节点 如果是 React16 之前的树状结构，就需要通过 DFS 深度遍历来查找每一个节点。而现在只需要将指针按照 child → sibling → return 的优先级移动，就可以处理所有的节点 这样设计还有一个好处就是在 React 工作的时候只需要使用一个全局变量作为指针在链表中不断移动，如果出现用户输入或其他优先级更高的任务就可以 暂停 当前工作，其他任务结束后只需要根据指针的位置继续向下移动就可以继续之前的工作。指针移动的规律可以归纳为 自顶向下，从左到右 。 康康 fiber 的基本结构 其中 tag fiber 的类型 ，例如函数组件，类组件，原生组件， Portal 等。 type React元素 类型 详见上方 createElement。 alternate 代表双向缓冲对象（看后面）。 effectTag 代表这个 fiber 在下一次渲染中将会被如何处理。例如只需要插入，那么这个值中会包含 Placement ，如果需要被删除，那么将会包含 Deletion 。 expirationTime 过期时间，过期时间越靠前，就代表这个 fiber 的优先级越高。 firstEffect 和 lastEffect 的类型都和 fiber 一样，同样是链表结构，通过 nextEffect 来连接。代表着即将更新的 fiber 状态 memorizeState 和 memorizeProps 代表在上次渲染中组件的 props 和 state 。如果成功更新，那么新的 pendingProps 和 newState 将会替代这两个变量的值 ref 引用标识 stateNode 代表这个 fiber 节点对应的真实状态 对于原生组件，这个值指向一个 dom 节点（虽然已经被创建了，但不代表就被插入了 document ） 对于类组件，这个值指向对应的类实例 对于函数组件，这个值指向 Null 对于 RootFiber，这个值指向 FiberRoot （如图） 接下来是初次渲染的几个核心步骤，因为是初次渲染，核心任务就是将首屏元素渲染到页面上，所以这个过程将会是同步的。 PrepareFreshStack因为笔者是土货没学过英语，百度了下发现是 准备干净的栈 的意思。结合了下流程，可以看出这一步的作用是在真正工作之前做一些准备，例如初始化一些变量，放弃之前未完成的工作，以及最重要的—— 创建双向缓冲变量 WorkInProgress 12345678910111213141516171819202122232425262728let workInProgress: Fiber | null = null...export function prepareFreshStack ( root: FiberRoot, expirationTime: number) &#123; // 重置根节点的finishWork root.finishedWork = null root.finishedExpirationTime = ExpirationTime.NoWork ... if (workInProgress !== null) &#123; // 如果已经存在了WIP，说明存在未完成的任务 // 向上找到它的root fiber let interruptedWork = workInProgress.return while (interruptedWork !== null) &#123; // unwindInterruptedWork // 抹去未完成的任务 unwindInterruptedWork(interruptedWork) interruptedWork = interruptedWork.return &#125; &#125; workInProgressRoot = root // 创建双向缓冲对象 workInProgress = createWorkInProgress(root.current, null, expirationTime) renderExpirationTime = expirationTime workInProgressRootExitStatus = RootExitStatus.RootImcomplete&#125; 双向缓冲变量 WorkInProgress这里简称 WIP 好了，与之对应的是 current ， current 代表的是当前页面上呈现的组件对应的 fiber 节点，你可以将其类比为 git 中的 master 分支，它代表的是已经对外的状态。而 WIP 则代表了一个 pending 的状态，也就是下一帧屏幕将要呈现的状态，就像是从 master 拉出来的一个 feature 分支，我们可以在这个分支上做任意的更改。最终协调完毕，将 WIP 的结果渲染到了页面上，按照页面内容对应 current 的原则， current 将会指向 WIP ，也就是说， WIP 取代了之前的 current （ git 的 master 分支）。 在这之前 current 和 WIP 的 alternate 字段分别指向彼此。 那么 WIP 是如何被创造出来的呢： 12345678910111213141516171819202122232425262728293031323334353637// 根据已有 fiber 生成一个 workInProgress 节点export function createWorkInProgress ( current: Fiber, pendingProps: any, expirationTime): Fiber &#123; let workInProgress = current.alternate if (workInProgress === null) &#123; // 如果当前fiber没有alternate // tip: 这里使用的是“双缓冲池技术”，因为我们最多需要一棵树的两个实例。 // tip: 我们可以自由的复用未使用的节点 // tip: 这是异步创建的，避免使用额外的对象 // tip: 这同样支持我们释放额外的内存（如果需要的话 workInProgress = createFiber( current.tag, pendingProps, current.key, current.mode ) workInProgress.elementType = current.elementType workInProgress.type = current.type workInProgress.stateNode = current.stateNode workInProgress.alternate = current current.alternate = workInProgress &#125; else &#123; // 我们已经有了一个 WIP workInProgress.pendingProps = pendingProps // 重置 effectTag workInProgress.effectTag = EffectTag.NoEffect // 重置 effect 链表 workInProgress.nextEffect = null workInProgress.firstEffect = null workInProgress.lastEffect = null &#125; 可以看出 WIP 其实就是继承了 current 的核心属性，但是去除了一些副作用和工作记录的 干净 的 fiber。 工作循环 WorkLoop在工作循环中，将会执行一个 while 语句，每执行一次循环，都会完成对一个 fiber 节点的处理。在 workLoop 模块中有一个指针 workInProgress 指向当前正在处理的 fiber ，它会不断向链表的尾部移动，直到指向的值为 null ，就停止这部分工作， workLoop 的部分也就结束了。 每处理一个 fiber 节点都是一个工作单元，结束了一个工作单元后 React 会进行一次判断，是否需要暂停工作检查有没有更高优先级的用户交互进来。 123456function workLoopConcurrent() &#123; // 执行工作直到 Scheduler 要求我们 yield while (workInProgress !== null &amp;&amp; !shouldYield()) &#123; workInProgress = performUnitOfWork(workInProgress); &#125;&#125; 跳出条件只有： 所有 fiber 都已经被遍历结束了 当前线程的使用权移交给了外部任务队列 但是我们现在讨论的是第一次渲染，触屏渲染的优先级高于一切，所以并不存在第二个限制条件。 123456function workLoopSync () &#123; // 只要没有完成reconcile就一直执行 while(workInProgress !== null) &#123; workInProgress = performUnitOfWork(workInProgress as Fiber) &#125;&#125; PerformUnitOfWork &amp; beginWork单元工作 performUnitOfWork 的主要工作是通过 beginWork 来完成。 beginWork 的核心工作是通过判断 fiber.tag 判断当前的 fiber 代表的是一个类组件、函数组件还是原生组件，并且针对它们做一些特殊处理。这一切都是为了最终步骤：操作真实 DOM 做准备，即通过改变 fiber.effectTag 和 pendingProps 告诉后面的 commitRoot 函数应该对真实 DOM 进行怎样的改写。 123456789101112131415161718switch (workInProgress.tag) &#123; // RootFiber case WorkTag.HostRoot: return updateHostRoot(current as Fiber, workInProgress, renderExpirationTime) // class 组件 case WorkTag.ClassComponent: &#123; const Component = workInProgress.type const resolvedProps = workInProgress.pendingProps return updateClassComponent( current, workInProgress, Component, resolvedProps, renderExpirationTime ) &#125; ...&#125; 此处就以 Class 组件为例，查看一下具体是如何构建的。 之前有提过，对于类组件而言， fiber.stateNode 会指向这个类之前构造过的实例。 1234567891011121314151617181920212223242526272829// 更新Class组件function updateClassComponent ( current: Fiber | null, workInProgress: Fiber, Component: any, nextProps, renderExpiration: number) &#123; // 如果这个 class 组件被渲染过，stateNode 会指向类实例 // 否则 stateNode 指向 null const instance = workInProgress.stateNodeif (instance === null) &#123; // 如果没有构造过类实例 ...&#125; else &#123; // 如果构造过类实例 ...&#125;// 完成 render 的构建，将得到的 react 元素和已有元素进行调和const nextUnitOfWork = finishClassComponent( current, workInProgress, Component, shouldUpdate, false, renderExpiration)return nextUnitOfWork 如果这个 fiber 并没有构建过类实例的话，就会调用它的构建函数，并且将更新器 updater 挂载到这个类实例上。（处理 setState 逻辑用的，事实上所有的类组件实例上的更新器都是同一个对象，后面会提到） 1234567891011121314151617181920212223242526if (instance === null) &#123; // 这个 class 第一次渲染 if (current !== null) &#123; // 删除 current 和 WIP 之间的指针 current.alternate = null workInProgress.alternate = null // 插入操作 workInProgress.effectTag |= EffectTag.Placement &#125; // 调用构造函数，创造新的类实例 // 给予类实例的某个指针指向更新器 updater constructClassInstance( workInProgress, Component, nextProps, renderExpiration ) // 将属性挂载到类实例上，并且触发多个生命周期 mountClassInstance( workInProgress, Component, nextProps, renderExpiration )&#125; 如果实例已经存在，就需要对比新旧 props 和 state ，判断是否需要更新组件（万一写了 shouldComponentUpdate 呢）。并且触发一些更新时的生命周期钩子，例如 getDerivedStateFromProps 等等。 12345678910else &#123; // 已经 render 过了，更新 shouldUpdate = updateClassInstance( current, workInProgress, Component, nextProps, renderExpiration )&#125; 属性计算完毕后，调用类的 render 函数获取最终的 ReactElement ，打上 Performed 标记，代表这个类在本次渲染中已经执行过了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 完成Class组件的构建function finishClassComponent ( current: Fiber | null, workInProgress: Fiber, Component: any, shouldUpdate: boolean, hasContext: boolean, renderExpiration: number) &#123; // 错误 边界捕获 const didCaptureError = false if (!shouldUpdate &amp;&amp; !didCaptureError) &#123; if (hasContext) &#123; // 抛出问题 return bailoutOnAlreadyFinishedWork( current, workInProgress, renderExpiration ) &#125; &#125; // 实例 const instance = workInProgress.stateNode let nextChildren nextChildren = instance.render() // 标记为已完成 workInProgress.effectTag |= EffectTag.PerformedWork // 开始调和 reconcile reconcileChildren( current, workInProgress, nextChildren, renderExpiration ) return workInProgress.child&#125; 调和过程 如果还记得之前的内容的话，我们在一切工作开始之前只是构建了第一个根节点 fiberRoot 和第一个无意义的空 root ，而在单个元素的调和过程 reconcileSingleElement 中会根据之前 render 得到的 ReactElement 元素构建出对应的 fiber 并且插入到整个 fiber 链表中去。 并且通过 placeSingleChild 给这个 fiber 的 effectTag 打上 Placement 的标签，拥有 Placement 标记后这里的工作就完成了，可以将 fiber 指针移动到下一个节点了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 处理对象类型(单个节点)const isObjectType = isObject(newChild) &amp;&amp; !isNull(newChild)// 对象if (isObjectType) &#123; switch (newChild.$$typeof) &#123; case REACT_ELEMENT_TYPE: &#123; // 在递归调和结束，向上回溯的过程中 // 给这个 fiber 节点打上 Placement 的 Tag return placeSingleChild( reconcileSingleElement( returnFiber, currentFirstChild, newChild, expirationTime ) ) &#125; // 还有 Fragment 等类型 &#125;&#125;// 如果这时子元素是字符串或者数字，按照文字节点来处理// 值得一提的是，如果元素的子元素是纯文字节点// 那么这些文字不会被转换成 fiber// 而是作为父元素的 prop 来处理if (isString(newChild) || isNumber(newChild)) &#123; return placeSingleChild( reconcileSingleTextNode( returnFiber, currentFirstChild, '' + newChild, expirationTime ) )&#125;// 数组if (isArray(newChild)) &#123; return reconcileChildrenArray( returnFiber, currentFirstChild, newChild, expirationTime )&#125; 文章篇幅有限，对于函数组件和原生组件这里就不做过多介绍。假设我们已经完成了对于所有 WIP 的构建和调和过程，对于第一次构建而言，我们需要插入大量的 DOM 结构，但是到现在我们得到的仍然是一些虚拟的 fiber 节点。 所以，在最后一次单元工作 performUnitOfWork 中将会执行 completeWork ，在此之前，我们的单元工作是一步步向尾部的 fiber 节点移动。而在 completeWork 中，我们的工作将是自底向上，根据 fiber 生成真实的 dom 结构，并且在向上的过程中将这些结构拼接成一棵 dom 树。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162export function completeWork ( current: Fiber | null, workInProgress: Fiber, renderExpirationTime: number): Fiber | null &#123; // 最新的 props const newProps = workInProgress.pendingProps switch (workInProgress.tag) &#123; ... case WorkTag.HostComponent: &#123; // pop 该 fiber 对应的上下文 popHostContext(workInProgress) // 获取 stack 中的当前 dom const rootContainerInstance = getRootHostContainer() // 原生组件类型 const type = workInProgress.type if (current !== null &amp;&amp; workInProgress.stateNode !== null) &#123; // 如果不是初次渲染了，可以尝试对已有的 dom 节点进行更新复用 updateHostComponent( current, workInProgress, type as string, newProps, rootContainerInstance ) &#125; else &#123; if (!newProps) &#123; throw new Error('如果没有newProps,是不合法的') &#125; const currentHostContext = getHostContext() // 创建原生组件 let instance = createInstance( type as string, newProps, rootContainerInstance, currentHostContext, workInProgress ) // 将之前所有已经生成的子 dom 元素装载到 instance 实例中 // 逐步拼接成一颗 dom 树 appendAllChildren(instance, workInProgress, false, false) // fiber 的 stateNode 指向这个 dom 结构 workInProgress.stateNode = instance // feat: 这个函数真的藏得很隐蔽，我不知道这些人是怎么能注释都不提一句的呢→_→ // finalizeInitialChildren 作用是将props中的属性挂载到真实的dom元素中去，结果作为一个判断条件被调用 // 返回一个bool值，代表是否需要auto focus(input, textarea...) if (finalizeInitialChildren(instance, type as string, newProps, rootContainerInstance, currentHostContext)) &#123; markUpdate(workInProgress) &#125; &#125; &#125; &#125; return null&#125; 构建完毕后，我们得到了形如下图，虚拟 dom 和 真实 dom，父元素和子元素之间的关系结构 截止到当前，调和 reconcile 工作已经完成，我们已经进入了准备提交到文档 ready to commit 的状态。其实从进入 completeUnitOfWork 构建开始，后面的过程就已经和时间片，任务调度系统没有关系了，此时一切事件、交互、异步任务都将屏气凝神，聆听接下来 dom 的改变。 12345678910111213141516171819202122// 提交根实例(dom)到浏览器真实容器root中function commitRootImpl ( root: FiberRoot, renderPriorityLevel: ReactPriorityLevel) &#123; ... // 因为这次是整个组件树被挂载，所以根 fiber 节点将会作为 fiberRoot 的 finishedWork const finishedWork = root.finishedWork ... // effect 链表，即那些将要被插入的原生组件 fiber let firstEffect = finishedWork.firstEffect ... let nextEffect = firstEffect while (nextEffect !== null) &#123; try &#123; commitMutationEffects(root, renderPriorityLevel) &#125; catch(err) &#123; throw new Error(err) &#125; &#125;&#125; 在 commitMutationEffects 函数之前其实对 effect 链表还进行了另外两次遍历，分别是一些生命周期的处理，例如 getSnapshotBeforeUpdate ，以及一些变量的准备。 1234567891011121314151617181920212223242526272829303132333435// 真正改写文档中dom的函数// 提交fiber effectfunction commitMutationEffects ( root: FiberRoot, renderPriorityLevel: number) &#123; // @question 这个 while 语句似乎是多余的 = = while (nextEffect !== null) &#123; // 当前fiber的tag const effectTag = nextEffect.effectTag // 下方的switch语句只处理 Placement,Deletion 和 Update const primaryEffectTag = effectTag &amp; ( EffectTag.Placement | EffectTag.Update | EffectTag.Deletion | EffectTag.Hydrating ) switch (primaryEffectTag) &#123; case EffectTag.Placement: &#123; // 执行插入 commitPlacement(nextEffect) // effectTag 完成实名制后，要将对应的 effect 去除 nextEffect.effectTag &amp;= ~EffectTag.Placement &#125; case EffectTag.Update: &#123; // 更新现有的 dom 组件 const current = nextEffect.alternate commitWork(current, nextEffect) &#125; &#125; nextEffect = nextEffect.nextEffect &#125;&#125; 截至此刻，第一次渲染的内容已经在屏幕上出现。也就是说，真实 DOM 中的内容不再对应此时的 current fiber ，而是对应着我们操作的 workInProgress fiber ，即函数中的 finishedWork 变量。 1234// 在 commit Mutation 阶段之后，workInProgress tree 已经是真实 Dom 对应的树了// 所以之前的 tree 仍然是 componentWillUnmount 阶段的状态// 所以此时， workInProgress 代替了 current 成为了新的 currentroot.current = finishedWork 一次点击事件如果你是一个经常使用 React 的打工人，就会发现 React 中的 event 是“阅后即焚的”。假设这样一段代码： 1234567891011121314import React, &#123; MouseEvent &#125; from 'react'function TestPersist () &#123; const handleClick = ( event: MouseEvent&lt;HTMLElement, globalThis.MouseEvent&gt; ) =&gt; &#123; setTimeout(() =&gt; console.log('event', event)) &#125; return ( &lt;div onClick=&#123;handleClick&#125;&gt;O2&lt;/div&gt; )&#125; 如果我们需要异步的获取这次点击事件在屏幕中的位置并且做出相应处理，那么在 setTimeout 中能否达到目的呢。 答案是否定的，因为 React 使用了 事件委托 机制，我们拿到的 event 对象并不是原生的 nativeEvent ，而是被 React 挟持处理过的合成事件 SyntheticEvent ，这一点从 ts 类型中也可以看出， 我们使用的 MouseEvent 是从 React 包中引入的而不是全局的默认事件类型。在 handleClick 函数同步执行完毕的一瞬间，这个 event 就已经在 React 事件池中被销毁了，我们可以跑这个组件康一康。 当然 React 也提供了使用异步事件对象的解决方案，它提供了一个 persist 函数，可以让事件不再进入事件池。（在 React17 中为了解决某些 issue ，已经重写了合成事件机制，事件不再由 document 来代理，官网的说法是合成事件不再由事件池管理，也没有了 persist 函数） 那，为什么要用事件委托呢。还是回到那个经典的命题，渲染 2 个 div 当然横着写竖着写都没关系，如果是 1000 个组件 2000 个点击事件呢。事件委托的收益就是： 简化了事件注册的流程，优化性能。 dom 元素不断在更新，你无法保证下一帧的 div 和上一帧中的 div 在内存中的地址是同一个。既然不是同一个，事件又要全部重新绑定，烦死了（指浏览器）。 ok，言归正传。我们点击事件到底发生了什么呢。首先是在 React 的 render 函数执行之前，在 JS 脚本中就已经自动执行了事件的注入。 事件注入事件注入的过程稍微有一点复杂，不光模块之间有顺序，数据也做了不少处理，这里不 po 太详细的代码。可能有人会问为啥不直接写死呢，浏览器的事件不也就那么亿点点。就像 Redux 不是专门为 React 服务的一样， React 也不是专门为浏览器服务的。文章开头也说了 React 只是一个 javascipt 库，它也可以服务 native 端、桌面端甚至各种终端。所以根据底层环境的不同动态的注入事件集也是非常合理的做法。 当然注入过程并不重要，我们需要知道的就是 React 安排了每种事件在 JSX 中的写法和原生事件的对应关系（例如 onClick 和 onclick ），以及事件的优先级。 1234567891011121314151617181920/* ReactDOM环境 */// DOM 环境的事件 pluginconst DOMEventPluginOrder = [ 'ResponderEventPlugin', 'SimpleEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin',];// 这个文件被引入的时候自动执行 injectEventPluginOrder// 确定 plugin 被注册的顺序，并不是真正引入EventPluginHub.injectEventPluginOrder(DOMEventPluginOrder)// 真正的注入事件内容EventPluginHub.injectEventPluginByName(&#123; SimpleEventPlugin: SimpleEventPlugin&#125;) 这里以 SimpleEventPlugin 为例，点击事件等我们平时常用的事件都属于这个 plugin。 12345678910111213141516171819202122232425// 事件元组类型type EventTuple = [ DOMTopLevelEventType, // React 中的事件类型 string, // 浏览器中的事件名称 EventPriority // 事件优先级]const eventTuples: EventTuple[] = [ // 离散的事件 // 离散事件一般指的是在浏览器中连续两次触发间隔最少 33ms 的事件(没有依据，我猜的) // 例如你以光速敲打键盘两次，这两个事件的实际触发时间戳仍然会有间隔 [ DOMTopLevelEventTypes.TOP_BLUR, &apos;blur&apos;, DiscreteEvent ], [ DOMTopLevelEventTypes.TOP_CANCEL, &apos;cancel&apos;, DiscreteEvent ], [ DOMTopLevelEventTypes.TOP_CHANGE, &apos;change&apos;, DiscreteEvent ], [ DOMTopLevelEventTypes.TOP_CLICK, &apos;click&apos;, DiscreteEvent ], [ DOMTopLevelEventTypes.TOP_CLOSE, &apos;close&apos;, DiscreteEvent ], [ DOMTopLevelEventTypes.TOP_CONTEXT_MENU, &apos;contextMenu&apos;, DiscreteEvent ], [ DOMTopLevelEventTypes.TOP_COPY, &apos;copy&apos;, DiscreteEvent ], [ DOMTopLevelEventTypes.TOP_CUT, &apos;cut&apos;, DiscreteEvent ], [ DOMTopLevelEventTypes.TOP_DOUBLE_CLICK, &apos;doubleClick&apos;, DiscreteEvent ], [ DOMTopLevelEventTypes.TOP_AUX_CLICK, &apos;auxClick&apos;, DiscreteEvent ], [ DOMTopLevelEventTypes.TOP_FOCUS, &apos;focus&apos;, DiscreteEvent ], [ DOMTopLevelEventTypes.TOP_INPUT, &apos;input&apos;, DiscreteEvent ], ...] 那么，这些事件的监听事件是如何被注册的呢。还记得在调和 Class 组件的时候会计算要向浏览器插入什么样的 dom 元素或是要如何更新 dom 元素。在这个过程中会通过 diffProperty 函数对元素的属性进行 diff 对比，其中通过 ListenTo 来添加监听函数 大家都知道，最终被绑定的监听事件一定是被 React 魔改过，然后绑定在 document 上的。 123456789101112131415161718192021222324252627282930313233343536373839404142function trapEventForPluginEventSystem ( element: Document | Element | Node, topLevelType: DOMTopLevelEventType, capture: boolean): void &#123; // 生成一个 listener 监听函数 let listener switch (getEventPriority(topLevelType)) &#123; case DiscreteEvent: &#123; listener = dispatchDiscreteEvent.bind( null, topLevelType, EventSystemFlags.PLUGIN_EVENT_SYSTEM ) break &#125; ... default: &#123; listener = dispatchEvent.bind( null, topLevelType, EventSystemFlags.PLUGIN_EVENT_SYSTEM ) &#125; &#125; // @todo 这里用一个getRawEventName转换了一下 // 这个函数就是 →_→ // const getRawEventName = a =&gt; a // 虽然这个函数什么都没有做 // 但是它的名字语义化的说明了这一步 // 目的是得到浏览器环境下addEventListener第一个参数的合法名称 const rawEventName = topLevelType // 将捕获事件listener挂载到根节点 // 这两个部分都是为了为了兼容 IE 封装过的 addEventListener if (capture) &#123; // 注册捕获事件 addEventCaptureListener(element, rawEventName, listener) &#125; else &#123; // 注册冒泡事件 addEventBubbleListener(element, rawEventName, listener) &#125;&#125; 大家应该都知道 addEventListener 的第三个参数是控制监听捕获过程 or 冒泡过程的吧 ok，right now，鼠标点了下页面，页面调用了这个函数。开局就一个 nativeEvent 对象，这个函数要做的第一件事就是知道真正被点的那个组件是谁，其实看了一些源码就知道， React 但凡有什么事儿第一个步骤总是找到需要负责的那个 fiber 。 首先，通过 nativeEvent 获取目标 dom 元素也就是 dom.target 1const nativeEventTarget = getEventTarget(nativeEvent) 123456789export default function getEventTarget(nativeEvent) &#123; // 兼容写法 let target = nativeEvent.target || nativeEvent.srcElement || window // Normalize SVG // @todo return target.nodeType === HtmlNodeType.TEXT_NODE ? target.parentNode : target&#125; 那么如何通过 dom 拿到这个 dom 对应的 fiber 呢，事实上， React 会给这个 dom 元素添加一个属性指向它对应的 fiber 。对于这个做法我是有疑问的，这样的映射关系也可以通过维护一个 WeekMap 对象来实现，操作一个 WeakMap 的性能或许会优于操作一个 DOM 的属性，且后者似乎不太优雅，如果你有更好的想法也欢迎在评论区指出。 每当 completeWork 中为 fiber 构造了新的 dom，都会给这个 dom 一个指针来指向它的 fiber 12345678910111213141516171819202122232425262728293031323334// 随机Keyconst randomKey = Math.random().toString(36).slice(2)// 随机Key对应的当前实例的Keyconst internalInstanceKey = &apos;__reactInternalInstance$&apos; + randomKey// Key 对应 render 之后的 propsconst internalEventHandlersKey = &apos;__reactEventHandlers$&apos; + randomKey// 对应实例const internalContianerInstanceKey = &apos;__reactContainer$&apos; + randomKey// 绑定操作export function precacheFiberNode ( hostInst: object, node: Document | Element | Node): void &#123; node[internalInstanceKey] = hostInst&#125;// 读取操作export function getClosestInstanceFromNode (targetNode) &#123; let targetInst = targetNode[internalInstanceKey] // 如果此时没有Key，直接返回null if (targetInst) &#123; return targetInst &#125; // 省略了一部分代码 // 如果这个 dom 上面找不到 internalInstanceKey 这个属性 // 就会向上寻找父节点，直到找到一个拥有 internalInstanceKey 属性的 dom 元素 // 这也是为什么这个函数名要叫做 从 node 获取最近的 (fiber) 实例 ... return null&#125; 此时我们已经拥有了原生事件的对象，以及触发了事件的 dom 以及对应的 fiber ，就可以从 fiber.memorizedProps 中取到我们绑定的 onClick 事件。这些信息已经足够生成一个 React 合成事件 ReactSyntheticEvent 的实例了。 React 声明了一个全局变量 事件队列 eventQueue ，这个队列用来存储某次更新中所有被触发的事件，我们需要让这个点击事件入队。然后触发。 123456789101112131415161718192021222324252627// 事件队列let eventQueue: ReactSyntheticEvent[] | ReactSyntheticEvent | null = nullexport function runEventsInBatch ( events: ReactSyntheticEvent[] | ReactSyntheticEvent | null) &#123; if (events !== null) &#123; // 存在 events 的话，加入事件队列 // react 自己写的合并数组函数 accumulateInto // 或许是 ES3 时期写的吧 eventQueue = accumulateInto&lt;ReactSyntheticEvent&gt;(eventQueue, events) &#125; const processingEventQueue = eventQueue // 执行完毕之后要清空队列 // 虽然已经这些 event 已经被释放了，但还是会被遍历 eventQueue = null if (!processingEventQueue) return // 将这些事件逐个触发 // forEachAccumulated 是 React 自己实现的 foreach forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel)&#125; 123456789101112// 触发一个事件并且立刻将事件释放到事件池中，除非执行了presistentconst executeDispatchesAndRelease = function (event: ReactSyntheticEvent) &#123; if (event) &#123; // 按照次序依次触发和该事件类型绑定的所有 listener executeDispatchesInOrder(event) &#125; // 如果没有执行 persist 持久化 , 立即销毁事件 if (!event.isPersistent()) &#123; (event.constructor as any).release(event) &#125;&#125; 可以看到合成事件的构造函数实例上挂载了一个函数 release ，用来释放事件。我们看一看 SyntheticEvent 的代码，可以发现这里使用了一个事件池的概念 eventPool 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465Object.assign(SyntheticEvent.prototype, &#123; // 模拟原生的 preventDefault 函数 preventDefault: function() &#123; this.defaultPrevented = true; const event = this.nativeEvent; if (!event) &#123; return; &#125; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; this.isDefaultPrevented = functionThatReturnsTrue; &#125;, // 模拟原生的 stopPropagation stopPropagation: function() &#123; const event = this.nativeEvent; if (!event) &#123; return; &#125; if (event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; this.isPropagationStopped = functionThatReturnsTrue; &#125;, /** * 在每次事件循环之后，所有被 dispatch 过的合成事件都会被释放 * 这个函数能够允许一个引用使用事件不会被 GC 回收 */ persist: function() &#123; this.isPersistent = functionThatReturnsTrue; &#125;, /** * 这个 event 是否会被 GC 回收 */ isPersistent: functionThatReturnsFalse, /** * 销毁实例 * 就是将所有的字段都设置为 null */ destructor: function() &#123; const Interface = this.constructor.Interface; for (const propName in Interface) &#123; this[propName] = null; &#125; this.dispatchConfig = null; this._targetInst = null; this.nativeEvent = null; this.isDefaultPrevented = functionThatReturnsFalse; this.isPropagationStopped = functionThatReturnsFalse; this._dispatchListeners = null; this._dispatchInstances = null; &#125;,&#125;); React 在构造函数上直接添加了一个事件池属性，其实就是一个数组，这个数组将被全局共用。每当事件被释放的时候，如果线程池的长度还没有超过规定的大小（默认是 10 ），那么这个被销毁后的事件就会被放进事件池 1234567891011121314151617// 为合成事件构造函数添加静态属性// 事件池为所有实例所共用function addEventPoolingTo (EventConstructor) &#123; EventConstructor.eventPool = [] EventConstructor.getPooled = getPooledEvent EventConstructor.release = releasePooledEvent&#125;// 将事件释放// 事件池有容量的话，放进事件池function releasePooledEvent (event) &#123; const EventConstructor = this event.destructor() if (EventConstructor.eventPool.length &lt; EVENT_POOL_SIZE) &#123; EventConstructor.eventPool.push(event) &#125;&#125; 我们都知道单例模式，就是对于一个类在全局最多只会有一个实例。而这种事件池的设计相当于是 n 例模式，每次事件触发完毕之后，实例都要还给构造函数放进事件池，后面的每次触发都将复用这些干净的实例，从而减少内存方面的开销。 12345678910111213141516171819202122// 需要事件实例的时候直接从事件池中取出function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) &#123; const EventConstructor = this if (EventConstructor.eventPool.length) &#123; // 从事件池中取出最后一个 const instance = EventConstructor.eventPool.pop() EventConstructor.call( instance, dispatchConfig, targetInst, nativeEvent, nativeInst ) return instance &#125; return new EventConstructor ( dispatchConfig, targetInst, nativeEvent, nativeInst )&#125; 如果在短时间内浏览器事件被频繁触发，那么将出现的现象是，之前事件池中的实例都被取出复用，而后续的合成事件对象就只能被老老实实重新创建，结束的时候通过放弃引用来被 V8 引擎的 GC 回收。 回到之前的事件触发，如果不特地将属性名写成 onClickCapture 的话，那么默认将被触发的就会是冒泡过程。这个过程也是 React 模拟的，就是通过 fiber 逐层向上触发的方式，捕获过程也是同理。 我们都知道正常的事件触发流程是： 事件捕获 处于事件 事件冒泡 处于事件 阶段是一个 try-catch 语句，这样即使发生错误也会处于 React 的错误捕获机制当中。我们真正想要执行的函数实体就是在此被触发： 1234567891011121314151617181920212223242526export default function invodeGuardedCallbackImpl&lt; A, B, C, D, E, F, Context&gt;( name: string | null, func: (a: A, b: B, c: C, d: D, e: E, f: F) =&gt; void, context?: Context, a?: A, b?: B, c?: C, d?: D, e?: E, f?: F,): void &#123; const funcArgs = Array.prototype.slice.call(arguments, 3) try &#123; func.apply(context, funcArgs) &#125; catch (error) &#123; this.onError(error) &#125;&#125; 类与函数当我们使用类组件或是函数组件的时候，最终目的都是为了得到一份 JSX 来描述我们的页面。那么其中就存在着一个问题—— React 是如何分辨函数组件和类组件的。 虽然在 ES6 中，我们可以轻易的看出 Class 和 函数的区别，但是别忘了，我们实际使用的往往是 babel 编译后的代码，而类就是函数和原型链构成的语法糖。可能大部分人最直接的想法就是，既然类组件继承了 React.Component ，那么应该可以直接使用类类型判断就就行： 1App instanceof React.Component 当然， React 采用的做法是在原型链上添加一个标识 1Component.prototype.isReactComponent = &#123;&#125; 源码中需要判断是否是类组件的时候，就可以直接读取函数的 isReactComponent 属性时，因为在函数（也是对象）自身找不到时，就会向上游原型链逐级查找，直到到达 Object.prototype 对象为止。 为什么 isReactComponent 是一个对象而不是布尔以及为什么不能用 instanceOf 状态的更新之前我们已经看懂了 React 的事件委托机制，那么不如在一次点击事件中尝试修改组件的状态来更新我们的页面。 首先康康 setState 是如何工作的，我们知道 this.setState 是 React.Component 类中的方法： 12345678910111213141516/** * @description 更新组件state * @param &#123; object | Function &#125; partialState 下个阶段的状态 * @param &#123; ?Function &#125; callback 更新完毕之后的回调 */Component.prototype.setState = function (partialState, callback) &#123; if (!( isObject(partialState) || isFunction(partialState) || isNull )) &#123; console.warn(&apos;setState的第一个参数应为对象、函数或null&apos;) return &#125; this.updater.enqueueSetState(this, partialState, callback, &apos;setState&apos;)&#125; 看起来核心步骤就是触发挂载在实例上的一个 updater 对象。默认的， updater 会是一个展位的空对象，虽然实现了 enqueueSetState 等方法，但是这些方法内部都是空的。 12// 我们初始化这个默认的update，真正的updater会被renderer注入this.updater = updater || ReactNoopUpdateQueue 12345678910111213141516171819202122232425262728293031323334353637383940export const ReactNoopUpdateQueue = &#123; /** * 检查组件是否已经挂载 */ isMounted: function (publishInstance) &#123; // 初始化ing的组件就别挂载不挂载了 return false &#125;, /** * 强制更新 */ enqueueForceUpdate: function (publishInstance, callback, callerName) &#123; console.warn(&apos;enqueueForceUpdate&apos;, publishInstance) &#125;, /** * 直接替换整个state,通常用这个或者setState来更新状态 */ enqueueReplaceState: function ( publishInstance, completeState, callback, callerName ) &#123; console.warn(&apos;enqueueReplaceState&apos;, publishInstance) &#125;, /** * 修改部分state */ enqueueSetState: function ( publishInstance, partialState, callback, callerName ) &#123; console.warn(&apos;enqueueSetState&apos;, publishInstance) &#125;&#125; 还记得我们在 render 的过程中，是通过执行 Component.render() 来获得一个类组件的实例，当 React 得到了这个实例之后，就会将实例的 updater 替换成真正的 classComponentUpdater ： 1234567function adoptClassInstance ( workInProgress: Fiber, instance: any): void &#123; instance.updater = classComponentUpdate ...&#125; 刚刚我们触发了这个对象中的 enqueueSetState 函数，那么可以看看实现： 123456789101112131415161718192021222324252627282930313233343536const classComponentUpdate = &#123; isMounted, /** * 触发组件状态的更新 * @param inst ReactElement * @param payload any * @param callback 更新结束之后的回调 */ enqueueSetState( inst: ReactElement, payload: any, callback?: Function ) &#123; // ReactElement -&gt; fiber const fiber = getInstance(inst) // 当前时间 const currentTime = requestCurrentTime() // 获取当前 suspense config const suspenseConfig = requestCurrentSuspenseConfig() // 计算当前 fiber 节点的任务过期时间 const expirationTime = computeExpirationForFiber( currentTime, fiber, suspenseConfig ) // 创建一个 update 实例 const update = createUpdate(expirationTime, suspenseConfig) update.payload = payload // 将 update 装载到 fiber 的 queue 中 enqueueUpdate(fiber, update) // 安排任务 ScheduleWork(fiber, expirationTime) &#125;, ...&#125; 显然，这个函数的作用就是获得类组件对应的 fiber ，更新它在任务调度器中的过期时间（领导给了新工作，自然要定新的 Deadline ），然后就是创建一个新的 update 任务装载到 fiber 的任务队列中。最后通过 ScheduleWork （告诉任务调度器来任务了，赶紧干活） 要求从这个 fiber 开始调和，至于调和和更新的步骤我们在第一次渲染中已经有了大致的了解。 顺带提一提 Hooks 中的 useState 。网络上有挺多讲解 hook 实现的文章已经讲得很全面了，我们只需要搞清楚以下几点问题。 Q1. 函数组件不像类组件一样拥有实例，数据存储在哪里 A1. 任何以 ReactElement 为粒度的组件都需要围绕 fiber ，数据存储在 fiber.memorizedState 上 Q2. useState 的实现 A2. 如果你听过了 useState 那么你就应该听过 useReducer ，如果听过 reducer 就应该知道 redux。首先，useState 的本质就是 useReducer 的语法糖。我们都知道构建一个状态库需要一个 reducer ，useState 就是当 reducer 函数为 a =&gt; a 时的特殊情况。 123456789function basicStateReducer&lt;S&gt;(state: S, action: BasicStateAction&lt;S&gt;): S &#123; return typeof action === &apos;function&apos; ? action(state) : action&#125;function updateState&lt;S&gt;( initialState: (() =&gt; S) | S): [ S, Dispatch&lt;BasicStateAction&lt;S&gt;&gt; ] &#123; return updateReducer&lt;S, (() =&gt; S) | S, any&gt;(basicStateReducer, initialState)&#125; Q3. 为什么 Hooks 的顺序和个数不允许改变 A3. 每次执行 Hooks 函数需要取出上一次渲染时数据的最终状态，因为结构是链表而不是一个 Map，所以这些最终状态也会是有序的，所以如果个数和次序改变会导致数据的错乱。 时间调度机制虽然今年过期时间 expirationTime 机制已经被淘汰了，但是不管是航道模型还是过期时间，本质上都是任务优先级的不同体现形式。 在探究运行机制之前我们需要知道一个问题就是，为什么时间片的性能会优于同步计算的性能。此处借用司徒正美老师文章中的例子。 实验1，通过 for 循环一次性向 document 中插入1000 个节点 1234567891011121314function randomHexColor()&#123; return &quot;#&quot; + (&quot;0000&quot;+ (Math.random() * 0x1000000 &lt;&lt; 0).toString(16)).substr(-6);&#125;setTimeout(function() &#123; var k = 0; var root = document.getElementById(&quot;root&quot;); for(var i = 0; i &lt; 10000; i++)&#123; k += new Date - 0 ; var el = document.createElement(&quot;div&quot;); el.innerHTML = k; root.appendChild(el); el.style.cssText = background:$&#123;randomHexColor()&#125;;height:40px ; &#125;&#125;, 1000); 实验2，进行 10 次 setTimeout 分批次操作，每次插入 100 个节点 1234567891011121314151617181920212223function randomHexColor() &#123; return &quot;#&quot; + (&quot;0000&quot; + (Math.random() * 0x1000000 &lt;&lt; 0).toString(16)).substr(-6);&#125;var root = document.getElementById(&quot;root&quot;);setTimeout(function () &#123; function loop(n) &#123; var k = 0; console.log(n); for (var i = 0; i &lt; 100; i++) &#123; k += new Date - 0; var el = document.createElement(&quot;div&quot;); el.innerHTML = k; root.appendChild(el); el.style.cssText = background:$&#123;randomHexColor()&#125;;height:40px ; &#125; if (n) &#123; setTimeout(function () &#123; loop(n - 1); &#125;, 40); &#125; &#125; loop(100);&#125;, 1000); 相同的结果，第一个实验花费了 1000 ms，而第二个实验仅仅花费了 31.5 ms。 这和 V8 引擎的底层原理有关，我们都知道浏览器是单线程，一次性需要做到 GUI 描绘，事件处理，JS 执行等多个操作时，V8 引擎会优先对代码进行执行，而不会对执行速度进行优化。如果我们稍微给浏览器一些时间，浏览器就能够进行 JIT ，也叫热代码优化。 简单来说， JS 是一种解释型语言，每次执行都需要被编译成字节码才能被运行。但是如果某个函数被多次执行，且参数类型和参数个数始终保持不变。那么这段代码会被识别为 热代码 ，遵循着“万物皆可空间换时间”的原则，这段代码的字节码会被缓存，下次再次运行的时候就会直接被运行而不需要进行耗时的解释操作。也就是 解释器 + 编译器 的模式。 做个比喻来说，我们工作不能一直蛮干，必须要给自己一些时间进行反思和总结，否则工作速度和效率始终是线性的，人也不会有进步。 还记得在 WorkLoop 函数中，每次处理完一个 fiber 都会跳出循环执行一次 shouldYield 函数进行判断，是否应该将执行权交还给浏览器处理用户时间或是渲染。看看这个 shouldYield 函数的代码： 12345678910111213141516171819202122232425// 当前是否应该阻塞 react 的工作function shouldYield (): boolean &#123; // 获取当前的时间点 const currentTime = getCurrentTime() // 检查任务队列中是否有任务需要执行 advanceTimers(currentTime) // 取出任务队列中任务优先级最高的任务 const firstTask = peek(taskQueue) // 以下两种情况需要yield // 1. 当前任务队列中存在任务，且第一个任务的开始时间还没到，且过期时间小于当前任务 // 2. 处于固定的浏览器渲染时间区间 return ( ( currentTask !== null &amp;&amp; firstTask !== null &amp;&amp; (firstTask as any).startTime &lt;= currentTime &amp;&amp; (firstTask as any).expirationTime &lt; currentTask.expirationTime ) // 当前处于时间片的阻塞区间 || shouldYieldToHost() )&#125; 决定一个任务当前是否应该被执行有两个因素。 这个任务是否非执行不可，正所谓一切的不论是不是先问为什么都是耍流氓。如果到期时间还没到，为什么不先把线程空出来留给可能的高优先级任务呢。 如果多个任务都非执行不可，那么任务的优先级是否是当前队列中最高的。 如果一个任务的过期时间已经到了必须执行，那么这个任务就应该处于 待执行队列 taskQueue 中。相反这个任务的过期时间还没到，就可以先放在 延迟列表 中。每一帧结束的时候都会执行 advanceTimer 函数，将一些延迟列表中到期的任务取出，插入待执行队列。 可能是出于最佳实践考虑，待执行队列是一个小根堆结构，而延迟队列是一个有序链表。 回想一下 React 的任务调度要求，当一个新的优先级更高的任务产生，需要能够打断之前的工作并插队。也就是说，React 需要维持一个始终有序的数组数据结构。因此，React 自实现了一个小根堆，但是这个小根堆无需像堆排序的结果一样整体有序，只需要保证每次进行 push 和 pop 操作之后，优先级最高的任务能够到达堆顶。 所以 shouldYield 返回 true 的一个关键条件就是，当前 taskQueue 堆中的堆顶任务的过期时间已经到了，那么就应该暂停工作交出线程使用权。 那么待执行的任务是如何被执行的呢。这里我们需要先了解 MessageChannel 的概念。Message Channel 的实例会拥有两个端口，其中第一个端口为发送信息的端口，第二个端口为接收信息的端口。当接收到信息就可以执行指定的回调函数。 12345const channel = new MessageChannel()// 发送端const port = channel.port2// 接收端channel.port1.onmessage = performWorkUntilDeadline // 在一定时间内尽可能的处理任务 每当待执行任务队列中有任务的时候，就会通过 Channel 的发送端发送一个空的 message ，当接收端异步地接收到这个信号的时候，就会在一个时间片内尽可能地执行任务。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 记录任一时间片的结束时刻let deadline = 0// 单位时间切片长度let yieldInterval = 5// 执行任务直到用尽当前时间片空闲时间function performWorkUntilDeadline () &#123; if (scheduledHostCallback !== null) &#123; // 如果有计划任务，那么需要执行 // 当前时间 const currentTime = getCurrentTime() // 在每个时间片之后阻塞(5ms) // deadline 为这一次时间片的结束时间 deadline = currentTime + yieldInterval // 既然能执行这个函数，就代表着还有时间剩余 const hasTimeRemaining = true try &#123; // 将当前阻塞的任务计划执行 const hasMoreWork = scheduledHostCallback( hasTimeRemaining, currentTime ) if (!hasMoreWork) &#123; // 如果没有任务了, 清空数据 isMessageLoopRunning = false scheduledHostCallback = null &#125; else &#123; // 如果还有任务，在当前时间片的结尾发送一个 message event // 接收端接收到的时候就将进入下一个时间片 port.postMessage(null) &#125; &#125; catch (error) &#123; port.postMessage(null) throw(error) &#125; &#125; else &#123; // 压根没有任务，不执行 isMessageLoopRunning = false &#125;&#125; 我们在之前说过，阻塞 WorkLoop 的条件有两个，第一个是任务队列的第一个任务还没到时间，第二个条件就是 shouldYieldToHost 返回 true，也就是处于时间片期间。 1234// 此时是否是【时间片阻塞】区间export function shouldYieldToHost () &#123; return getCurrentTime() &gt;= deadline&#125; 总结一下，时间调度机制其实就是 fiber 遍历任务 WorkLoop 和调度器中的任务队列争夺线程使用权的过程。不过区别是前者完全是同步的过程，只会在每个 while 的间隙去询问 调度器 ：我是否可以继续执行下去。而在调度器拿到线程使用权的每个时间片中，都会尽可能的处理任务队列中的任务。 传统武术讲究点到为止，以上内容，就是这次 React 原理的全部。在文章中我并没有放出大量的代码，只是放出了一些片段用来佐证我对于源码的一些看法和观点，文中的流程只是一个循序思考的过程，如果需要查看更多细节还是应该从源码入手。 当然文中的很多观点带有主观色彩，并不一定就正确，同时我也不认为网络上的其他文章的说法就和 React 被设计时的初衷完全一致，甚至 React 源码中的很多写法也未必完美。不管阅读什么代码，我们都不要神话它，而是应该辩证的去看待它。总的来说，功过91开。 前端世界并不需要第二个 React ，我们学习的意义并不是为了证明我们对这个框架有多么了解。而是通过窥探这些顶级工程师的实现思路，去完善我们自己的逻辑体系，从而成为一个更加严谨的人。","pubDate":"Thu, 12 Nov 2020 12:10:20 GMT","guid":"https://aotu.io/notes/2020/11/12/react-indoor/","category":"经验分享"},{"title":"MongoDB 副本集之入门篇","link":"https://aotu.io/notes/2020/11/12/mongo-replica-set/","description":"mongodb 副本集之入门篇前言：mongodb 因为高性能、高可用性、支持分片等特性，作为非关系型数据库被大家广泛使用。其高可用性主要是体现在 mongodb 的副本集上面（可以简单理解为一主多从的集群），本篇文章主要从副本集介绍、本地搭建副本集、副本集读写数据这三个方面来带大家认识下 mongodb 副本集。 一、 mongodb 副本集介绍mongodb 副本集（Replica Set）包括主节点（primary）跟副本节点（Secondaries）。 主节点只能有一个，所有的写操作请求都在主节点上面处理。副本节点可以有多个，通过同步主节点的操作日志（oplog）来备份主节点数据。 在主节点挂掉后，有选举权限的副本节点会自动发起选举，并从中选举出新的主节点。 副本节点可以通过配置指定其具体的属性，比如选举、隐藏、延迟同步等，最多可以有50个副本节点，但只能有7个副本节点能参与选举。虽然副本节点不能处理写操作，但可以处理读请求，这个下文会专门讲到。 搭建一个副本集集群最少需要三个节点：一个主节点，两个备份节点，如果三个节点分布合理，基本可以保证线上数据99.9%安全。三个节点的架构如下图所示： 如果只有一个主节点，一个副本节点，且没有资源拿来当第二个副本节点，那就可以起一个仲裁者节点（arbiter），不存数据，只用来选举用，如下图所示： 当主节点挂掉后，那么两个副本节点会进行选举，从中选举出一个新的主节点，流程如下： 对于副本集成员属性，特别需要说明下这几个：priority、hidden、slaveDelay、tags、votes。 priority 对于副本节点，可以通过该属性来增大或者减小该节点被选举成为主节点的可能性，取值范围为0-1000（如果是arbiters，则取值只有0或者1），数据越大，成为主节点的可能性越大，如果被配置为0，那么他就不能被选举成为主节点，而且也不能主动发起选举。 这种特性一般会被用在有多个数据中心的情况下，比如一个主数据中心，一个备份数据中心，主数据中心速度会更快，如果主节点挂掉，我们肯定希望新主节点也在主数据中心产生，那么我们就可以设置在备份数据中心的副本节点优先级为0，如下图所示： hidden 隐藏节点会从主节点同步数据，但对客户端不可见，在mongo shell 执行 db.isMaster() 方法也不会展示该节点，隐藏节点必须Priority为0，即不可以被选举成为主节点。但是如果有配置选举权限的话，可以参与选举。 因为隐藏节点对客户端不可见，所以跟客户端不会互相影响，可以用来备份数据或者跑一些后端定时任务之类的操作，具体如下图，4个备份节点都从主节点同步数据，其中1个为隐藏节点： slaveDelay 延迟同步即延迟从主节点同步数据，比如延迟时间配置的1小时，现在时间是 09:52，那么延迟节点中只同步到主节点 08:52 之前的数据。另外需要注意延迟节点必须是隐藏节点，且Priority为0。 那这个延迟节点有什么用呢？有过数据库误操作惨痛经历的开发者肯定知道答案，那就是为了防止数据库误操作，比如更新服务前，一般会先执行数据库更新脚本，如果脚本有问题，且操作前未做备份，那数据可能就找不回了。但如果说配置了延迟节点，那误操作完，还有该节点可以兜底，只能说该功能真是贴心。具体延迟节点如下图所展示： tags 支持对副本集成员打标签，在查询数据时会用到，比如找到对应标签的副本节点，然后从该节点读取数据，这点也非常有用，可以根据标签对节点分类，查询数据时不同服务的客户端指定其对应的标签的节点，对某个标签的节点数量进行增加或减少，也不怕会影响到使用其他标签的服务。Tags 的具体使用，文章下面章节也会讲到。 votes 表示节点是否有权限参与选举，最大可以配置7个副本节点参与选举。 二、副本集的搭建以及测试安装mongodb 教程：https://docs.mongodb.com/manual/installation/ 我们来搭建一套 P-S-S 结构的副本集（1个 Primary 节点，2个 Secondary 节点），大致过程为：先启动三个不同端口的 mongod 进程，然后在 mongo shell 中执行命令初始化副本集。 启动单个mongod 实例的命令为： mongod --replSet rs0 --port 27017 --bind_ip localhost,&lt;hostname(s)|ip address(es)&gt; --dbpath /data/mongodb/rs0-0 --oplogSize 128 参数说明： 参数 说明 示例 replSet 副本集名称 rs0 port mongod 实例端口 27017 bind_ip 访问该实例的地址列表，只是本机访问可以设置为localhost 或者 127.0.0.1，生产环境建议使用内部域名 Localhost dbpath 数据存放位置 /data/mongodb/rs0-0 oplogSize 操作日志大小 128 搭建步骤如下： 先创建三个目录来分别存放这三个节点的数据 mkdir -p /data/mongodb/rs0-0 /data/mongodb/rs0-1 /data/mongodb/rs0-2 分别启动三个mongod 进程，端口分别为：27018，27019，27020 第一个： mongod --replSet rs0 --port 27018 --bind_ip localhost --dbpath /data/mongodb/rs0-0 --oplogSize 128 第二个： mongod --replSet rs0 --port 27019 --bind_ip localhost --dbpath /data/mongodb/rs0-1 --oplogSize 128 第三个： mongod --replSet rs0 --port 27020 --bind_ip localhost --dbpath /data/mongodb/rs0-2 --oplogSize 128 使用 mongo 进入第一个 mongod 示例，使用 rs.initiate() 进行初始化 登录到27018： mongo localhost:27018 执行： 12345678910111213141516171819rsconf = &#123; _id: \"rs0\", members: [ &#123; _id: 0, host: \"localhost:27018\" &#125;, &#123; _id: 1, host: \"localhost:27019\" &#125;, &#123; _id: 2, host: \"localhost:27020\" &#125; ]&#125;rs.initiate( rsconf ) 以上就已经完成了一个副本集的搭建，在 mongo shell 中执行 rs.conf() 可以看到每个节点中 host、arbiterOnly、hidden、priority、 votes、slaveDelay等属性，是不是超级简单。。 执行 rs.conf() ，结果展示如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364rs.conf()&#123; \"_id\" : \"rs0\", \"version\" : 1, \"protocolVersion\" : NumberLong(1), \"writeConcernMajorityJournalDefault\" : true, \"members\" : [ &#123; \"_id\" : 0, \"host\" : \"localhost:27018\", \"arbiterOnly\" : false, \"buildIndexes\" : true, \"hidden\" : false, \"priority\" : 1, \"tags\" : &#123; &#125;, \"slaveDelay\" : NumberLong(0), \"votes\" : 1 &#125;, &#123; \"_id\" : 1, \"host\" : \"localhost:27019\", \"arbiterOnly\" : false, \"buildIndexes\" : true, \"hidden\" : false, \"priority\" : 1, \"tags\" : &#123; &#125;, \"slaveDelay\" : NumberLong(0), \"votes\" : 1 &#125;, &#123; \"_id\" : 2, \"host\" : \"localhost:27020\", \"arbiterOnly\" : false, \"buildIndexes\" : true, \"hidden\" : false, \"priority\" : 1, \"tags\" : &#123; &#125;, \"slaveDelay\" : NumberLong(0), \"votes\" : 1 &#125; ], \"settings\" : &#123; \"chainingAllowed\" : true, \"heartbeatIntervalMillis\" : 2000, \"heartbeatTimeoutSecs\" : 10, \"electionTimeoutMillis\" : 10000, \"catchUpTimeoutMillis\" : -1, \"catchUpTakeoverDelayMillis\" : 30000, \"getLastErrorModes\" : &#123; &#125;, \"getLastErrorDefaults\" : &#123; \"w\" : 1, \"wtimeout\" : 0 &#125;, \"replicaSetId\" : ObjectId(\"5f957f12974186fc616688fb\") &#125;&#125; 特别注意下：在 mongo shell 中，有 rs 跟 db。 rs 是指副本集，有rs.initiate()，rs.conf(), rs.reconfig(), rs.add() 等操作副本集的方法 db 是指数据库，其下是对数据库的一些操作，比如下面会用到 db.isMaster(), db.collection.find(), db.collection.insert() 等。 我们再来测试下 Automatic Failover 可以直接停掉主节点localhost:27018 来测试下主节点挂掉后，副本节点重新选举出新的主节点，即自动故障转移（Automatic Failover） 杀掉主节点 27018后，可以看到 27019 的输出日志里面选举部分，27019 发起选举，并成功参选成为主节点： 123452020-10-26T21:43:58.156+0800 I REPL [replexec-304] Scheduling remote command request for vote request: RemoteCommand 100694 -- target:localhost:27018 db:admin cmd:&#123; replSetRequestVotes: 1, setName: \"rs0\", dryRun: false, term: 17, candidateIndex: 1, configVersion: 1, lastCommittedOp: &#123; ts: Timestamp(1603719830, 1), t: 16 &#125; &#125;2020-10-26T21:43:58.156+0800 I REPL [replexec-304] Scheduling remote command request for vote request: RemoteCommand 100695 -- target:localhost:27020 db:admin cmd:&#123; replSetRequestVotes: 1, setName: \"rs0\", dryRun: false, term: 17, candidateIndex: 1, configVersion: 1, lastCommittedOp: &#123; ts: Timestamp(1603719830, 1), t: 16 &#125; &#125;2020-10-26T21:43:58.159+0800 I ELECTION [replexec-301] VoteRequester(term 17) received an invalid response from localhost:27018: ShutdownInProgress: In the process of shutting down; response message: &#123; operationTime: Timestamp(1603719830, 1), ok: 0.0, errmsg: \"In the process of shutting down\", code: 91, codeName: \"ShutdownInProgress\", $clusterTime: &#123; clusterTime: Timestamp(1603719830, 1), signature: &#123; hash: BinData(0, 0000000000000000000000000000000000000000), keyId: 0 &#125; &#125; &#125;2020-10-26T21:43:58.164+0800 I ELECTION [replexec-305] VoteRequester(term 17) received a yes vote from localhost:27020; response message: &#123; term: 17, voteGranted: true, reason: \"\", ok: 1.0, $clusterTime: &#123; clusterTime: Timestamp(1603719830, 1), signature: &#123; hash: BinData(0, 0000000000000000000000000000000000000000), keyId: 0 &#125; &#125;, operationTime: Timestamp(1603719830, 1) &#125;2020-10-26T21:43:58.164+0800 I ELECTION [replexec-304] election succeeded, assuming primary role in term 17 然后执行 rs.status() 查看当前副本集情况，可以看到27019变为主节点，27018 显示已挂掉 health = 0 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990rs.status()&#123; \"set\" : \"rs0\", \"date\" : ISODate(\"2020-10-26T13:44:22.071Z\"), \"myState\" : 1, \"heartbeatIntervalMillis\" : NumberLong(2000), \"majorityVoteCount\" : 2, \"writeMajorityCount\" : 2, \"members\" : [ &#123; \"_id\" : 0, \"name\" : \"localhost:27018\", \"ip\" : \"127.0.0.1\", \"health\" : 0, \"state\" : 8, \"stateStr\" : \"(not reachable/healthy)\", \"uptime\" : 0, \"optime\" : &#123; \"ts\" : Timestamp(0, 0), \"t\" : NumberLong(-1) &#125;, \"optimeDurable\" : &#123; \"ts\" : Timestamp(0, 0), \"t\" : NumberLong(-1) &#125;, \"optimeDate\" : ISODate(\"1970-01-01T00:00:00Z\"), \"optimeDurableDate\" : ISODate(\"1970-01-01T00:00:00Z\"), \"lastHeartbeat\" : ISODate(\"2020-10-26T13:44:20.202Z\"), \"lastHeartbeatRecv\" : ISODate(\"2020-10-26T13:43:57.861Z\"), \"pingMs\" : NumberLong(0), \"lastHeartbeatMessage\" : \"Error connecting to localhost:27018 (127.0.0.1:27018) :: caused by :: Connection refused\", \"syncingTo\" : \"\", \"syncSourceHost\" : \"\", \"syncSourceId\" : -1, \"infoMessage\" : \"\", \"configVersion\" : -1 &#125;, &#123; \"_id\" : 1, \"name\" : \"localhost:27019\", \"ip\" : \"127.0.0.1\", \"health\" : 1, \"state\" : 1, \"stateStr\" : \"PRIMARY\", \"uptime\" : 85318, \"optime\" : &#123; \"ts\" : Timestamp(1603719858, 1), \"t\" : NumberLong(17) &#125;, \"optimeDate\" : ISODate(\"2020-10-26T13:44:18Z\"), \"syncingTo\" : \"\", \"syncSourceHost\" : \"\", \"syncSourceId\" : -1, \"infoMessage\" : \"\", \"electionTime\" : Timestamp(1603719838, 1), \"electionDate\" : ISODate(\"2020-10-26T13:43:58Z\"), \"configVersion\" : 1, \"self\" : true, \"lastHeartbeatMessage\" : \"\" &#125;, &#123; \"_id\" : 2, \"name\" : \"localhost:27020\", \"ip\" : \"127.0.0.1\", \"health\" : 1, \"state\" : 2, \"stateStr\" : \"SECONDARY\", \"uptime\" : 52468, \"optime\" : &#123; \"ts\" : Timestamp(1603719858, 1), \"t\" : NumberLong(17) &#125;, \"optimeDurable\" : &#123; \"ts\" : Timestamp(1603719858, 1), \"t\" : NumberLong(17) &#125;, \"optimeDate\" : ISODate(\"2020-10-26T13:44:18Z\"), \"optimeDurableDate\" : ISODate(\"2020-10-26T13:44:18Z\"), \"lastHeartbeat\" : ISODate(\"2020-10-26T13:44:20.200Z\"), \"lastHeartbeatRecv\" : ISODate(\"2020-10-26T13:44:21.517Z\"), \"pingMs\" : NumberLong(0), \"lastHeartbeatMessage\" : \"\", \"syncingTo\" : \"localhost:27019\", \"syncSourceHost\" : \"localhost:27019\", \"syncSourceId\" : 1, \"infoMessage\" : \"\", \"configVersion\" : 1 &#125; ]&#125; 再次启动27018：mongod --replSet rs0 --port 27018 --bind_ip localhost --dbpath /data/mongodb/rs0-0 --oplogSize 128 可以在节点 27019 日志中看到已检测到 27018，并且已变为副本节点，通过rs.status 查看结果也是如此。 12020-10-26T21:52:06.871+0800 I REPL [replexec-305] Member localhost:27018 is now in state SECONDARY 三、副本集写跟读的一些特性写关注（Write concern） 副本集写关注是指写入一条数据，主节点处理完成后，需要其他承载数据的副本节点也确认写成功后，才能给客户端返回写入数据成功。 这个功能主要是解决主节点挂掉后，数据还未来得及同步到副本节点，而导致数据丢失的问题。 可以配置节点个数，默认配置 {“w”：1}，这样表示主节点写入数据成功即可给客户端返回成功，“w” 配置为2，则表示除了主节点，还需要收到其中一个副本节点返回写入成功，“w” 还可以配置为 “majority”，表示需要集群中大多数承载数据且有选举权限的节点返回写入成功。 如下图所示，P-S-S 结构（一个 primary 节点，两个 secondary 节点），写请求里面带了w : “majority” ，那么主节点写入完成后，数据同步到第一个副本节点，且第一个副本节点回复数据写入成功后，才给客户端返回成功。 关于写关注在实际中如何操作，有下面两种方法： 在写请求中指定 writeConcern 相关参数，如下： 1234db.products.insert( &#123; item: \"envelopes\", qty : 100, type: \"Clasp\" &#125;, &#123; writeConcern: &#123; w: \"majority\" , wtimeout: 5000 &#125; &#125;) 修改副本集 getLastErrorDefaults 配置，如下： 123cfg = rs.conf()cfg.settings.getLastErrorDefaults = &#123; w: \"majority\", wtimeout: 5000 &#125;rs.reconfig(cfg) 读偏好 （Read preference）读跟写不一样，为了保持一致性，写只能通过主节点，但读可以选择主节点，也可以选择副本节点，区别是主节点数据最新，副本节点因为同步问题可能会有延迟，但从副本节点读取数据可以分散对主节点的压力。 因为承载数据的节点会有多个，那客户端如何选择从那个节点读呢？主要有3个条件（Tag Sets、 maxStalenessSeconds、Hedged Read），5种模式（primary、primaryPreferred、secondary、secondaryPreferred、nearest） 首先说一下 5种模式，其特点如下表所示： 模式 特点 primary 所有读请求都从主节点读取 primaryPreferred 主节点正常，则所有读请求都从主节点读取，如果主节点挂掉，则从符合条件的副本节点读取 secondary 所有读请求都从副本节点读取 secondaryPreferred 所有读请求都从副本节点读取，但如果副本节点都挂掉了，那就从主节点读取 nearest 主要看网络延迟，选取延迟最小的节点，主节点跟副本节点均可 再说下3个条件，条件是在符合模式的基础上，再根据条件删选具体的节点 Tag Sets（标签） 顾名思义，这个可以给节点加上标签，然后查找数据时，可以根据标签选择对应的节点，然后在该节点查找数据。可以通过mongo shell 使用 rs.conf() 查看当前每个节点下面的 tags， 修改或者添加tags 过程同上面修改 getLastErrorDefaults 配置 ，如：cfg.members[n].tags = { &quot;region&quot;: &quot;South&quot;, &quot;datacenter&quot;: &quot;A&quot; } maxStalenessSeconds （可容忍的最大同步延迟） 顾名思义+1，这个值是指副本节点同步主节点写入的时间 跟 主节点实际最近写入时间的对比值，如果主节点挂掉了，那就跟副本集中最新写入的时间做对比。 这个值建议设置，避免因为部分副本节点网络原因导致比较长时间未同步主节点数据，然后读到比较老的数据。特别注意的是该值需要设置 90s 以上，因为客户端是定时去校验副本节点的同步延迟时间，数据不会特别准确，设置比 90s 小，会抛出异常。 Hedged Read （对冲读取） 该选项是在分片集群 MongoDB 4.4 版本后才支持，指 mongos 实例路由读取请求时会同时发给两个符合条件的副本集节点，然后那个先返回结果就返回这个结果给客户端。 那问题来了，如此好用的模式以及条件在查询请求中如何使用呢？ 在代码中连接数据库，使用 connection string uri 时，可以加上下面的这三个参数 | 参数 | 说明 || ——————- | ———————————————————— || readPreference | 模式，枚举值有：primary（默认值）、 primaryPreferred、secondary、secondaryPreferred、nearest || maxStalenessSeconds | 最大同步延时秒数，取值0 - 90 会报错， -1 表示没有最大值 || readPreferenceTags | 标签，如果标签是 { “dc”: “ny”, “rack”: “r1” }, 则在uri 为 readPreferenceTags=dc:ny,rack:r1 | 例如下面： mongodb://db0.example.com,db1.example.com,db2.example.com/?replicaSet=myRepl&amp;readPreference=secondary&amp;maxStalenessSeconds=120&amp;readPreferenceTags=dc:ny,rack:r1 在mogo shell 中，可以使用 cursor.readPref() 或者 Mongo.setReadPref() cursor.readPref() 参数分别为： mode、tag set、hedge options, 具体请求例如下面这样 12345db.collection.find(&#123; &#125;).readPref( \"secondary\", // mode [ &#123; \"datacenter\": \"B\" &#125;, &#123; &#125; ], // tag set &#123; enabled: true &#125; // hedge options) Mongo.setReadPref() 类似，只是预先设置请求条件，这样就不用每个请求后面带上 readPref 条件。 可以在搭建好的集群中简单测试下该功能 登录主节点： mongo localhost:27018 插入一条数据： db.nums.insert({name: “num0”}) 在当前节点查询: db.nums.find() 可以看到本条数据： { &quot;_id&quot; : ObjectId(&quot;5f958687233b11771912ced5&quot;), &quot;name&quot; : &quot;num0&quot; } 登录副本节点： mongo localhost:27019 查询：db.nums.find() 因为查询模式默认为 primary，所以在副本节点查询会报错，如下： 1234567891011121314Error: error: &#123; \"operationTime\" : Timestamp(1603788383, 1), \"ok\" : 0, \"errmsg\" : \"not master and slaveOk=false\", \"code\" : 13435, \"codeName\" : \"NotMasterNoSlaveOk\", \"$clusterTime\" : &#123; \"clusterTime\" : Timestamp(1603788383, 1), \"signature\" : &#123; \"hash\" : BinData(0,\"AAAAAAAAAAAAAAAAAAAAAAAAAAA=\"), \"keyId\" : NumberLong(0) &#125; &#125;&#125; 查询时指定模式为 “secondary”： db.nums.find().readPref(“secondary&quot;) 就可以查询到插入的数据：{ &quot;_id&quot; : ObjectId(&quot;5f958687233b11771912ced5&quot;), &quot;name&quot; : &quot;num0&quot; } 结语以上内容都是阅读 MongoDB 官方文档后，然后挑简单且重要的一些点做的总结，如果大家对 MongoDB 感兴趣，建议直接啃一啃官方文档。","pubDate":"Thu, 12 Nov 2020 12:10:20 GMT","guid":"https://aotu.io/notes/2020/11/12/mongo-replica-set/","category":"经验分享"},{"title":"EaseJs 中 regX / regY 的用法","link":"https://aotu.io/notes/2020/11/05/easeJs-center-setting/","description":"前情提要动效开发中最常用的基本变形动作就是缩放、旋转等，该变形会涉及到中心点的设置。由于我们采用了createJs中的easeJs库进行图形绘制，这个时候我们就会用到regX/regY。下面先看一个小demo: 我们先在页面中画一个100x100的矩形，并放置在canvas中间，代码如下：123456789101112131415161718192021222324252627282930313233import React, &#123; useRef, useEffect &#125; from \"react\";import &#123; Power0, TweenMax as Tween &#125; from \"gsap\";import &#123; Stage, Shape, Graphics, Ticker &#125; from \"@createjs/easeljs\";import \"./App.css\";function MotionDemo() &#123; const canvasRef = useRef(null); Tween.ticker.fps(24); useEffect(() =&gt; &#123; canvasRef.current.width = 400; canvasRef.current.height = 400; let stage; window.stage = stage = new Stage(canvasRef.current); const graphics = new Graphics().beginFill(\"#0ff\").drawRect(0, 0, 100, 100); const shape = new Shape(graphics); window.stage.addChild(shape); //将矩形放置在canvas中 shape.x = 150; shape.y = 150; shape.alpha = 0.3; Ticker.on(\"tick\", e =&gt; &#123; stage.update(); &#125;); &#125;, []); return ( &lt;div style=&#123;&#123; position: \"relative\", width: \"100%\", height: \"100%\" &#125;&#125;&gt; &lt;div style=&#123;&#123; position: \"absolute\", left: \"10%\", top: \"20%\" &#125;&#125;&gt; &lt;canvas className=\"canvas\" ref=&#123;canvasRef&#125; width=&#123;200&#125; height=&#123;200&#125; /&gt; &lt;/div&gt; &lt;/div&gt; );&#125;export default MotionDemo 效果如下： ^_^ 继续说回regX/regY什么是regX/regY 官方文档解释： regX：The left offset for this display object’s registration point.即该显示对象注册点的左偏移量。 regY:The y offset for this display object’s registration point.即该显示对象注册点的上偏移量。 需要明确的是： regX/regY为正时，对象往左上偏移；regX/regY为负，则向右下偏移。现在我们让中间的矩形动起来,向useEffect 底部添加如下代码:12345Tween.to(shape, 2, &#123; rotation: 360, repeat: -1, ease: Power0.easeNone, &#125;) 效果如下： 很显然我们能发现，该对象的注册点即左顶点。 设置regX/regY绕图形中心旋转 官方说明： For example, to make a 100x100px Bitmap rotate around its center, you would set regX and regY to 50.让一个100x100的矩形，围绕起中心点旋转，则需要将regX/regY设为50. 现在我们设置regX/regY，显示对象宽度/高度的一半（100 / 2 = 50）, 为了对比，我们新增一个同位置的矩形,（在useEffect底部添加)12345678910111213141516const createShape = () =&gt; &#123; const graphics = new Graphics() .beginFill(\"#0f0\") .drawRect(0, 0, 100, 100); const shape = new Shape(graphics); shape.x = 150; shape.y = 150; shape.regX = 50; shape.regY = 50; window.stage.addChild(shape); Tween.to(shape, 2, &#123; rotation: 360, repeat: -1, ease: Power0.easeNone &#125;); &#125;;createShape(); 效果如下： 淡蓝色的为该矩形原本的位置，设置regX/regY后，可知图形确实是绕中心旋转。只是该矩形位置发生了偏移，我们需要调整显示对象的位置，将其位置还原为初始状态并围绕中心旋转。123//将createShape中shape的位置往右下调整shape宽度的一半 shape.x += 50 shape.y += 50 效果如下： 设置任意旋转中心现在我们清楚了，regX/regY会改变显示对象的注册点位置，并使该对象位置发生偏移。那我们可以很简单的利用这一特性和显示对象的x,y属性联合使用达到我们的目的。举个例子：现在我们想让矩形绕其右上顶点旋利用regX/regY ，使其绕右顶点旋转利用x, y将偏移后的对象还原至初始位置代码如下：1234567// 第一步实现，将旋转中心移至右顶点shape.regX = 100shape.regY = 0// 第二步实现，设置x,y将显示对象移回初始位置shape.x += 100shape.y = 0 效果如下： 依靠上面拆分的办法，我们就可以将旋转中心设置为该显示对象上的任意一点啦。（大家会不会因此迷糊 如果旋转中心不在显示对象上该如何处理，下面也做一下说明）。 举个例子：现在我们希望矩形绕【画布的左顶点】旋转。 利用regX/regY将显示对象注册点调整为画布左顶点。 利用x,y将显示对象还原至初始位置 所以 其实和旋转中心在显示对象上是一致的。1234567// 第一步shape.regX = -150shape.regY = -150// 第二步shape.x -= 150 shape.y -= 150 效果如下：（速率调快了，方便看效果） 总结： regX/regY会改变其旋转中心，并伴随显示对象位置偏移（相对于原显示对象而言） 当显示对象存在缩放和旋转时，情况会不会不同呢？ 有缩放的情况 给显示对象设置缩放值1shape.scale = 0.5; 设置中心点：1234567// 第一步实现，设置显示对象注册点偏移至中心点处shape.regX = (width / 2) * scaleshape.regY = (height / 2) * scale // 第二步实现，设置x/y将显示对象偏移到原来的位置，shape.x += (width / 2) * scaleshape.y += (height / 2) * scale 很显然，位置计算并不正确。因为缩放不会影响注册点所在坐标系。调整regX/regY取值12shape.regX = width / 2shape.regY = height / 2 则得到绕中心点旋转结果，效果如下： 有旋转的情况 给显示对象本身设置旋转角度1234567shape.rotation = 30; //处理中心点设置shape.regX = width / 2shape.regY = height / 2shape.x += width / 2shape.y += height / 2 即：显示对象的旋转，不会影响旋转中心的设置 总结： regX/regY、x/y配合使用可以设置任意中心点。另外通过旋转和缩放两种情况中心点的设置和效果可知：缩放在中心点设置之前就已生效所以缩放是以其左顶点进行缩放，而旋转是在设置完中心点之后生效，所以其是绕其中心点进行旋转的。额外需要注意的是，当设完中心点，对象经过旋转动效后，如需要将中心点重置为左顶点时。此时注册点的偏移量重置为0。但x, y的位置需要通过旋转公式求出旋转后左顶点的坐标，而不是单纯的还原位置。","pubDate":"Thu, 05 Nov 2020 07:40:20 GMT","guid":"https://aotu.io/notes/2020/11/05/easeJs-center-setting/","category":"经验分享"},{"title":"node.js 沙盒逃逸分析","link":"https://aotu.io/notes/2020/10/28/node-sandbox-escape-analysis/","description":"背景日常开发需求中有时候为了追求灵活性或降低开发难度，会在业务代码里直接使用 eval/Function/vm 等功能，其中 eval/Function 算是动态执行 JS，但无法屏蔽当前执行环境的上下文，但 node.js 里提供了 vm 模块，相当于一个虚拟机，可以让你在执行代码时候隔离当前的执行环境，避免被恶意代码攻击。 vm 基本介绍vm 模块可在 V8 虚拟机上下文中编译和运行代码，虚拟机上下文可自行配置，利用该特性做到沙盒的效果。例如： 12345678910111213const vm = require(\"vm\");const x = 1;const y = 2;const context = &#123; x: 2, console &#125;;vm.createContext(context); // 上下文隔离化对象。const code = \"console.log(x); console.log(y)\";vm.runInContext(code, context);// 输出 2// Uncaught ReferenceError: y is not defin 根据以上示例，可以看出和 eval/Function 最大的区别就是可自定义上下文，也就可以控制被执行代码的访问资源。例如以上示例，除了语言的语法、内置对象等，无法访问到超出上下文外的任何信息，所以示例中出现了错误提示: y 未定义。以下是 vm 的的执行示例图： 沙盒环境代码只能读取 VM 上下文 数据。 沙盒逃逸node.js 在 vm 的文档页上有如下描述： vm 模块不是安全的机制。 不要使用它来运行不受信任的代码。 刚开始看到这句话的很好奇，为什么会这样？按照刚才的理解他应该是安全的？搜索后我们找到一段逃逸示例： 123456789const vm = require(\"vm\");const ctx = &#123;&#125;;vm.runInNewContext( 'this.constructor.constructor(\"return process\")().exit()', ctx);console.log(\"Never gets executed.\"); 以上示例中 this 指向 ctx 并通过原型链的方式拿到沙盒外的 Funtion，完成逃逸，并执行逃逸后的 JS 代码。 以上示例大致拆分： 12345tmp = ctx.constructor; // Objectexec = tmp.constructor; // Functionexec(\"return Process\"); 以上是通过原型链方式完成逃逸，如果将上下文对象的原型链设置为 null 呢？ 1const ctx = Object.create(null); 这时沙盒在通过 ctx.constructor，就会出错，也就无法完成沙盒逃逸，完整示例如下： 123456789const vm = require(\"vm\");const ctx = Object.create(null);vm.runInNewContext( 'this.constructor.constructor(\"return process\")().exit()', ctx);// throw Error 但，真的这样简单吗？ 再来看看以下成功逃逸示例： 1234567891011const vm = require(\"vm\");const ctx = Object.create(null);ctx.data = &#123;&#125;;vm.runInNewContext( 'this.data.constructor.constructor(\"return process\")().exit()', ctx);// 逃逸成功！console.log(\"Never gets executed.\"); 为什么会这样？ 原因 由于 JS 里所有对象的原型链都会指向 Object.prototype，且 Object.prototype 和 Function 之间是相互指向的，所有对象通过原型链都能拿到 Function，最终完成沙盒逃逸并执行代码。 逃逸后代码可以执行如下代码拿到 require，从而并加载其他模块功能，示例： 1234567891011121314const vm = require(\"vm\");const ctx = &#123; console,&#125;;vm.runInNewContext( ` var exec = this.constructor.constructor; var require = exec('return process.mainModule.constructor._load')(); console.log(require('fs'));`, ctx); 沙盒执行上下文是隔离的，但可通过原型链的方式获取到沙盒外的 Function，从而完成逃逸，拿到全局数据，示例图如下： 总结由于语言的特性，在沙盒环境下通过原型链的方式能获取全局的 Function，并通过它来执行代码。 最终确实如官方所说，在使用 vm 的时应确保所运行的代码是可信任的。 eval/Function/vm 等可动态执行代码的功能在 JavaScript 里一定是用来执行可信任代码。 以下可能是比较常见会用到动态执行脚本的场景：模板引擎，H5 游戏、追求高度灵活配置的场景。 解决方案 事前处理，如：代码安全扫描、语法限制 使用 vm2 模块，它的本质就是通过代理的方式来进行安全校验，虽然也可能还存在未出现的逃逸方式，所以在使用时也谨慎对待。 自己实现解释器，并在解释器层接管所有对象创建及属性访问。","pubDate":"Wed, 28 Oct 2020 07:40:20 GMT","guid":"https://aotu.io/notes/2020/10/28/node-sandbox-escape-analysis/","category":"node.js"},{"title":"从浏览器渲染层面解析css3动效优化原理","link":"https://aotu.io/notes/2020/10/13/css3-optimization/","description":"引言在h5开发中，我们经常会需要实现一些动效来让页面视觉效果更好，谈及动效便不可避免地会想到动效性能优化这个话题: 减少页面DOM操作，可以元素使用CSS实现的动效不多出一行js代码 使用绝对定位脱离让DOM脱离文档流，减少页面的重排(relayout) 使用CSS3 3D属性开启硬件加速 那么，CSS3与动效优化有什么关系呢，本文将从浏览器渲染层面讲述CSS3的动效优化原理 浏览器页面展示过程首页，我们需要了解一下浏览器的页面展示过程: Javascript：主要负责业务交互逻辑。 Style: 根据 CSS 选择器，对每个 DOM 元素匹配对应的 CSS 样式。 Layout: 具体计算 DOM 元素显示在屏幕上的大小及位置。 Paint: 实现一个 DOM 元素的可视效果(颜色、边框、阴影等)，一般来说由多个渲染层完成。 Composite: 当每个层绘制完成后，浏览器会将所有层按照合理顺序合并为一个图层，显示到屏幕。本文我们将重点关注 Composite 过程。 浏览器渲染原理在讨论 Composite 之前，我们还需要了解一下浏览器渲染原理 从该图中，我们可以发现： DOM 元素与 Layout Object 存在一一对应的关系 一般来说，拥有相同坐标空间的 Layout Object 属于同一个 Paint Layer (渲染层)，通过 position、opacity、filter等 CSS 属性可以创建新的 Paint Layer 某些特殊的 Paint Layer 会被认为是 Composite Layer (合成层/复合层)，Composite Layer 拥有单独的 Graphics Layer (图形层)，而那些非 Composite Layer 的 Paint Layer，会与拥有 Graphics Layer 的父层共用一个 Graphics Layer我们日常生活中所看到屏幕可视效果可以理解为：由多个位图通过 GPU 合成渲染到屏幕上，而位图的最小单位是像素。如下图： 那么位图是怎么获得的呢，Graphics Layer 便起到了关键作用,每个 Graphics Layer 都有一个 Graphics Context, 位图是存储在共享内存中，Graphics Context 会负责将位图作为纹理上传到GPU中，再由GPU进行合成渲染。如下图： CSS在浏览器渲染层面承担了怎样的角色大多数人对于CSS3的第一印象，就是可以通过3D(如transform)属性来开启硬件加速，许多同学在重构某一个项目时，考虑到动画性能问题，都会倾向: 将2Dtransform改为3Dtransform2.将 left ( top、bottom、right )的移动改为 3Dtransform但开启硬件加速的底层原理其实就在于将 Paint Layer 提升到了 Composite Layer以下的几种方式都用相同的作用： 3D属性开启硬件加速(3d-transform) will-change: (opacity、transform、top、left、bottom、right) 使用fixed或sticky定位 对opacity、transform、filter应用了 animation(actived) or transition(actived)，注意这里的 animation 及 transition 需要是处于激活状态才行 我们来写两段 demo 代码，带大家具体分析一下实际情况 demo1. 3D属性开启硬件加速(3d-transform) 1234567891011.composited&#123; width: 200px; height: 200px; background: red; transform: translateZ(0)&#125;&lt;/style&gt;&lt;div class=\"composited\"&gt; composited - 3dtransform&lt;/div&gt; 可以看到是因为使用的CSS 3D transform，创建了一个复合层 demo2. 对opacity、transform、filter应用 animation(actived) or transition(actived) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;style&gt;@keyframes move&#123; 0%&#123; top: 0; &#125; 50%&#123; top: 600px; &#125; 100%&#123; top: 0; &#125;&#125;@keyframes opacity&#123; 0%&#123; opacity: 0; &#125; 50%&#123; opacity: 1; &#125; 100%&#123; opacity: 0; &#125;&#125;#composited&#123; width: 200px; height: 200px; background: red; position: absolute; left: 0; top: 0; &#125;.both&#123; animation: move 2s infinite, opacity 2s infinite;&#125;.move&#123; animation: move 2s infinite;&#125;&lt;/style&gt;&lt;div id=\"composited\" class=\"both\"&gt; composited - animation&lt;/div&gt;&lt;script&gt;setTimeout(function()&#123; const dom = document.getElementById('composited') dom.className = 'move'&#125;,5000)&lt;/script&gt; 这里我们定义了两个keyframes(move、opacity)，还有两个class(both、move)，起初 #composited 的 className = &#39;both&#39;，5秒延时器后，className = &#39;move&#39;，我们来看看浏览器的实际变化。 起初：#composited 创建了一个复合层，并且运动时 fps 没有波动，性能很稳定 5秒后：复合层消失，运动时 fps 会发生抖动，性能开始变得不再稳定 如何查看复合层及fps在浏览器的 Dev Tools 中选择 More tools，并勾选 Rendering 中的 FPS meter 动画性能最优化之前，我们提到了页面呈现出来所经历的渲染流水线，其实从性能方面考虑，最理想的渲染流水线是没有布局和绘制环节的，为了实现上述效果，就需要只使用那些仅触发 Composite 的属性。目前，只有两个属性是满足这个条件的：transforms 和 opacity（仅部分浏览器支持）。相关信息可查看：css Triggers 总结提升为合成层简单说来有以下几点好处： 合成层的位图，会交由 GPU 合成，比 CPU 处理要快 当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层 对于 transform 和 opacity 效果，部分浏览器不会触发 Layout 和 Paint， 相关信息可查看：css Triggers 缺点： 创建一个新的合成层并不是免费的，它得消耗额外的内存和管理资源。 纹理上传后会交由 GPU 处理，因此我们还需要考虑 CPU 和 GPU 之间的带宽问题、以及有多大内存供 GPU 处理这些纹理的问题 大多数人都很喜欢使用3D属性 translateZ(0) 来进行所谓的硬件加速，以提升性能。但我们还需要切实的去分析页面的实际性能表现，不断的改进测试，这样才是正确的性能优化途径。 参考资料无线性能优化：Composite - 淘系前端团队","pubDate":"Tue, 13 Oct 2020 13:00:00 GMT","guid":"https://aotu.io/notes/2020/10/13/css3-optimization/","category":"经验分享"},{"title":"Flutter 性能优化：tree shaking 和延迟加载","link":"https://aotu.io/notes/2020/10/13/optimizing-performance-in-flutter-web-apps-with-tree-shaking-and-deferred-loading/","description":"本文是 Flutter 性能优化系列文章之一，记录了 Flutter 团队优化 Flutter Gallery（https://gallery.flutter.dev/#/） 的实践。本文主要介绍了 tree shaking 和延迟加载在性能优化中的使用。原文链接：https://medium.com/flutter/optimizing-performance-in-flutter-web-apps-with-tree-shaking-and-deferred-loading-535fbe3cd67 在优秀的用户体验中，app 的加载速度扮演着重要角色。Flutter web app 的初次加载时间可以通过最小化 JS 包体积来提高。Dart 编译器自带 tree shaking 和延迟加载特性，这两者都可以最大程度地减少 JS 包体积。这篇文章介绍了这两个特性的工作原理，以及如何应用。 默认开启的 tree shaking 特性编译 Flutter web app 时，JS 包是通过 dart2js 编译器生成的。一次 release 构建将会得到最高级别的优化，其中就包括了 tree shaking。 Tree shaking 是一个通过只将一定会被执行到的代码包含进来，从而剔除无用代码的过程。所以说，你不用担心你的 app 引用的各种库，因为没有用到的 class 或者 function 会被排除掉。 来看一下 tree shaking 的实际效果： 创建一个 Dart 文件 greeter.dart : 123456789101112131415abstract class Greeter &#123; String greet(String name);&#125;class EnglishGreeter implements Greeter &#123; String greet(String name) =&gt; 'Hello $name';&#125;class SwedishGreeter implements Greeter &#123; String greet(String name) =&gt; 'Hej $name';&#125;void main() &#123; print(EnglishGreeter().greet('World'));&#125; 执行 dart2js -04 greeter.dart 命令，然后看一下生成的文件 out.js。 在生成的 JS 代码中，没有 SwedishGreeter 类，也找不到 Hej $name，因为它们在 tree shaking 过程中被编译器移除了。 如果只通过静态分析，编译器只能找出哪些代码是会被执行，哪些不会被执行的。举个例子，假如 greeter 的定义依赖系统地区设置： 123456Locale locale = Localizations.localeOf(context);if (locale.languageCode == 'sv') &#123; greeter = SwedishGreeter();&#125; else &#123; greeter = EnglishGreeter();&#125; 编译器不知道用户的系统地区设置，因此 EnglishGreeter 和 SwedishGreeter 都会被打包进去。对于这种情况，延迟加载可以帮助减少初始化的包体积。 延迟加载延迟加载，也叫懒加载，允许你在需要时再加载各种库。它可以用来加载 app 中很少用到的功能。请注意延迟加载是一个 dart2js 特性，所以这个特性对移动端 Flutter app 不可用。在以下这个最简单的例子中，将包或者文件引入为 deferred，然后在使用时先等待加载： 123456import 'greeter.dart' deferred as greeter;void main() async &#123; await greeter.loadLibrary(); runApp(App(title: greeter.EnglishGreeter().greet('World')));&#125; 在 Flutter 中，一切都是 widget，所以你可能会需要用到 FutureBuilder。因为一个 widget 的构建方法应该是同步的，因此你不能在一个构建方法中去 await loadLibrary 方法。但是，你可以在构建方法中返回一个 FutureBuilder，你也可以在等待加载库时使用它来显示不同的 UI： 123456789101112import 'greeter.dart' deferred as greeter;FutureBuilder( future: greeter.loadLibrary(), builder: (context, snapshot) &#123; if (snapshot.connectionState == ConnectionState.done) &#123; return Text(greeter.greet('World')); &#125; else &#123; return Text('Loading...'); &#125; &#125;,) 你可以尝试运行这个仓库中完整的例子，打开 Chrome 开发者工具，然后点击网络 tab 查看网络活动。刷新页面来观察库是什么时候引入和加载的。在下面的截图中，文件 main.dart.js_1.part.js 的加载是延迟的： Flutter Gallery 中的本地化延迟加载Flutter Gallery 支持超过 70 中语言，但是大多数用户只用到一种。延迟加载本地化字符串是这个特性非常棒的应用。比如，实现了延迟加载本地化字符串之后，app 的初始化 JS 包体积减少了一半。如果你的 Flutter web app 中有很多本地化字符串，可以考虑一下延迟加载这些文件。gen_l10n.dart 脚本 使用了 –use-deferred-loading 选项来实现这个需求（目前只在 1.19 SDK master channel 上可用）。 这篇文章是我们在提高 Flutter Gallery 性能中学习到的系列内容之一。希望对你有所帮助，能让你学到可以在你的 Flutter app 中用上的内容。系列文章如下： Flutter 性能优化系列之 tree shaking 和延迟加载（本文） Flutter 性能优化系列之图片占位符、预缓存和禁用导航过渡动画 Flutter 性能优化系列之打造高性能 widget","pubDate":"Tue, 13 Oct 2020 12:45:00 GMT","guid":"https://aotu.io/notes/2020/10/13/optimizing-performance-in-flutter-web-apps-with-tree-shaking-and-deferred-loading/","category":"Flutter"},{"title":"Flutter 性能优化：图片占位符、预缓存和禁用导航过渡动画","link":"https://aotu.io/notes/2020/10/13/improving-perceived-performance-with-image-placeholders-precaching-and-disabled-navigation/","description":"本文是 Flutter 性能优化系列文章之一，记录了 Flutter 团队优化 Flutter Gallery（https://gallery.flutter.dev/#/） 的实践。本文主要介绍了如何利用图片占位符、预缓存和禁用导航过渡动画提高用户感知性能。原文链接：https://medium.com/flutter/improving-perceived-performance-with-image-placeholders-precaching-and-disabled-navigation-6b3601087a2b 感知性能是指用户感觉 app 有多快（译者注：感性性能是用户视角，而不是指标）。这篇文章介绍了三个提高感知性能的策略：图片占位符、图片预缓存和禁用导航过渡动画。 利用图片占位符防止布局跳动用户等待图片加载，在图片最终显示出来时，布局可能会跳来跳去。通过在布局中使用图片占位符，你可以避免这种跳动，来确保更好的用户体验。 以下这个 GIF 图展示了没有图片占位符时布局的跳动： 在 DartPad 中查看完整例子 如果你的 app 中已经缓存了一个图片占位符，你可以使用 FadeInImage widget 来显示占位符。如果你想使用一个 widget 而不是图片作为占位符，你可以使用 Image.frameBuilder 属性。 Image.frameBuilder 属性负责构建一个图片 widget ，它有四个参数： context：构建上下文 child： widget 子元素 frame：一个代码该 frame 的数字，如果图片还在加载中的话，为 null wasSynchronousLoaded ：布尔值，图片加载完成后为 true 实现占位符 widget 时，首先要通过 wasSynchronousLoaded 检查图片是否已经加载完成，如果加载完成，返回 child 。如果没有，使用 AnimatedSwitcher widget 来创建一个占位符到显示图片的渐现动画： 123456789101112131415161718192021222324252627class ImageWidgetPlaceholder extends StatelessWidget &#123; const ImageWidgetPlaceholder(&#123; Key key, this.image, this.placeholder, &#125;) : super(key: key); final ImageProvider image; final Widget placeholder; @override Widget build(BuildContext context) &#123; return Image( image: image, frameBuilder: (context, child, frame, wasSynchronousLoaded) &#123; if (wasSynchronousLoaded) &#123; return child; &#125; else &#123; return AnimatedSwitcher( duration: const Duration(milliseconds: 500), child: frame != null ? child : placeholder, ); &#125; &#125;, ); &#125;&#125; 有了占位符，布局再也不会跳来跳去了，而且图片也有了渐现效果： 在 DartPad 中查看完整例子 预缓存图片如果你的 app 在显示图片界面之前有欢迎界面，你可以调用 precacheImage 方法来预缓存图片。 1precacheImage(NetworkImage(url), context); 来看一下效果： 在 DartPad 中查看完整例子 在 Flutter web app 中禁用导航过渡动画导航过渡动画一般在用户切换页面时使用，在移动 app 中，这种方式可以很好地让用户知道知道自己在哪里。但是，在 web 中，很少看到这样的交互。所以为了提高感知性能，你可以禁用页面间的过渡动画。 默认情况下， MaterialApp 会根据不同平台来使用不同的过渡动画（Android 向上滑动，而 iOS 是向右（左）滑动）。为了覆盖这个默认行为，你需要创建自定义的 PageTransitionsTheme 类。你可以使用 kIsWeb 常量来判断 app 是否在 web 中运行。如果是，通过返回 child 来禁用过渡动画： 123456789101112131415161718192021222324import 'package:flutter/foundation.dart';import 'package:flutter/material.dart';class NoTransitionsOnWeb extends PageTransitionsTheme &#123; @override Widget buildTransitions&lt;T&gt;( route, context, animation, secondaryAnimation, child, ) &#123; if (kIsWeb) &#123; return child; &#125; return super.buildTransitions( route, context, animation, secondaryAnimation, child, ); &#125;&#125; 设置 MaterialApp 的 pageTransitionsTheme 选项： 12345MaterialApp( theme: ThemeData( pageTransitionsTheme: NoTransitionsOnWeb(), ),) 没有任何过渡动画的页面切换效果如下： 在 DartPad 中查看完整的交互例子 结语希望你在本文中找到一些有用的技巧来提高 Flutter web app 的感知性能。在 Flutter Gallery 中，我们禁用了 web 端的导航过渡动画和使用了图片占位符来避免加载页面时布局的跳动，其中的实现和本文所描述的是类似，如果你想看代码，可以在 GitHub 上找到。 感谢阅读！ 这篇文章是我们在提高 Flutter Gallery 性能中学习到的系列内容之一。希望对你有所帮助，能让你学到可以在你的 Flutter app 中用上的内容。系列文章如下： Flutter 性能优化系列之 tree shaking 和延迟加载 Flutter 性能优化系列之图片占位符、预缓存和禁用导航过渡动画（本文） Flutter 性能优化系列之打造高性能 widget","pubDate":"Tue, 13 Oct 2020 12:45:00 GMT","guid":"https://aotu.io/notes/2020/10/13/improving-perceived-performance-with-image-placeholders-precaching-and-disabled-navigation/","category":"Flutter"},{"title":"你可能不知道的Animation动画技巧与细节","link":"https://aotu.io/notes/2020/10/13/animation-skill/","description":"引言在 web 应用中，前端同学在实现动画效果时往往常用的几种方案： css3 transition / animation - 实现过渡动画 setInterval / setTimeout - 通过设置一个间隔时间来不断的改变图像的位置 requestAnimationFrame - 通过一个回调函数来改变图像位置，由系统来决定这个回调函数的执行时机，比定时修改的性能更好，不存在失帧现象 在大多数需求中，css3 的 transition / animation 都能满足我们的需求，并且相对于 js 实现，可以大大提升我们的开发效率，降低开发成本。 本篇文章将着重对 animation 的使用做个总结，如果你的工作中动画需求较多，相信本篇文章能够让你有所收获： Animation 常用动画属性 Animation 实现不间断播报 Animation 实现回弹效果 Animation 实现直播点赞效果 ❤️ Animation 与 Svg 又会擦出怎样的火花呢？🔥 Loading 组件 进度条组件 Animation steps() 运用 ⏰ 实现打字效果 绘制帧动画 Animation 常用动画属性 介绍完 animation 常用属性，为了将这些属性更好地理解与运用，下面将手把手实现一些 DEMO 具体讲述 Animation 实现不间断播报 实现不间断播报 DEMO 通过修改内容在父元素中的 y 轴的位置来实现广播效果 12345678910111213141516@keyframes scroll &#123; 0%&#123; transform: translate(0, 0); &#125; 100%&#123; transform: translate(0, -$height); &#125;&#125;.ul &#123; animation-name: scroll; animation-duration: 5s; animation-timing-function: linear; animation-iteration-count: infinite; /* animation: scroll 5s linear infinite; 动画属性简写 */&#125; 此处为了保存广播滚动效果的连贯性，防止滚动到最后一帧时没有内容，需要多添加一条重复数据进行填充 12345678&lt;div class=\"ul\"&gt; &lt;div class=\"li\"&gt;小刘同学加入了凹凸实验室&lt;/div&gt; &lt;div class=\"li\"&gt;小邓同学加入了凹凸实验室&lt;/div&gt; &lt;div class=\"li\"&gt;小李同学加入了凹凸实验室&lt;/div&gt; &lt;div class=\"li\"&gt;小王同学加入了凹凸实验室&lt;/div&gt; &lt;!-- 插入用于填充的数据数据 --&gt; &lt;div class=\"li\"&gt;小刘同学加入了凹凸实验室&lt;/div&gt;&lt;/div&gt; Animation 实现回弹效果通过将过渡动画拆分为多个阶段，每个阶段的 top 属性停留在不同的位置来实现 实现回弹效果 DEMO 1234567891011121314151617181920212223/* 规定动画，改变top,opacity */@keyframes animate &#123; 0% &#123; top: -100%; opacity: 0; &#125; 25% &#123; top: 60; opacity: 1; &#125; 50% &#123; top: 48%; opacity: 1; &#125; 75% &#123; top: 52%; opacity: 1; &#125; 100%&#123; top: 50%; opacity: 1; &#125;&#125; 为了让过渡效果更自然，这里通过 cubic-bezier() 函数定义一个贝塞尔曲线来控制动画播放速度 过渡动画执行完后，为了将让元素应用动画最后一帧的属性值，我们需要使用 animation-fill-mode: forwards 12345678.popup &#123; animation-name: animate; animation-duration: 0.5s; animation-timing-function: cubic-bezier(0.21, 0.85, 1, 1); animation-iteration-count: 1; animation-fill-mode: forwards; /* animation: animate 0.5s cubic-bezier(0.21, 0.85, 1, 1) 1 forwards; 动画属性简写 */&#125; Animation 实现点赞效果 Online Code 实现点赞效果 DEMO 相信大多数同学都知道点赞效果，本文章会实现一个简易版的点赞效果，主要讲述一下实现思路： 为了让气泡可以向上偏移，我们需要先实现一个 y 轴方向上移动的 @keyframes 动画 123456789101112/* 规定动画，改变y轴偏移距离*/@keyframes animation-y &#123; 0%&#123; transform: translate(-50%, 100px) scale(0); &#125; 50%&#123; transform: translate(-50%, -100px) scale(1.5); &#125; 100%&#123; transform: translate(-50%, -300px) scale(1.5); &#125;&#125; 为了让气泡向上偏移时显得不太单调，我们可以再实现一个 x 轴方向上移动的 @keyframes 动画 123456789101112131415/* 规定动画，改变x轴偏移距离 */@keyframes animation-x &#123; 0%&#123; margin-left: 0px; &#125; 25%&#123; margin-left: 25px; &#125; 75%&#123; margin-left: -25px; &#125; 100%&#123; margin-left: 0px; &#125;&#125; 这里我理解： 虽然是修改 margin 来改变 x 轴偏移距离，但实际上与修改 transform没有太大的性能差异 因为通过 @keyframes animation-y 中的 transform 已经新建了一个渲染层 ( PaintLayers ) animation 属性 可以让该渲染层提升至 合成层(Compositing Layers) 拥有单独的图形层 ( GraphicsLayer )，即开启了硬件加速 ，不会影响其他渲染层的 paint、layout 对于合成层(Compositing Layers)相关知识不是很了解的同学，可以阅读一下这篇文章从浏览器渲染层面解析 css3 动效优化原理 如下图所示： 如笔者这里理解有误，还请读者大佬指出，感激不尽~ 给气泡应用上我们所实现的两个 @keyframes 动画 1234.bubble &#123; animation: animation-x 3s -2s linear infinite,animation-y 4s 0s linear 1;/* 给 bubble 开启了硬件加速 */&#125; 在点赞事件中，通过 js 操作动态添加/移除气泡元素 12345678function like() &#123; const likeDom = document.createElement('div'); likeDom.className = 'bubble'; // 添加样式 document.body.appendChild(likeDom); // 添加元素 setTimeout( () =&gt; &#123; document.body.removeChild(likeDom); // 移除元素 &#125;, 4000)&#125; Animation 与 Svg 绘制 loading/进度条 组件 🔥 Online Code Animation 与 Svg 绘制 loading/进度条 组件 🔥 DEMO 首先，我们使用 svg 绘制一个圆周长为2 * 25 * PI = 157 的圆 123&lt;svg with='200' height='200' viewBox=\"0 0 100 100\" &gt; &lt;circle cx=\"50\" cy=\"50\" r=\"25\" fill=\"transparent\" stroke-width=\"4\" stroke=\"#0079f5\" &gt;&lt;/circie&gt;&lt;/svg&gt; 将实线圆绘制成虚线圆，这里需要用 stoke-dasharray:50, 50 (可简写为50) 属性来绘制虚线, stoke-dasharray 参考资料 它的值是一个数列，数与数之间用逗号或者空白隔开，指定短划线(50px)和缺口(50px)的长度。 由于50(短划线) + 50(缺口) + 50(段划线) = 150, 150 &lt; 157，无法绘制出完整的圆，所以会导致右边存在缺口(7px) 123&lt;svg with='200' height='200' viewBox=\"0 0 100 100\" &gt; &lt;circle cx=\"50\" cy=\"50\" r=\"25\" fill=\"transparent\" stroke-width=\"4\" stroke-dasharray=\"50\" stroke=\"#0079f5\" &gt;&lt;/circie&gt;&lt;/svg&gt; stroke-dashoffset 属性可以使圆的短划线和缺口产生偏移，添加 @keyframes 动画后能够实现从无到有的效果，stoke-dashoffset 参考资料 设置 stroke-dasharray=&quot;157 157“,指定 短划线(157px) 和 缺口(157px) 的长度。 添加 @keyframes 动画 修改stroke-dashoffset值, 值为正数时逆时针偏移🔄,， 值为负数时，顺时针偏移🔃 1234567891011@keyframes loading &#123; 0%&#123; stroke-dashoffset: 0; &#125; 100%&#123; stroke-dashoffset: -157; /* 线条顺时针偏移 */ &#125;&#125;circle&#123; animation: loading 1s 0s ease-out infinite;&#125; 修改短划线和缺口值 为了让 loading 组件线条可见，我们需要一个50px的短划线,设置 stroke-dasharray=&quot;50&quot; 为了让短划线发生偏移后可以完全消失，缺口需要大于或等于圆周长157，设置 stroke-dasharray=&quot;50 157&quot; 添加 @keyframes 动画,为了让动画结束时仍处理动画开始位置，需要修改 stroke-dashoffset:-207(短划线+缺口长度) 进度条也是类似原理，帮助理解 stroke-dashoffset 属性，具体实现请查看示例 1234567891011@keyframes loading &#123; 0%&#123; stroke-dashoffset: 0; &#125; 100%&#123; stroke-dashoffset: -207; /* 保证动画结束时仍处理动画开始位置 */ &#125;&#125;circle&#123; animation: loading 1s 0s ease-out infinite;&#125; Animation steps()运用steps() 是 animation-timing-function 的属性值 1animation-timing-function : steps(number[, end | start]) steps 函数指定了一个阶跃函数，它接受两个参数 第一个参数接受一个整数值，表示两个关键帧之间分几步完成 第二个参数有两个值 start or end。默认值为 end step-start 等同于 step(1, start)。step-end 等同于 step(1, end) steps 适用于关键帧动画，第一个参数将两个关键帧细分为N帧，第二个参数决定从一帧到另一帧的中间间隔是用开始帧还是结束帧来进行填充。 看下图可以发现: steps(N, start)将动画分为N段，动画在每一段的起点发生阶跃(即图中的空心圆 → 实心圆),动画结束时停留在了第 N 帧 steps(N, end)将动画分为N段，动画在每一段的终点发生阶跃(即图中的空心圆 → 实心圆),动画结束时第 N 帧已经被跳过(即图中的空心圆 → 实心圆)，停留在了 N+1 帧。 实践出真知！Animation 实现打字效果 Animation 实现打字效果 DEMO 此处用英文字母(I’m an O2man.)举例，一共有13个字符。[经测试，多数中文字体每个字符宽高都相等] steps(13)可以将 @keyframes 动画分为13阶段运行,且每一阶段运行距离相等。 效果如下： 12345678910111213/* 改变容器宽度 */@keyframes animate-x &#123; 0%&#123; width: 0; &#125;&#125;p &#123; width: 125px; overflow: hidden; border-right: 1px solid transparent; animation: animate-x 3s 0s steps(13) 1 forwards;&#125; 可以发现仅仅这样还不够，动画运行过程中出现了字符被截断的情况,为了保证每个阶段运行后能准确无误地显示当前所处阶段的字符，我们还需要保证每个字符的width与动画每一阶段运行的距离相等 设置Monaco字体属性，用以保证每个字符的 width 相同，具体像素受fontSize属性影响，示例中的字体宽度约为 9.6px，9.6px * 13(段数) = 124.8px (125px)，所以当我们设置容器宽度为 125px，即可的达成目的：每个字符的 width 与动画每一阶段运行的距离相等(约为 9.6px )。 1234567891011p &#123; /* 设置 Monaco 字体属性，字体大小为16px，用以保证每个字符的 width 相同，width 约为9.6p */ font-family: Monaco; /* 9.6px * 13 = 124.8px (125px) */ width: 125px ; font-size: 16px; overflow: hidden; border-right: 1px solid transparent; /* 同时应用动画 animate-x、cursor-x */ animation: animate-x 3s 0s steps(13) 1 forwards,cursor-x 0.4s 0s linear infinite;&#125; Animation 实现帧动画 ⏰ Animation 实现帧动画 ⏰ DEMO 这里我们拿到了一张47帧的雪碧图（css spirit）,设置背景图 1234567.main &#123; width: 260px; height: 200px; background: url(url) no-repeat; background-size: 100%; background-position: 0 0;&#125; 添加 @keyframes 修改 background-position，让背景图移动 1234567891011121314151617@keyframes animate &#123; 0% &#123; background-position: 0 0; &#125; 100% &#123; background-position: 0 100%; &#125;&#125;.main&#123; width: 260px; height: 200px; background: url(url) no-repeat; background-size: 100%; background-position: 0 0; animation: animate 2s 1s steps(47) infinite alternate;&#125; 同时, css 还提供了animation-play-state用于控制动画是否暂停 123input:checked+.main&#123; animation-play-state: paused;&#125; 文章篇幅较长，感谢大家的阅读，希望各位看客能够有所收获~ ~ ~ 参考资料Animation 常用动画属性CSS 参考手册steps() 参考资料SVG 学习之 stroke-dasharray 和 stroke-dashoffset 详解理解 CSS3 Animation 中的 steps()【译】css 动画里的 steps()用法详解CSS Will Change","pubDate":"Tue, 13 Oct 2020 12:00:00 GMT","guid":"https://aotu.io/notes/2020/10/13/animation-skill/","category":"经验分享"},{"title":"Flutter 性能优化：打造高性能 widget","link":"https://aotu.io/notes/2020/10/13/build-performant-flutter-widget/","description":"本文是 Flutter 性能优化系列文章之一，记录了 Flutter 团队优化 Flutter Gallery（https://gallery.flutter.dev/#/） 的实践。本文主要介绍了如何打造高性能的 widget。原文链接：https://medium.com/flutter/building-performant-flutter-widgets-3b2558aa08fa 所有无状态和有状态 widget 都会实现 build() 方法，这个方法决定了它们是如何渲染的。app 中的一屏就可能有成百上千个部件，这些部件可能只会构建一次，或者在有动画或者某种特定的交互情况下，也有可能构建多次。如果想构建快速的 widget，你一定要很谨慎地选择构建哪些 widget，以及在什么时候构建。 这篇文章主要讨论只构建必要的和只在必要时构建，然后会分享我们是如何使用这个办法来显著提高 Flutter Gallery 的性能。我们还会分享一些高级技巧用于诊断你的 web app 中类似的问题。 只在必要时构建一个重要的优化方法是，只在绝对必要时才构建 widget。 谨慎地调用 setState()调用 setState 方法会引起 build() 方法调用。如果调用太多次，会使性能变慢。 看一下下面的动画，显示在前面的黑色 widget 向下滑动，露出后面类似棋盘的面板，类似于 bottom sheet 的行为。前面黑色 widget 很简单，但是后面的 widget 很忙碌。 123456789101112Stack( children: [ Back(), PositionedTransition( rect: RelativeRectTween( begin: RelativeRect.fromLTRB(0, 0, 0, 0), end: RelativeRect.fromLTRB(0, MediaQuery.of(context).size.height, 0, 0), ).animate(_animationController), child: Front(), ) ], ), 你可能会像以下这样写父 widget，但在这个场景下，这样是错误的： 1234567891011121314// BAD CODE@overridevoid initState() &#123; super.initState(); _animationController = AnimationController( duration: Duration(seconds: 3), vsync: this, ); _animationController.addListener(() &#123; setState(() &#123; // Rebuild when animation ticks &#125;); &#125;);&#125; 这样性能并不好。为什么？因为动画在做不必要的工作。 以下是有问题的代码： 123456// BAD CODE_animationController.addListener(() &#123; setState(() &#123; // Rebuild when animation ticks. &#125;);&#125;); 这种类型的动画只在你需要让整个 widget 动起来时才推荐使用，但这并不是我们在这种布局中需要的。 在动画监听器中调用 setState() 会引起整个 Stack 重新构建，这是完全没必要的 PositionedTransition 部件已经一个 AnimatedWidget 了，所以它会在动画开始的时候自动重新构建 不需要在这里调用 setState() 即使后面的组件是很忙碌的，前面的组件动画也可以达到 60 FPS。更多有关合理地调用 setState 方法的内容，请看 Flutter 卡顿的动画：你不该这样 setState 只构建必要的部分除了只在必要的时候进行构建，你还需要只构建 UI 中变化的部分。接下来的章节主要关注如何创建一个高性能的 list。 优先使用 ListView.builder()首先，让我们简单地看看显示 list 的基础： 竖 list 使用 Column 如果 list 需要滚动，使用 ListView 如果 list 有很多 item，使用 ListView.builder，这个方法会在 item 滚动进入屏幕的时候才创建 item，而不是一次性创建所有的 item。这在 list 很复杂和 widget 嵌套很深的情况下，有明显的性能优势。 为了解释多 item 情况下 ListView.builder 相较于 ListView 的优势，我们来看几个例子。 在这个 DartPad 例子中运行以下 ListView。你可以看到 8 个 item 都创建好了。（点击左下角的 Console 按钮，然后点击Run按钮。右边的输出面板没有滚动条，但是你可以滚动内容，然后通过控制台看到什么被创建了以及什么时候进行构建） 123456789101112ListView( children: [ _ListItem(index: 0), _ListItem(index: 1), _ListItem(index: 2), _ListItem(index: 3), _ListItem(index: 4), _ListItem(index: 5), _ListItem(index: 6), _ListItem(index: 7), ],); 接下来，在这个 DartPad 例子中运行 ListView.builder。你可以看只有可见的 item 被创建了，当你滚动时，新的 item 才被创建。 123456ListView.builder( itemBuilder: (context, index) &#123; return _ListItem(index: index); &#125;, itemCount: 8,); 现在，运行这个例子。在这里例子中，ListView的孩子都是提前一次性创建好的。在这种场景下，使用 ListView 的效率更高。 1234567891011121314151617181920final listItems = [ _ListItem(index: 0), _ListItem(index: 1), _ListItem(index: 2), _ListItem(index: 3), _ListItem(index: 4), _ListItem(index: 5), _ListItem(index: 6), _ListItem(index: 7),];@overrideWidget build(BuildContext context) &#123; // 这种情况下 ListView.builder 并不会有性能上的好处 return ListView.builder( itemBuilder: (context, index) &#123; return listItems[index]; &#125;, itemCount: 8, );&#125; 更多有关延迟构建 list 的内容，请看 Slivers, Demystified。 怎样通过一行代码，提升超过两倍的性能Flutter Gallery 支持超过 100 个地区；这些地区，可能你也猜到了，是通过 ListView.builder() 来展示的。通过查看 widget 重新构建的次数，我们注意到这些 item 会在启动时进行不必要的构建。这个情况有点难发现，因为这些 item 藏在折叠了两层的菜单下：设置面板和地区列表。（后来我们发现，因为使用了 ScaleTransitioin ，设置面板在不可见状态下也会进行渲染，意味着它会不断地被构建）。 通过简单地将 ListView.builder 的 itemCount 在未展开状态下设置为 0，我们确保了 item 只会在展开的、可见的设置面板中才进行构建。这一行改动提高了在 web 环境下渲染时间将近两倍，其中的关键是定位过度的 widget 构建。 如何查看 widget 的构建次数虽然 Flutter 的构建是很高效的，但是也会出现过度构建导致性能问题的情况。有几种方法可以帮助定位过度的 widget 构建： 使用 Android Studio/IntelliJAndroid Studio 和 IntelliJ 开发者可以使用自带的工具来查看 widget 重新构建信息。 修改 Flutter 框架本身如果使用的不是以上的编辑器，或者希望可以知道 web 环境下 widget 的重新构建次数，你可以在 Flutter 框架中加入几行简单的代码。 先看一下输出效果： 1234RaisedButton 1RawMaterialButton 2ExpensiveWidget 538Header 5 先定位到文件：&lt;Flutter path&gt;/packages/flutter/lib/src/widgets/framework.dart ，然后加入以下代码。这些代码会在启动时统计 widget 的构建次数，并在一段时间（这里设置的是 10 秒）后输出结果。 123456789101112131415161718192021222324252627bool _outputScheduled = false;Map&lt;String, int&gt; _outputMap = &lt;String, int&gt;&#123;&#125;;void _output(Widget widget) &#123; final String typeName = widget.runtimeType.toString(); if (_outputMap.containsKey(typeName)) &#123; _outputMap[typeName] = _outputMap[typeName] + 1; &#125; else &#123; _outputMap[typeName] = 1; &#125; if (_outputScheduled) &#123; return; &#125; _outputScheduled = true; Timer(const Duration(seconds: 10), () &#123; _outputMap.forEach((String key, int value) &#123; switch (widget.runtimeType.toString()) &#123; // Filter out widgets whose build counts we don't care about case 'InkWell': case 'RawGestureDetector': case 'FocusScope': break; default: print('$key $value'); &#125; &#125;); &#125;);&#125; 然后，修改 StatelessElement 和 StatelessElement 的 build 方法来调用 _output(widget)。 12345678910111213141516class StatelessElement extends ComponentElement &#123; ...@override Widget build() &#123; final Widget w = widget.build(this); _output(w); return w; &#125;class StatefulElement extends ComponentElement &#123;...@override Widget build() &#123; final Widget w = _state.build(this); _output(w); return w; &#125; 你可以在这里查看修改后的 framework.dart 文件。 需要注意的是，几次重新构建不一定会引起问题，但是这个办法可以通过验证不可见的 widget 是否在构建来帮你 debug 性能问题。 web 专用 tips：你可以添加一个 resetOutput 函数（可以在浏览器的控制台中调用）来获取随时获取 widget 的构建次数。 import 'dart:js' as js; void resetOutput() { _outputScheduled = false; _outputMap = &lt;String, int&gt;{}; } void _output(Widget widget) { // Add this line js.context['resetOutput'] = resetOutput; ... 查看修改后的 framework.dart 文件。 结语高效的性能调优需要我们明白底层的工作原理。文章里的 tips 可以帮助你决定什么时候构建 widget 来使你的 app 在所有场景都保持高性能。 这篇文章是我们在提高 Flutter Gallery 性能中学习到的系列内容之一。希望对你有所帮助，能让你学到可以在你的 Flutter app 中用上的内容。系列文章如下： Flutter 性能优化系列之 tree shaking 和延迟加载 Flutter 性能优化系列之图片占位符、预缓存和禁用导航过渡动画 Flutter 性能优化系列之打造高性能 widget（本文） 你还可以查看适用所有水平开发者的 Flutter UI 性能文档。","pubDate":"Tue, 13 Oct 2020 12:00:00 GMT","guid":"https://aotu.io/notes/2020/10/13/build-performant-flutter-widget/","category":"Flutter"},{"title":"使用 Vue3 开发小程序","link":"https://aotu.io/notes/2020/09/28/taro-vue3/","description":"前言9 月 19 日凌晨，Vue3 在经过多个开发版本的迭代后，终于迎来了它的正式版本，”One Piece” 的代号也昭示了其开拓伟大航路的野心。 Vue3 的新特性主要有 Composition API、Teleport、Fragments 和 &lt;script setup /&gt; &amp; &lt;style vars /&gt; 等。我们是否也可以在小程序开发中使用这些特性呢？在 Taro 的文档里我们找到了关于 Vue3 的章节，事不宜迟，让我们开始尝试吧。 Vue3 部分新特性还没了解过 Vue3 的同学也别急，先了解下 Vue3 的新特性吧： 1.Composition APIVue2.X 基于 Option API（选项 API）构建组件，一般来说组件拥有 data、methods、computed 等选项。这是一种属性相互隔离的模式，好处是各属性内容分离开，对于新手来说比较友好；但对于大型项目来说，为了修改某个功能，可能需要在一个文件中来回翻页。Vue3 增加了 Composition API 方式（组合 API ），基于 reactivity（响应式）的思想进行组件构建，将逻辑封装到函数中，可以实现类似 ReactHooks 的逻辑组合和重用。对于大型项目，代码按照具体功能划分，而不是分散在不同的生命周期中，逻辑更加一目了然。 2.Teleport（传入）Teleport 功能，使得我们可以将全屏的组件（例如 Toast）移到 Vue APP 节点外，而不需要在 UI 界面上修改其他组件样式，方便实现全屏蒙层、浮层弹窗等效果。 3.Fragments（碎片）Vue2.x 版本中，&lt;template /&gt; 标签下不支持放置多个组件，这个限制在 Vue3 中不再存在。这点比较好理解，下述组件设计在 Vue3 中是没有问题的： 123456&lt;!-- Layout.vue --&gt;&lt;template&gt; &lt;header&gt;...&lt;/header&gt; &lt;main v-bind=\"$attrs\"&gt;...&lt;/main&gt; &lt;footer&gt;...&lt;/footer&gt;&lt;/template&gt; 4.实验性质的语法糖 &lt;script setup&gt;、&lt;style vars&gt;a.&lt;script setup&gt;:用于在 SFC 中使用 Composition API 的语法糖，改善在单个文件组件中使用 Composition API 时的体验。 b.&lt;style vars&gt;: SFC 中状态驱动的 CSS 变量，它提供了直接的 CSS 配置和封装，支持将组件状态驱动的 CSS 变量注入到“单个文件组件”样式中。 除了以上 4 点之外，Vue3 还提供了自定义渲染，详细可以参考文末的推荐阅读文章。 如何在 Taro 里使用 Vue3Vue3 带来的新特性可以让我们更加优雅和高效地进行开发，现在，来开启我们在 Taro 里使用 Vue3 的体验之旅吧。 Taro 已经默认安装 Taro3 ，所以正常安装即可： 123456# 使用 npm 安装 CLI$ npm install -g @tarojs/cli# OR 使用 yarn 安装 CLI$ yarn global add @tarojs/cli# OR 安装了 cnpm，使用 cnpm 安装 CLI$ cnpm install -g @tarojs/cli 安装完成之后，使用taro --version查看一下是否安装成功，如果输出版本号说明安装成功。安装成功后，初始化一个项目 1$ taro init 将出现如下图的一些选型 如上图： 请输入项目名称？输入项目名称vuedemo 请输入项目介绍？输入项目介绍a demo project 请选择框架？当然是Vue3啦 余下选项，如上面 3 个选项，根据自己的需要选择就好，不会有什么问题 一般情况下，依照提示选型好以后， Taro 会自动安装依赖。如果由于网络问题导致安装不成功，就需要手动在项目路径下进行安装。 123456# 使用 yarn 安装依赖$ yarn# OR 使用 cnpm 安装依赖$ cnpm install# OR 使用 npm 安装依赖$ npm install 安装后目录结构： app默认代码如下，我们注意到，Taro3 在新建 Vue3 项目时已经修改了入口组件写法。 1234567import &#123; createApp &#125; from 'vue'import './app.scss'const App = createApp(&#123; onShow (options) &#123;&#125;, // 入口组件不需要实现 render 方法，即使实现了也会被 taro 所覆盖&#125;)export default App page/index目录下index文件示例如下： 1234567891011121314151617&lt;template&gt; &lt;view class=\"index\"&gt; &lt;text&gt;&#123;&#123; msg &#125;&#125;&lt;/text&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref &#125; from 'vue'import './index.scss'export default &#123; setup () &#123; const msg = ref('Hello world') return &#123; msg &#125; &#125;&#125;&lt;/script&gt; 编译运行微信小程序 1npm run dev:weapp 编译后，打开微信开发者工具导入编译后的dist目录，首页内容和编译成 H5 的表现都如下图： 验证 Taro3 对 Vue3 的支持度Composition API写个比较简单的 todolist 计数组件，假设目前已有 4 项代办事项，点击后将新增一项。这里会使用到 Composition API 思路，以及 computed 计算属性。 在用户点击时，第二行“当前操作新增”会根据点击次数递增，总计条数会在 4 的基础上累加。 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;button @tap=\"increment\"&gt; 增加 1 &lt;/button&gt; &lt;view&gt;当前todolist事项已有：&#123;&#123; existCount &#125;&#125;条；&lt;/view&gt; &lt;view&gt;当前操作已新增：&#123;&#123; count &#125;&#125; ，共有&#123;&#123; total &#125;&#125;条。&lt;/view&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref, computed, onMounted, toRefs, watch &#125; from 'vue'export default &#123; name: 'case1', setup(props) &#123; // ref响应式变量 const count = ref(0) const existCount = ref(4) // computed方法，在count的value发生改变时，会触发计算total const total = computed(() =&gt; count.value + existCount.value ) function increment() &#123; count.value++ &#125; onMounted(() =&gt; console.log('component mounted!')) return &#123; // 返回increment方法，existCount、count、total属性，供模板中调用 increment, existCount, count, total, &#125; &#125;&#125;&lt;/script&gt; 页面表现如下所示，可见对于 Composition API 的支持的还是不错的。 Teleport写个初次登录用户的欢迎弹窗。用户名从index.vue传入。首页代码如下： 123456&lt;template&gt; &lt;view class=\"index\"&gt; &lt;Toast :user = username /&gt; &lt;view id=\"teleportToast\"&gt;&lt;/view&gt; &lt;/view&gt;&lt;/template&gt; 在 Toast.vue 中，我们会写个属性 to 为 teleportToast 的 Teleport 组件，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;template&gt; &lt;button @tap=\"showToast\" class=\"btn\"&gt;打开弹窗&lt;/button&gt; &lt;!-- to和index.html中的view id一致 --&gt; &lt;teleport to=\"#teleportToast\"&gt; &lt;view v-if=\"toastFlag\" class=\"toast__wrap\" @tap=\"hideToast\"&gt; &lt;view class=\"h2\"&gt;弹窗标题：&lt;/view&gt; &lt;view class=\"toast__wrap--msg\"&gt;欢迎&#123;&#123; user &#125;&#125;，点击关闭&lt;/view&gt; &lt;/view&gt; &lt;/teleport&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref,toRefs &#125; from 'vue';export default &#123; props:&#123; user: &#123;type: String&#125; &#125;, setup(props) &#123; // 获取用户名 const &#123; user &#125; = toRefs(props) // Toast：显示flag const toastFlag = ref(false) let timer const showToast = ()=&gt;&#123; toastFlag.value = true &#125; const hideToast = ()=&gt;&#123; toastFlag.value = false &#125; return &#123; user, toastFlag, showToast, hideToast, &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=\"scss\"&gt;.toast__wrap&#123; position: fixed; width:100%; height: 100%; background: rgba(0,0,0,.8); top: 0; left: 0; z-index: 101; color: #fff; .h2&#123; margin: 20px; &#125; &amp;--msg&#123; text-align: center; &#125;&#125;&lt;/style&gt; 在 H5 下是正常显示的，弹窗展示以及关闭功能效果如下；在小程序上却报错了，Taro 团队还需要加把劲： FragmentsFragments 特性已经在上面的例子中得到验证，使用没有问题。 script setup 语法糖我们尝试一下&lt;script setup&gt;，组件里的代码如下： 12345678910111213141516171819202122&lt;template&gt; &lt;view&gt; &lt;view&gt;count:&#123;&#123; count &#125;&#125;,msg:&#123;&#123; info &#125;&#125;&lt;/view&gt; &lt;button @tap=\"incAndChangeInfo\"&gt; 增加 1修改msg &lt;/button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script setup=\" props \"&gt; import &#123; ref, toRefs &#125; from 'vue' export default&#123; props: &#123; msg: String, &#125;, &#125; export const count = ref(0) export const info = ref(props.msg) export const incAndChangeInfo = () =&gt; &#123; count.value++ info.value = \"change hello\" + count.value &#125;&lt;/script&gt; 上述script标签里的代码效果等同于下面： 123456789101112131415161718192021&lt;script&gt;import &#123; ref, toRefs &#125; from 'vue'export default &#123; props: &#123; msg: String, &#125;, setup(props) &#123; const count = ref(0) const info = ref(props.msg) const incAndChangeInfo = () =&gt; &#123; count.value++ info.value = \"change hello\" + count.value &#125; return &#123; count, info, incAndChangeInfo, &#125; &#125;&#125;&lt;/script&gt; 调用它的代码传入 mgs 如下： 1&lt;Setup msg=\"hello\"/&gt; 运行后，小程序和 H5 都是支持的，页面整体表现如下： 可以看到，运用新特性进行开发，代码书写更加便捷，逻辑更清晰。 style vars 语法糖&lt;style vars&gt;，组件里的代码如下： 123456789101112131415161718192021222324252627&lt;template&gt; &lt;view class=\"text\"&gt;文字颜色为&#123;&#123; color &#125;&#125;,点击后变为红色&lt;/view&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref,toRefs &#125; from 'vue'export default &#123; props:&#123; color: &#123;type: String&#125; &#125;, data(props) &#123; return &#123; color: ref(props) //'red' &#125; &#125;, setup(props)&#123; const &#123; color &#125; = toRefs(props) return &#123; color, &#125; &#125;&#125;&lt;/script&gt;&lt;style vars=\"&#123; color &#125;\"&gt;.text &#123; color: var(--color);&#125;&lt;/style&gt; 调用它的页面里的代码如下： 123456789101112131415161718192021222324&lt;template&gt; &lt;view class=\"index\"&gt; &lt;Styledemo :color = color @tap=\"changeColor\"/&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref, computed, onMounted, toRefs, watch &#125; from 'vue'import Styledemo from \"@/floors/styledemo\"export default &#123; components:&#123; Styledemo &#125;, setup () &#123; const color = ref('blue') const changeColor = ()=&gt;&#123; color.value = 'red' &#125; return &#123; changeColor, color &#125; &#125;&#125;&lt;/script&gt; 小程序和 H5 都没有问题，功能效果如下： 结语我们将上述几个 Demo 整合在一个项目中，放在Github上，有兴趣的同学可以看看。在线预览地址在这里。 经过验证，Taro3 支持使用最新的 Vue3 开发多端应用，相比之下 H5 的支持度更好一些。 值得一提的是，Taro 团队在技术上一直保持进取，在 Taro2.0 版本支持了 ReactHooks；根据Taro RFCS，早在2020-06-03也已经打算支持 Vue3 了。截至目前，Taro 对 Vue3 的支持在小程序端的稍有补足，希望 Taro 团队可以早日补足这个短板。 推荐文章： Vue3 和 React Hooks 对比 SWR 自定义渲染器的应用 参考文章： [1]compsition api [2]teleport [3]taro3安装及使用","pubDate":"Mon, 28 Sep 2020 01:00:00 GMT","guid":"https://aotu.io/notes/2020/09/28/taro-vue3/","category":"小程序"},{"title":"京喜小程序首页无障碍优化实践","link":"https://aotu.io/notes/2020/09/21/jx-weapp-accessible/","description":"前言本文参考 WCAG 2.1 、WAI-ARIA 和 Web 可访问性与无障碍最佳实践，在京喜小程序首页无障碍优化开发中，总结了一些“无障碍优化”在小程序端的实践，希望以此推动无障碍在小程序更多地落地。 无障碍无障碍是什么？在了解无障碍之前，我们先来了解一些数据： 据中国盲协的最新数据显示，中国目前视障者有 1700 多万，随着老龄化的严重，视障群体有进一步扩大的趋势。 在中国，有着庞大的信息障碍群体，包括：8500 多万残障人士，两亿多老年人，大量认知障碍人士。 … 无障碍无障碍 (Accessibility)，是指在发展过程中没有阻碍，活动能够顺利进行。从无障碍引申的相关词汇有，无障碍设施、信息无障碍、无障碍交流等等。 信息无障碍对于信息无障碍，中国互联网协会给出了一个定义：任何人（无论是健全人还是残疾人，无论是年轻人还是老年人）在任何情况下都能平等地、方便地、无障碍地获取信息、利用信息。 以上释义，源自百度百科 无障碍设施如果看不见、听不见，我们该怎么生活呢？ 在生活中，我们常常会看到一些设施：缘石坡道、盲道、无障碍垂直电梯、无障碍扶手、人行横道的警示信号等等。这些给障碍群体使用的安全设施，就是无障碍设施 (Accessibility Facilities)。无障碍设施主要是为了让障碍群体能够自主、安全、方便地通行和活动，它是障碍群体生活顺畅的重要保证。除物质环境的无障碍设施，无障碍设施还可以扩展到信息和交流的无障碍，比如互联网中的网站设计、网上办事、购物交互等。 信息无障碍的现状随着互联网不断发展，互联网应用已经融入到我们生活的各个方面，行动不便的障碍群体则更希望也更需要通过方便的互联网应用获取信息、学习和生活。因此，互联网应用进行无障碍优化，对障碍群体显得尤为重要。 早在 1997 年 2 月，万维网联盟 (W3C) 为了提升网络的无障碍性，成立了网络无障碍推动 (WAI)小组，并制定了一系列的关于网络无障碍的标准、规范、检测表、无障碍的技术，并与世界各地的组织携手合作，在全球范围推动无障碍网络运动。 但至今为止，互联网产品的无障碍优化进展仍然缓慢，很多网站建设和移动端 APP 的开发都还未考虑无障碍优化，即使是通过读屏软件，也很难获取想要的信息。 障碍群体调研 我们以电商平台购物 APP 为调研对象，同信息无障碍研究会合作做了一个调研。根据收集到的舆情反馈，我们了解到： 在消费降级的当下，低价商品火遍互联网的每个角落，障碍群体是其中需求度最大的人群之一。京喜，作为京东旗下的拼购电商平台，与拼多多和淘宝特价版一样，在障碍人士聚集的论坛和QQ中，有非常多的讨论。用户们对京喜没做无障碍表示遗憾，也期待京喜可以尽快开展无障碍优化，享受低价拼购的乐趣。 根据研究会信息无障碍工程师初步检测，目前影响障碍用户们使用缺陷集中在以下几类中： 按钮未加标签，用户难以了解对应按钮点按分别会触发哪些功能。 精简状态不提示或提示不符合障碍用户理解习惯，导致用户无法了解正确的信息，诸如是否已加入购物车等。 焦点逻辑混乱或没有遵循正确的读屏浏览模式，致使用户不能便捷、清晰地了解界面信息，严重影响操作效率。 活动信息或弹窗等页面，由于使用大量字绘架构且没有集成无障碍特性，用户无法便捷地参与平台营销活动。 以上几类属于障碍用户能够无障碍使用的基本支撑，部分或完全适配后将能促使 APP 实现较好的无障碍体验。 无障碍优化开发在了解小程序的无障碍优化之前，首先需要了解 Web 无障碍开发的基础知识，及读屏软件的工作方式。 读屏软件无障碍访问的关键点 —— 使用屏幕阅读器。 移动端 APP 访问无障碍特性，开启读屏模式的设置路径： iOS： 设置 -&gt; 通用 -&gt; 辅助功能 -&gt; 旁白（VoiceOver） 。 安卓：设置 -&gt; 辅助功能 -&gt; 无障碍 -&gt; TalkBack（不同机型路径可能不一样） 以下是一些主要的 VoiceOver 手势： 轻点：选择并朗读项目。 轻点两下：激活所选项目。 左右轻扫：选择下一项或上一项。 三个手指向上或向下轻扫：滑动屏幕上的列表或区。 双指搓擦：快速来回移动两个手指三次（形成“z”字形）以解除提醒，或者返回上一个屏幕。 更多手势可以查看 ：VoiceOver - iPhone 使用手册。 安卓的 TalkBack 手势与 VoiceOver 有一些差异，后面还会提到…… WAI-ARIA WAI-ARIA 通过浏览器把信息暴露给 accessibility APIs (无障碍API)，作为读屏软件的信息源。 WAI-ARIA ( Accessible Rich Internet Applications (WAI-ARIA) 1.1) 是一项技术，它可以通过浏览器和一些辅助技术来帮助我们进一步地识别以及实现语义化，这样一来能帮助我们解决问题，也让用户可以了解发生了什么。WAI-ARIA 是 W3C 编写的规范，定义了一组可用于其他元素的 HTML 特性，用于提供额外的语义化以及改善缺乏的可访问性。 以下是规范中三个主要的特性： 角色 —— 定义元素是干什么的。如 role=&#39;button&#39; 表示元素是按钮，读屏软件会读作“按钮”、role=&#39;searchbox&#39; 表示元素用于搜索，读屏软件会读作”搜索”。 属性 —— 让元素具备更多的意义。如 aria-required=&#39;true&#39; 表示元素在表单上是必填的、aria-label=&#39;描述文字&#39; 用来给当前元素标签加上描述，用不可视的方式给元素加 label，接受字符串作为参数，读屏软件会将描述文字朗读出来。 状态 —— 用于表达元素当前条件的特殊属性。如 aria-disabled=&#39;true&#39;表示表单禁止输入、aria-hidden=&#39;true&#39; 表示元素会被读屏软件忽略。 更多属性可以参考 Using Aria 中的 States and properties，部分属性可能在小程序设置不生效。 更多 role 可以参考 Using Aria 中的 Widget Roles，部分 role 可能在小程序设置不生效。 因此，无障碍优化便可以借助读屏软件，结合 WAI-ARIA 的特性进行开发。互联网应用引入无障碍特性，使得障碍用户可以清晰准确的获取到页面信息，获得更好的产品体验，方便地实现网上办事、购物等。 京喜小程序首页无障碍优化背景此前，京喜小程序未进行无障碍优化，障碍群体在读屏软件的辅助下，基本不能使用。这使得平台失去了障碍群体的市场，同时障碍群体也失去了体验京喜小程序平台服务的机会。因此，希望对平台进行无障碍优化，提升平台的可用性、易用性，让障碍群体享受更好的购物体验。 优化方案产品提供焦点划分规则、朗读规则、阅读顺序，为京喜小程序首页量身定制无障碍优化方案。内部方案，这里就不透露了。（想了解的话，来投一波简历啊~） 开发实现目前小程序官方已经支持无障碍访问特性，用户在读屏模式下可以体验无障碍访问。 开发细则DOM 顺序很重要 读屏软件在读屏时默认按照 DOM 的顺序朗读。如果 DOM 的顺序与内容的语义顺序不一致，会使得内容难以理解。例如首页中的商品瀑布流，按左右两列布局： 在开发过程中应尽量避免使用会影响到 DOM 视觉顺序的样式，如果无法避免，需要手动设置 tabIndex 属性，告知读屏软件正确的内容顺序。 非文本元素增加描述和角色属性 通过给非文本元素增加描述和角色属性，元素的内容就可以被读屏软件清晰准确地朗读。 图像可使用 alt 属性描述图像内容，读屏软件会根据 alt 中的内容朗读出 “描述图像内容 图像”。 view 本身是无语义的，可以给元素增加 aria-role 和 aria-label 属性。 读屏软件会朗读出 “label 描述内容 + role 类型”。 整块元素读取 一个元素可能由很多子元素组成。在无障碍模式下，读屏软件只能分别聚焦子元素，单独将每个子元素信息读出来。障碍用户在读屏软件的辅助下，获取到的都是元素零零碎碎的信息，这样的体验很不友好。 因此，在无障碍优化过程中，可以将元素当作按钮整块朗读，将子元素的信息整合作为描述，并尽量精简描述内容，缩短朗读文案的时间。 隐藏元素读取 如果不希望部分内容被读出来，可以使用 aria-hidden=’true’ 来声明，这样读屏时就会忽略这些元素。 1&lt;Text aria-hidden='true'&gt;读屏时会忽略这行文本&lt;/Text&gt; 在无障碍模式下，这个属性可用来隐藏辅助作用不大或是具有干扰性的内容。 场景实现非文本元素读取 首页头部中京喜 Logo 和文字是一整张图片。聚焦后，读屏软件默认会读成图像，无法将图片中的文字朗读出来。这样的无障碍体验是非常差的。 在这个场景下，可通过给 Logo 图片增加描述来进行无障碍优化。 1234&lt;View className='index__main'&gt; &lt;View className='index__logo' aria-role='text' aria-label='京喜' /&gt; &lt;View className='index__title'&gt;京东旗下社交电商平台&lt;/View&gt;&lt;/View&gt; 类似的还有关闭按钮、返回顶部按钮、菜单栏按钮…… 12345&lt;View className='back-top' aria-role='button' aria-label='返回顶部'/&gt; 搜索框读取 首页搜索框聚焦后，读屏软件默认会将搜索框中的暗纹读出来。但是障碍用户并不能明显的感知到搜索框元素。 在这个场景下，可以通过给搜索框增加角色属性来进行无障碍优化。 123&lt;View aria-role='searchbox'&gt; &lt;SearchBar /&gt;&lt;/View&gt; 轮播图读取 轮播图由多个子元素组成，但点击为整块点击，且每个子元素都是图片，读屏软件无法让用户清晰感知元素的含义。 在这样的场景下，可以给每一个子元素标签增加描述，读屏软件就可以识别到子元素了。 12345678&lt;View className='banner'&gt; &lt;Swiper&gt; &lt;SwiperItem aria-role='text' aria-label='活动推荐1'&gt;活动1&lt;/SwiperItem&gt; &lt;SwiperItem aria-role='text' aria-label='活动推荐2'&gt;活动2&lt;/SwiperItem&gt; &lt;SwiperItem aria-role='text' aria-label='活动推荐3'&gt;活动3&lt;/SwiperItem&gt; &lt;SwiperItem aria-role='text' aria-label='活动推荐4'&gt;活动4&lt;/SwiperItem&gt; &lt;/Swiper&gt;&lt;/View&gt; 但这样的无障碍优化在安卓手机上体验并不友好。 当障碍用户聚焦到轮播图后，读屏软件将子元素的描述朗读读来。轮播图继续轮播，焦点索引却不会随轮播状态自动更新，而是跟随当前子元素滑动消失在屏幕中。若要获取更新后的轮播信息，需要重新聚焦。 在这样的场景下，建议在轮播图的最外层增加描述，将整块内容当作按钮处理，让障碍用户清楚这是整体点击的按钮。 12345678&lt;View className='banner' aria-role='button' aria-label='活动推荐，共4个'&gt; &lt;Swiper&gt; &lt;SwiperItem&gt;活动1&lt;/SwiperItem&gt; &lt;SwiperItem&gt;活动2&lt;/SwiperItem&gt; &lt;SwiperItem&gt;活动3&lt;/SwiperItem&gt; &lt;SwiperItem&gt;活动4&lt;/SwiperItem&gt; &lt;/Swiper&gt;&lt;/View&gt; 商品卡片读取 商品卡片由多个子元素组成，读屏软件会将聚焦的子元素（商品图、名字、价格、利益点等）一个个的读出来。 但单独读出每个子元素，不便于障碍用户理解商品卡片的完整含义。 类似这样的场景，可以将商品卡片当作一个按钮整块处理。在商品卡片最外层标签加上 aria-role=&#39;button&#39;，还可以通过 aria-label 标签，将商品信息进行整合，精简描述，缩短商品名字的朗读时间，让障碍用户获得更好的体验。 隐藏元素读取 上文提到商品卡片的无障碍优化可通过 aria-role=&#39;button&#39; 和 aria-label 来实现。理想情况下，当障碍用户聚焦到商品卡片，读屏软件将整合的商品信息朗读出来，并提示是按钮类型。 但实际情况并非如此。当障碍用户在安卓手机上聚焦后，读屏软件不仅会将整合的商品信息和 role 朗读出来，还会将商品卡片子元素的文本内容朗读出来。（后文会提到 iOS 的表现） 为了避免商品信息重复朗读，可以在元素文本标签上加上 aria-hidden=&#39;true&#39; ，隐藏子元素文本描述，让障碍用户能够获取到清晰简洁的商品信息。 123456&lt;View aria-role='button' aria-label='商品整合信息'&gt; &lt;View aria-hidden='true'&gt; &lt;Image className='goods__img' src='https://img20.360buyimg.com/ling/jfs/t1/129045/25/12798/233574/5f61ffdbE248117d0/52fd1d1ee42b4443.png' lazyLoad /&gt; &lt;View className='goods__info'&gt;商品信息…&lt;/View&gt; &lt;/View&gt;&lt;/View&gt; iOS 和安卓端的差异滑屏手势差异 安卓：双指滑动，根据手势自适应滑动； iOS：三指滑动，一屏一屏分页滑动。 轮播图焦点差异 安卓：焦点位置会跟随子元素滑动消失； iOS：焦点位置固定不变，不会随子元素滑动而消失。 价格读取差异 由于整数部分和小数部分字体大小不同，价格文本是用多个标签实现的。 12345&lt;View&gt; &amp;yen; &lt;Text&gt;259&lt;/Text&gt; &lt;Text&gt;.2&lt;/Text&gt;&lt;/View&gt; 安卓：完整朗读 “259.2元”； iOS：单独朗读单位、整数、小数，并且会将 “￥” 读作“美元符号”。 aria-role=’button’ 读取差异 安卓：读作“描述+按钮+子元素文本描述”，需借助 aria-hidden=&#39;true&#39; 隐藏子元素文本描述，避免信息重复朗读。 iOS：有两种情况。 如果标签同时设置了 aria-label ，则读作“描述 按钮”，不重复朗读子元素文本。 如果标签仅设置了 aria-role=&#39;button&#39; ，会继续识别子元素文本，读作“描述+按钮+子元素文本描述”。为避免重复朗读，也需要给子元素加上 aria-hidden=&#39;true&#39;。 小程序无障碍展望小程序基础库自 2.7.1 起，支持部分 ARIA 标签，但是仍有部分属性和 role 在小程序中不生效，希望未来可以支持所有的 ARIA 标签，给障碍用户带来更好的体验。 另外，小程序目前还没有相关 API 支持识别用户手机是否开启无障碍（读屏）模式（原生 APP 可以通过相关 API识别）。如果能预知用户手机开启了无障碍模式，就可以通过动态控制前端模块展示，从而更好的隐藏无用信息、排除干扰信息（浮层弹窗、动画等）。在启无障碍模式下，设置数据埋点上报，还可以为障碍用户提供更好的体验。 希望微信小程序能尽快加强对无障碍优化开发的支持力度，让障碍群体能够享受信息化所带来的成果，享受便捷美好的生活。 无障碍体验手机开启读屏模式，扫码二维码体验： 结语京喜小程序首页无障碍优化上线后，我们对调研的障碍群体进行了回访，并且得到了不错的体验反馈。 这是我们在小程序无障碍优化上迈出的第一步，要获得更好的小程序无障碍访问体验还有很长一段路要走…… 希望此次小程序无障碍优化实践，能让障碍群体享受互联网应用所带来的便利，更好的享受生活。","pubDate":"Mon, 21 Sep 2020 09:08:08 GMT","guid":"https://aotu.io/notes/2020/09/21/jx-weapp-accessible/","category":"小程序"},{"title":"规范GIT代码提交信息&自动化版本管理","link":"https://aotu.io/notes/2020/09/10/git-commit-control/","description":"前言git作为一个开发人员必不可少的工具，代码提交也是日常一个非常频繁的操作，如果你或你的团队目前对提交信息还没有一个规范或约束，那么你有必要看看本文的内容了。 为什么要规范提交信息首先规范提交信息肯定是有必要的，简单总结下几点好处： 让项目的维护或使用人员能了解提交了哪些更改 清晰的历史记录，可能某天自己就需要查到呢 规范的提交记录可用于自动生成修改日志(CHANGELOG.MD) 基于提交类型，触发构建和部署流程 使用什么规范Conventional Commits(约定式提交规范)，是目前使用最广泛的提交信息规范，其主要受AngularJS规范的启发,下面是一个规范信息的结构：12345&lt;type&gt;[optional scope]: &lt;subject&gt;//空一行[optional body]//空一行[optional footer(s)] 规范说明type 提交的类别，必须是以下类型中的一个 12345678feat：增加一个新功能fix：修复bugdocs：只修改了文档style：做了不影响代码含义的修改，空格、格式化、缺少分号等等refactor：代码重构，既不是修复bug，也不是新功能的修改perf：改进性能的代码test：增加测试或更新已有的测试chore：构建或辅助工具或依赖库的更新 scope 可选，表示影响的范围、功能、模块 subject必填，简单说明，不超过50个字 body选填，用于填写更详细的描述 footer选填，用于填关联issus,或BREAK CHANGE BREAKING CHANGE 必须是大写，表示引入了破坏性 API 变更，通常是一个大版本的改动，BREAKING CHANGE: 之后必须提供描述，下面一个包含破坏性变更的提交示例123feat: allow provided config object to extend other configsBREAKING CHANGE: `extends` key in config file is now used for extending other config files 更详细的说明请看约定式提交规范 如何约束规范怎么确保每个提交都能符合规范呢，最好的方式就是通过工具来生成和校验，commitizen是一个nodejs命令行工具，通过交互的方式，生成符合规范的git commit，界面如下： 开始安装: 123456# 全局安装npm install -g commitizen # 或者本地安装$ npm install --save-dev commitizen# 安装适配器npm install cz-conventional-changelog packages.json在配置文件中指定使用哪种规范 123456... \"config\": &#123; \"commitizen\": &#123; \"path\": \"cz-conventional-changelog\" &#125; &#125; 安装完成后可以使用git cz 来代替git commit,然后根据提示一步步输入即可 格式校验commitlint可能你不想每次都通过交互界面来生成，还是想使用git commit -m &#39;message&#39;，那么为了确保信息的正确性，可以结合husky对提交的信息进行格式验证 安装依赖123npm install --save-dev @commitlint/&#123;config-conventional,cli&#125;# 安装huskynpm install --save-dev husky 添加 commitlint.config.js文件到项目123echo \"module.exports = &#123;extends: ['@commitlint/config-conventional']&#125;\" &gt; commitlint.config.js``` `package.json`配置 #git提交验证“husky”: { “hooks”: { “commit-msg”: “commitlint -E HUSKY_GIT_PARAMS” } },12OK到这一步就完成了，最后给你项目README.MD加上一个`commitizen-friendly`的标识吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)## 自动版本管理和生成CHANGELOG规范化的提交信息除了能很好描述项目的修改，还有一个很好的作用就是能根据提交记录来生成CHANGELOG.MD和自动生成版本号等功能。### standard-version一个用于生成`CHANGELOG.md`和进行`SemVer(语义化版本号)`发版的命令行工具主要功能：* 自动修改最新版本号，可以是`package.json`或者自定义一个文件* 读取最新版本号，创建一个最新的`git tag`* 根据提交信息，生成`CHANGELOG.md`* 创建一个新提交包括 `CHANGELOG.md`和`package.json`### 语义化版本控制(SemVer)先简单了解下什么是语义化的版本控制，其是由`GitHub`发起的一份用于规范版本号递增的规则，##### 版本格式主版本号.次版本号.修订号，版本号递增规则如下：* 主版本号(major)：当你做了不兼容的 API 修改，* 次版本号(minor)：当你做了向下兼容的功能性新增，可以理解为Feature版本，* 修订号(patch)：当你做了向下兼容的问题修正，可以理解为Bug fix版本。先行版本号可以加到“主版本号.次版本号.修订号”的后面，作为延伸。##### 先行版本当即将发布大版本改动前，但是又不能保证这个版本的功能 100% 正常，这个时候可以发布先行版本：* alpha: 内部版本* beta: 公测版本* rc: 候选版本(Release candiate)比如：1.0.0-alpha.0,1.0.0-alpha.1,1.0.0-rc.0,1.0.0-rc.1等。 `standard-version` 会根据提交的信息类型来自动更改对应的版本号,如下:* feat: 次版本(minor)+1* fix: 修订号(patch) +1* BREAK CHANGE: 主板号(marjor) +1&gt; `standard-verstion` 生成的`CHANGELOG`只会包含`feat`,`fix`,`BREACK-CHANGE`类型的提交记录#### 使用``` bashnpm i --save-dev standard-version 添加npm script 1234567&#123; scripts:&#123; \"release\": \"standard-version\", \"release:alpha\": \"standard-version --prerelease alpha\", \"release:rc\": \"standard-version --prerelease rc\" &#125;&#125; 执行：1234# npm run scriptnpm run release# or global binstandard-version 或者你想指定发行版本号： 1234#指定类型 patch/minor/marjornpm run release -- --release-as patch#指定版本号npm run release -- -- release-as 1.1.0 生命周期 prerelease:所有脚本执行之前 prebump/postbump: 修改版本号之前和之后 prechangelog/postchangelog:生成changelog和生成changelog之后 pretag/postag:生成tag标签和之后 standard-version本身只针对本地，并没有push才操作，我们可以在最后一步生成tag后，执行push操作，在paceage.json中添加12345\"standard-version\": &#123; \"scripts\": &#123; \"posttag\": \"git push --follow-tags origin master &amp;&amp; npm publish\" &#125; &#125; 还有更多配置功能自行查阅 官方文档 其它类似工具除了standard-version,还有其它类似的工具,有兴趣可以去了解下 semantic-release lerna 修改Git Commit为了使CHANGELOG.MD更能加直观看到每个版本的修改，我们尽量保证每次提交都是有意义的，但实际开发过程中，不可避免会提交了一些错误的commit message，下面介绍几个git命令来修改commit 1 修改最后一次提交git commit --amend 该命令会创建一个提交并覆盖上次提交，如果是因为写错或者不满意上次的提交信息，使用该命令就非常适合。 2 合并多条提交git reset --soft [commitID] 如果你想合并最近几条提交信息的话，那么就需要使用上面的命令来操作，指定要撤销的ccommitId,该命令会保留当前改动并撤销指定提交后的所有commit记录，如果不指定ID的话可以使用HEAD~{num} 来选择最近{num}条提交12git reset --soft HEAD~2 #合并最近两条提交git commit -m 'feat: add new feat' 带 --soft 参数的区别在于把改动内容添加到暂存区 相当于执行了git add . git rebase -igit rebase的功能会更加强大，如果我想修改最近3条提交记录，执行1git rebase -i HEAD~3 会出现如下编辑器界面(vim编辑器): 上面显示的是我最近3条提交信息 ，下面是命令说明，修改方式就是将commit信息前的pick改为你需要的命令，然后退出:wq保存 下面是常用的命令说明：123456p,pick = 使用提交r,reword = 使用提交，但修改提交说明e,edit = 使用提交，退出后使用git commit --amend 修改s,squash = 使用提交，合并前一个提交f,fixup = 和squash相同，但丢弃提交说明日志d,drop = 删除提交，丢弃提交记录 最后文本主要介绍了如何规范git commit和自动语义化版本管理，以及如何修改git commit,遵循一个规范其实没比之前随意填写信息增加多少工作量，但依赖规范却可以实现更多提升效率的事情。 参考 conventional commits standard version semver.org Semver(语义化版本号)扫盲","pubDate":"Thu, 10 Sep 2020 09:00:00 GMT","guid":"https://aotu.io/notes/2020/09/10/git-commit-control/","category":"经验分享"},{"title":"硬核看房利器——Web 全景的实现","link":"https://aotu.io/notes/2020/09/08/web-vr/","description":"疫情期间，打破社交距离限制的交互模式被推向前台，为不少行业的传统交易提供了想象的空间。 疫情时期，房地产租售业受到的冲击无疑是巨大的，由于人口流动的限制，需求量大幅减少，无法现场看房更加重了这一危机。但有危就有机，倒是意外推动了一项技术的推广——VR 看房。作为 WebVR 的子集，Web 全景是多数 WebVR 需求的降级选择，例如街景地图，本文将带大家实现一个简单的 Web 全景。","pubDate":"Tue, 08 Sep 2020 13:24:35 GMT","guid":"https://aotu.io/notes/2020/09/08/web-vr/","category":"技术预研"},{"title":"羚珑视频编辑器开发总结","link":"https://aotu.io/notes/2020/09/01/video-editor-summary/","description":"项目背景羚珑平台在静态类的设计中，已经取得了相应的成绩。在这个基础上结合当前大环境，我们认为可以去做一些动态类的设计，将动画和音效转化为可储存，可移植，可复用的数据。从而用户进行创作的时候，可以通过相对很简单的方式去使用这些高品质的动画和效果。 视频编辑器解决了什么问题？视频编辑器的主要作用是用户可以通过操作静态的PSD从而得到我们想要的动态设计效果。对比AE等复杂的视频编辑软件，学习成本大大降低，且动效的可复用性、移植性等也减轻了用户的工作量。 以下为设计效果： 开发实录如何让你的静态PSD”动”起来？参考 AE 的制作动画的过程，首先会预设剧本和分镜，其次规划好分镜中的镜头如何运动，角色如何运动，以及处理和规划素材。我们可以提炼出几个关键点：多场景、镜头移动（即场景整体的动效）、规划素材（图层内容出现时刻及时间长短灵活可控）视频编辑器操作主要涉及功能点如下： 多场景的切换与转场效果的融合，使视频效果更加生动灵活； 场景动效以及动效参数的设置，减少了同类型动效的开发（如位移动效合并为一个），也打开了设计师对动效使用的想象力，收获额外的视频效果； 图层操作，调整出现时刻及持续时间； 编辑器界面如下图： 状态管理视频编辑器的实现主要分为 5 个部分，视频预览区、动效添加区、参数编辑区、图层操作区、场景操作区，如下图其他部分的每一个操作都会映射到视频预览区，且各个部分数据共享。除此之外，编辑器的每一步操作都需要被”记住“，便于编辑的人回退、还原其操作。 经分析会涉及到以下场景，如： 预览区组件的状态需要共享 其他操作区的变动会改变预览区组件的状态 组件状态都需要可撤销/还原 我们可以采用 redux 集中管理状态以减少组件之间的数据流传递；对于撤销还原功能，我们可以采用 redux-undo，根据现有的 reducer 和配置对象，增强现有其撤消还原功能。12345678910111213141516171819202122232425262728import ReduxUndo from 'redux-undo'//定义原有的 reducerconst editReducer = (state = null, action) =&gt; &#123; switch (action.type) &#123; case VIDEO_INIT: &#123; const &#123; templates &#125; = action.payload return &#123; templates &#125; &#125; case VIDEO_TPL_CLEAR: &#123; return &#123;&#125; &#125;&#125;//通过 ReduxUndo 增强 reducer 的可撤销功能export const undoEditReducer = ReduxUndo(editReducer, &#123; initTypes: [VIDEO_TPL_CLEAR], filter: function filterActions (action, currentState, previousHistory) &#123; const &#123; isUndoIgnore = false &#125; = action return !isUndoIgnore &#125;, groupBy: groupByActionTypes([SOME_ACTION]), /* 自定义分组 groupBy:(action, currentState, previousHistory) =&gt; &#123; &#125;, */&#125;) 参数说明 initTypes：历史记录将根据初始化操作类型进行设置（重置) filter：过滤器, 可以帮助过滤掉不想在撤消/重做历史中包含的操作； groupBy：可以通过默认的 groupByActionTypes 方法将动作组合为单个撤消/重做步骤。也可以实现自定义分组行为，如果返回值不为 null，则新状态将按该返回值分组。如果下一个状态与上一个状态归为同一组，则这两个状态将在一个步骤中归为一组；如果返回值为 null，则 redux-undo 不会将下一个状态与前一个状态分组。 使用 store.dispatch() 和 Undo/Redo Actions 对你的状态执行撤消/重做操作1234567891011import &#123; ActionCreators &#125; from 'redux-undo'export const undo = () =&gt; (dispatch, getState) =&gt; &#123; dispatch(ActionCreators.undo())&#125;export const redo = () =&gt; (dispatch, getState) =&gt; &#123; dispatch(ActionCreators.redo())&#125;export const recovery = () =&gt; (dispatch, getState) =&gt; &#123; dispatch(ActionCreators.jumpToPast(0)) dispatch(ActionCreators.clearHistory())&#125; 总结 对于状态管理，首先我们可以从以下几点考虑是否需要引入redux、mobx等工具: 状态是否被多个组件或者跨页面共享； 组件状态需要跨越生命周期； 状态需要如持久化，可恢复/撤销等操作。在使用redux管理状态时，避免将所有状态抽离至redux store中，如 组件的私有状态； 组件状态传递层级较少； 当组件被unmount后可以销毁的数据等原则上是能放在组件内部就放在组件内部。其次为了状态的可读性和可操作性，在状态结构设计前，需要理清楚各个数据对象的关系，平衡数据获取及操作复杂度，推荐扁平化数据结构以减少嵌套和数据冗余。 图层交互在使用编辑器的过程中，图层的交互操作是最多最频繁的，我们参考了常用的客户端视频编辑软件 AE、Final Cut 的交互，尽可能在 Web 上提供用户操作的便利性及图层可视化，具体效果如下： 梳理图层操作需求，主要包含： 图层轨道需要伸缩 （ 调整图层持续时间 图层上的动效轨道可以单独伸缩（ 调整动效持续时间 图层轨道需要左右移动，且动效轨道跟随移动（调整出现的时刻 动效轨道可以单独左右移动 （调整动效出现的时刻 不同图层轨道可以上下调整顺序，动效轨道跟随图层轨道移动 （调整图层顺序 拖动时显示不同的外观 初始的时候首先考虑到需要移动图层顺序，我们基于 react-sortable-hoc 实现了基本的图层顺序拖曳移动 , 但是对于图层的拉伸、左右拖动处理需要自定义鼠标事件进行处理，并需要自定义计算控制图层的移动，而且最初没有考虑到拖动过程中拖动源的外观需要调整，最终，我们放弃这种实现。我们需要一个可定制化程度更高的拖曳组件，经过一番比较后，我们最终选定了 react-dnd 拖拽组件，查看其官方说明： 可帮助您构建复杂的拖放界面，同时保持组件的分离；且适用于拖动时在应用程序的不同部分之间传输数据，更完美的是组件可以响应拖放事件更改其外观和应用程序状态。 详细说明下，react-dnd 建立在 HTML5 拖放 API 之上,它可以对已拖动的 DOM 节点进行屏幕快照，并直接将其用作“拖动预览”, 简化了我们在光标移动时进行绘制的操作。不过，HTML5 拖放 API 也有一些缺点。它在触摸屏上不起作用，并且在 IE 上提供的自定义机会少于其他浏览器。这就是为什么在 react-dnd 中以可插入方式实现 HTML5 拖放支持的原因，你也可以不使用它，根据触摸事件，鼠标事件等自己来编写其他实现。 下面，我们从外到内，介绍基本的实现。 场景层面引入所需组件 12import &#123; DndProvider &#125; from 'react-dnd'import HTML5Backend from 'react-dnd-html5-backend' 将 DndProvider 放在整个场景的外层，设置 backend 为 HTML5Backend123456789&lt;DndProvider backend=&#123;HTML5Backend&#125;&gt; &lt;TemplateViewer // ----- 单个场景展示组件 template=&#123;tpl&#125; handleLayerSort=&#123;handleLayerSort&#125; onLayerDrop=&#123;onLayerDrop&#125; onLayerStretch=&#123;onLayerStretch&#125; /&gt; &lt;CustomDragLayer /&gt; // --- 自定义拖拽预览图层&lt;/DndProvider&gt; 里包含不同类型的图层组件。每个图层组件都提供一个纯渲染组件的方法 renderLayerContent，大致结构如下： 12345678export function renderLayerContent (layer) &#123; return &lt;div style=&#123;&#123;...&#125;&#125;&gt;...&lt;/div&gt;&#125;export default function XxxxLayerComponent (layer) &#123; ... return &lt;div&gt;&#123;renderLayerContent(layer)&#125;&lt;/div&gt;&#125; 里根据当前拖拽的对象的组件类型，调用相应 renderLayerContent 绘制拖拽可视内容，以实现拖拽前后的视图一致。 图层层面图层可以上下拖动，也可以左右拖动，意味它本身即是拖拽源，也是放置的目标。 为了区分拖拽的目的，我们定义了两个拖拽源12345678910111213141516const [&#123; isHorizontalDragging &#125;, horizontalDrag, preview] = useDrag(&#123; item: &#123; type: DragTypes.Horizontal, &#125;, collect: monitor =&gt; (&#123; isHorizontalDragging: monitor.isDragging(), &#125;),&#125;)const [&#123; isVerticalDragging &#125;, verticalDrag, verticalPreview] = useDrag(&#123; item: &#123; type: DragTypes.Vertical, &#125;, collect: monitor =&gt; (&#123; isVerticalDragging: monitor.isDragging(), &#125;),&#125;) 在放置处理中根据拖拽类型进行判断处理123456789const [, drop] = useDrop(&#123; accept: [DragTypes.Horizontal, DragTypes.Vertical], drop (item, monitor) &#123; // 处理左右拖动 &#125;, hover: throttle(item =&gt; &#123; // 处理上下排序 &#125;, 300),&#125;) 将定义好的拖动源和放置目标关联 DOM 。最外层 DIV 为图层可拖动区域即放置目标，然后依次为水平拖拽层，垂直拖拽层 1234567891011121314&lt;div ref=&#123;drop&#125;&gt; // --- 放置目标 DOM &lt;div ref=&#123;verticalPreview&#125;&gt; &lt;div ref=&#123;horizontalDrag&#125;&gt; // --- 水平拖拽 DOM &lt;div ref=&#123;verticalDrag&#125;&gt; // --- 垂直拖拽 DOM &lt;Icon type='drag'/&gt; &lt;/div&gt; /* 图层内容展示 */ &lt;div&gt;&#123;renderLayerContent(layer)&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 以上关于图层上下拖动、左右拖动的大体框架已经实现。 上下拖动排序时，为了拖动过程中不展示拖动源只保留生成的屏幕快照，可以根据当前的拖动状态将拖动源的透明度设置为 0 12345678&lt;div ref=&#123;drop&#125;&gt; // --- 放置目标 DOM &lt;div ref=&#123;verticalPreview&#125; style=&#123;&#123; opacity: isVerticalDragging ? 0 : 1 &#125;&#125; &gt; ... &lt;/div&gt;&lt;/div&gt; 水平拖动时，设置拖动源半透明，处理方式与上下拖动时同理。 图层内图层内有两个区域，下方区域可通过左右两端的操作点进行拉伸，上方区域可以在下方区域的宽度内左右移动以及同样通过左右两端的操作点进行拉伸。移动的实现方式前面已经介绍过就不重复了，针对拉伸的操作，我们封装一个 Stretch 类来统一处理12345678910111213141516171819202122232425function Stretch (&#123; children, left, width, onStretchEnd, onStretchMove,&#125;) &#123; function handleMouseDown (align) &#123; // 计算偏移 &#125; return ( &lt;div&gt; &#123;children&#125; &lt;div className=&#123;classnames(styles.stretch, styles.stretchHead)&#125; onMouseDown=&#123;handleMouseDown('head')&#125; /&gt; &lt;div className=&#123;classnames(styles.stretch, styles.stretchEnd)&#125; onMouseDown=&#123;handleMouseDown('end')&#125; /&gt; &lt;/div&gt; )&#125; 将需要支持拉伸的区域作为作为 Stretch 的 children 传递进来12345678&lt;div&gt; &lt;div&gt; &#123;motions.map((motion, i) =&gt; &lt;Stretch key=&#123;i&#125;&gt;&#123;/* 上方某个区域 */&#125;&lt;/Stretch&gt;)&#125; &lt;/div&gt; &lt;div&gt; &lt;Stretch&gt;&#123;/* 下方区域 */&#125;&lt;/Stretch&gt; &lt;/div&gt;&lt;/div&gt; 体验优化添加快捷键整个编辑器内容比较的多，对频繁的操作，我们可以保留常用快捷键的操作习惯。如空格播放、delete 删除等等，该功能我们可以使用 react-hot-keys 实现。 首先引入该快捷键库，然后指定绑定的快捷键，添加事件处理。123456789import Hotkeys from 'react-hot-keys'&lt;Hotkeys keyName='space' onKeyDown=&#123;(keyName, e) =&gt; &#123; e.preventDefault() play() &#125;&#125;/&gt; 文本转 SVG另外图层内容展示时有个小技巧，产品需求中文案图层平铺展示。可怜我最初竟然是通过文本长度以及轨道长度计算出文本展示次数，然后再放到 push 到节点中。经大佬改造后才明白可以将文本转化为 SVG 然后以背景图展示，真香！1234567891011&lt;div className=&#123;styles.contentText&#125; style=&#123;&#123; backgroundImage: `url(\"data:image/svg+xml;utf8, &lt;svg xmlns='http://www.w3.org/2000/svg' version='1.1' width='$&#123;size(layer.text) * 12 + 15&#125;px' height='35px'&gt; &lt;text x='10' y='22' fill='black' font-size='12'&gt; $&#123;layer.text&#125; &lt;/text&gt; &lt;/svg&gt;\")`, &#125;&#125;/&gt; 实现效果： 项目总结本文讲述了视频编辑器中操作区主要模块的处理。关于状态管理，我们主要需要明确引入管理工具的是否必要以及使用状态管理工具后是否所有状态都必须移入store中等等。另外对于复杂的图层拖拽功能，要像剥洋葱一样，先层层拆解，从而层层完善其结构。对项目而言，拿到需求后，我们从整体到局部进行分析，优先确定整体的框架、核心功能的实现方式等，进而考虑如何提高用户体验度。需求分清主次，以便于我们排列优先级从而开发提高效率。","pubDate":"Tue, 01 Sep 2020 06:36:00 GMT","guid":"https://aotu.io/notes/2020/09/01/video-editor-summary/","category":"Web开发"},{"title":"Taro 版本升级权威指南","link":"https://aotu.io/notes/2020/08/31/taro-versions/","description":"Taro 是一款由京东凹凸实验室推出的开放式跨端跨框架解决方案，致力于解决小程序、H5、React Native 的跨端同构问题，支持同时使用 React 和 Vue 来进行开发。本文由 Taro 团队成员隔壁老李撰写，旨在帮助 Taro 开发者厘清当前 Taro 多版本之间关系的那些事儿，同时解答有关 Taro 3、Taro RN 支持以及 Taro UI 的一些困惑。 自从 Taro 在今年 7 月份推出 3.0 版本，宣布同时支持 React 和 Vue 来开发跨端应用之后，Taro 的关注度得到了进一步地提升，很多开发者开始尝试升级自身项目到 3.0 来体验新的特性，同时，Taro 社区也开始迎来一些新朋友，业界有很多 Vue 开发者在做技术选型时开始将目光投向 Taro。 但由于 Taro 大版本之间差异较大，而社区内很多关于 Taro 的教程文章以及示例项目目前还停留 Taro 1/2 时代，导致很多开发者使用 Taro 3.0 尝试时出现奇怪的问题，所以 Taro 团队想通过本文帮助大家理解 Taro 各个版本之间的联系，协助大家更好地完成版本迁移，避免出现一些难以解决的奇怪问题。 区分 Taro 版本的火眼金睛Taro 目前有 3 个大版本，但如果按照架构来真正划分时代的话，Taro 1/2 属于第一代架构，而 Taro 3 则属于第二代架构，两代架构差异巨大，甚至可以完全认为是 2 个框架。当然，这只是对于框架内核而言，对于开发者，Taro 团队已经尽量在保证大版本之间的兼容性，着力降低版本迁移的难度。 Taro 1/2Taro 1/2 属于编译型架构，主要通过对类 React 代码进行语法编译转换地方式，得到各个端可以运行的代码，再配合非常轻量的运行时适配，以及根据标准组件库、API 进行差异抹平，从而实现多端适配的目的，整体架构如下。 而 Taro 1 与 Taro 2 的都是基于这种架构建立的方案，他们之间的区别主要是 Taro 1 在小程序端是自建构建体系，而 Taro 2 则是所有端都采用 Webpack 进行编译，可以降低 Taro 自身编译系统的复杂度，同时能够让开发者使用 Webpack 的生态来自定义编译过程和结果，可以认为 Taro 2 是 Taro 1 和 3 之间的一个过渡性版本。 Taro 3Taro 3 则可以大致理解为解释型架构（相对于 Taro 1/2 而言），主要通过在小程序端模拟实现 DOM、BOM API 来让前端框架直接运行在小程序环境中，从而达到小程序和 H5 统一的目的，而对于生命周期、组件库、API、路由等差异，我们依然可以通过定义统一标准，各端负责各自实现的方式来进行抹平。而正因为 Taro 3 的原理，所以我们可以在 Taro 3 中同时支持 React、Vue 等框架，甚至我们还支持了 jQuery，在不久的将来我们还能支持让开发自定义地去拓展其他框架的支持，比如 Angular，Taro 3 整体架构如下。 版本选择的取舍通过上述内容可以看出，Taro 两代架构之间差异巨大，从而也就导致了他们之间的特性也很不一样。Taro 1/2 和 Taro 3 之间特性的差异主要体现在开发体验与性能上。 从开发体验上看，Taro 3 明显是优于 Taro 1/2 的，受益于 Taro 3 架构的原理，我们可以在 Taro 3 中使用完整的 React、Vue 语法特性来进行开发，从而在开发体验上让多端开发无限接近于 Web 开发，这对深耕 Web 而初次接触小程序的开发者来说是非常友好的。而对 Taro 熟悉的朋友肯定知道 Taro 1/2 在开发时会有诸多限制，尤其是在 JSX 书写上，我们总会需要一些手段来绕过这些限制，这就导致开发体验小有不足。 从性能上看，某些情况下 Taro 1/2 会优于 Taro 3，如果你的应用非常复杂，页面节点非常多，有非常多的大规模更新操作，对性能要求比较苛刻的话，Taro 1/2 会是不错的选择，而 Taro 1 和 2 我们更推荐使用 Taro 2。当然，根据我们的测试，对于大部分应用来说 Taro 1/2 和 Taro 3 的性能差异并不明显，我们后续会给出 benchmark 来印证这一点，而且，对于 Taro 3 本身在性能存在劣势的场景，Taro 官方团队已经给出了相应的解决方案来应对。比如，提升首次渲染速度，我们可以使用预渲染；对于无限滚动加载的列表场景，我们提供了虚拟列表组件。 对于开发者来说，开发体验和性能往往是需要权衡来寻找平衡点的，缺一不可，所以现阶段，我们更加推荐使用 Taro 3 来开发多端应用。而且现阶段 Taro 团队的研发重心主要放在 Taro 3 上，新的特性会优先在 Taro 3 上进行尝试，所以，在未来 Taro 3 将更具有想象力，会有更多好玩的东西推出来。 平滑升级不完全指南Taro 2 和 Taro 3 都有对应的迁移指南，根据迁移指南往往能规避大部分的问题。 Taro 1 升级到 Taro 2 的迁移指南。 Taro 1/2 升级到 Taro 3 的迁移指南。 当然，迁移指南肯定无法覆盖到所有问题所有情况，我们在 Taro 交流群的日常交流中总是能观察到一些迁移的问题，所以在这里，我们将梳理一遍迁移指南，同时就一些常见的问题，再做一些说明补充，来解答开发者们的升级困惑。 Taro 1 升级到 Taro 2Taro 1 升 Taro 2 所需要做的工作并不多，根据迁移指南，主要是新增了一个 @tarojs/mini-runner 依赖，以及对编译配置的调整，而在这里容易出问题的往往是在编译配置调整中，所以我们总结了一下针对编译配置的调整内容。 plugins 配置调整，调整前是一个对象，调整后为一个数组，用来配置 Taro 插件，非常值得注意的是这个配置请与 babel 配置里的 plugins 区分开来，后者是用来配置 babel 插件的，这是一个非常常见的配置错误 babel、csso、uglify 等配置从旧的 plugins 配置中移出来了，调整为与 sourceRoot 和 outputRoot 等同级的配置项 weapp 配置项改名为 mini postcss 配置项下去掉 module 这一级配置，原 module 下的配置项直接置于 postcss 下 关于 async functions 的使用同时，从 Taro 2 开始，使用 async functions 不再需要安装 @tarojs/async-await 依赖了，而是通过安装 babel 插件 babel-plugin-transform-runtime 配合 babel-runtime 来实现支持，具体请查看文档异步编程指南。 而在 Taro 3 中则不再需要手动安装配置，Taro 的官方 babel 预设 babel-preset-taro 已经内置了相关配置。 Taro 1/2 升级到 Taro 3Taro 1/2 升级到 Taro 3 则相对来说要麻烦许多，但是迁移指南中其实介绍得已经非常详细了，我们在这里总结一下需要调整的内容。 文件调整文件调整主要如下： babel 配置，在项目目录下新增了 babel.config.js 配置文件来配置 babel，为此，请去掉编译配置（config/index.js）中的 babel 配置，请参见说明 项目/页面配置，新增项目/页面同名的配置文件 *.config.js（或者 *.config.ts）, * 代表页面/项目文件的文件名，config 文件必须和页面/项目文件在同一文件夹，请参见说明 编译配置调整主要参考上述 Taro 1 升级到 Taro 2 时的调整，新增 Taro 3 特有配置 framework 配置，取值为使用的框架（react, nerv, vue, vue3），请参见说明 项目依赖调整在 Taro 3 中有很多旧的项目依赖已经不再需要了，例如之前做平台运行时兼容的 @tarojs/taro-weapp、@tarojs/taro-alipay 等等，而同时也新增了一些新依赖项，例如 @tarojs/runtime 等，具体 Taro 3 会需要哪些依赖，可以通过创建 Taro 示例项目看到，在这里我们列出了 Taro 3 目前仍需使用的 NPM 包名及其具体作用。 NPM 包 描述 babel-preset-taro 给 Taro 项目使用的 babel preset @tarojs/taro 暴露给应用开发者的 Taro 核心 API @tarojs/shared Taro 内部使用的 utils @tarojs/api 暴露给 @tarojs/taro 的所有端的公有 API @tarojs/taro-h5 暴露给 @tarojs/taro 的 H5 端 API @tarojs/router Taro H5 路由 @tarojs/react 基于 react-reconciler 的小程序专用 React 渲染器 @tarojs/cli Taro 开发工具 @tarojs/extend Taro 扩展，包含 jQuery API 等 @tarojs/helper 内部给 CLI 和 runner 使用辅助方法集 @tarojs/service Taro 插件化内核 @tarojs/taro-loader 露给 @tarojs/mini-runner 和 @tarojs/webpack-runner 使用的 Webpack loader @tarojs/runner-utils 暴露给 @tarojs/mini-runner 和 @tarojs/webpack-runner 的公用工具函数 @tarojs/webpack-runner Taro H5 端 Webpack 打包编译工具 @tarojs/mini-runner Taro 小程序 端 Webpack 打包编译工具 @tarojs/components Taro 标准组件库，H5 版 @tarojs/taroize Taro 小程序反向编译器 @tarojs/with-weapp 反向转换的运行时适配器 eslint-config-taro Taro ESLint 规则 eslint-plugin-taro Taro ESLint 插件 代码调整代码调整主要如下： API 引入，前端框架（React/Nerv/Vue）自身的 API 直接从框架引入，与 Web 保持一致，只有 Taro 提供的相关 API，还是从 @tarojs/taro 引入，请参见说明 App 代码调整，对于 React/Nerv 项目，项目入口 App 的 render 函数固定修改为返回 this.props.children，如下 123456789import &#123; Component &#125; from 'react'import './app.scss'class App extends Component &#123; render() &#123; return this.props.children &#125;&#125;export default App 路由功能，使用 getCurrentInstance().router 替代 this.$router，getCurrentInstance 作为新 API 从 @tarojs/taro 引入，请参见说明 生命周期，主要是使用 React 后，带来的生命周期调整，请参见说明 使用第三方 React 库，对于 redux、mobx 等 React 生态库，可以直接像 Web 开发那样直接使用，请参见说明 Ref &amp; DOM，请参见说明 不再需要传入 $scope，在 Taro 1/2 时调用某些 API 需要传入 this.$scope，相当于传入组件对应的小程序原生对象，而 Taro 3 则不再需要，具体请参见说明 样式调整，组件直接受全局样式影响，不再需要设置 addGlobalClasses，请参见说明 当然，迁移指南内容并不仅仅局限于版本迁移，由于 Taro 3 相对与 Taro 1/2 有很多 breaking changes，所以建议使用 Taro 3 的开发者都能在开发前阅读一遍迁移指南。 不得不唠叨一下 Taro 3 的正确使用姿势正如前文所提到的，目前有很多开发者是从 Taro 3 才开始接触 Taro，而目前市面上很多 Taro 相关的教程和项目都是 Taro 1/2 的，这对于很多开发者来说会造成不小的困惑，所以行文到此，我们希望列举一些常见问题来帮助开发者规避掉一些不必要的错误。 Taro 多版本共存问题很多开发曾经使用 Taro 旧版本开发过项目，已经在全局安装了 Taro，但是想同时体验到 Taro 3，应该如何进行操作？ 我们提供了两种思路： 如果是需要新创建 Taro 3 项目，可以使用 nvm 来管理 node 版本，通过安装不同 node 版本来安装不同版本的 Taro CLI，从而解决 Taro 多版本共存的问题 如果是部分已有项目需要升级到 Taro 3，可以在这些项目本地安装相应版本的 Taro CLI，这样通过 yarn 或者 npm 执行命令的话就会直接使用本地安装的 Taro CLI，安装方式 yarn add @tarojs/cli 将 Taro CLI 版本与项目中 Taro 相关依赖的版本保持一致请时刻注意将 Taro CLI 版本与项目中 Taro 相关依赖的版本保持一致。 CLI 与项目依赖版本不一致是导致很多问题出现的源头之一。例如，Taro CLI 版本为 3.0.8，那么 Taro 相关依赖的版本也必须是 3.0.8，Taro 相关包名可以从这个列表得知，具体依赖项版本可以使用 taro info 命令或者通过 package.json 就能知晓。 如果发现不一致的情况可以使用 Taro 升级命令 taro update self [版本号] 和 taro update project [版本号]来分别将 CLI 和项目依赖升级到指定版本；或者也可以手动安装相应版本 CLI，修改 package.json 依赖版本号，然后重装依赖来解决。 使用路由在 Taro 3 中使用路由在前文的版本迁移部分已有提及，同时需要了解更多内容可以前往官方文档查看。 非常值得注意的是，无论是获取项目传入参数还是页面入参，都是通过 getCurrentInstance().router 来获取的，具体使用如下。 12345678import &#123; getCurrentInstance &#125; from '@tarojs/taro'import React, &#123; Component &#125; from 'react'export default class C extends Component &#123; componentDidMount () &#123; console.log(getCurrentInstance().router.params) &#125;&#125; 如何获取页面节点信息由于 Taro 3 设计机制的原因，需要在新增的 onReady 生命周期内才能调用 Taro API 正确获取页面节点信息，小程序和 H5 都是如此。 而同时，在微信小程序中当页面节点嵌套过深时，超过一定层级（默认 16 级，可以通过编译配置 baseLevel 来控制）时，Taro 将转而使用自定义组件，然后再开启新的循环，在这种情况要争取获取页面节点信息的话，需要使用 跨自定义组件的后代选择器 来进行选择，可以参见 Taro 相关 issue。 Taro UI 是不是不支持 Taro 3 了在 Taro 3 中依然可以使用 Taro UI，目前需要安装 Taro UI 的 alpha 版本。 1$ yarn add taro-ui@next Taro UI 作为 Taro 的官方 UI 库，依然处于维护状态，目前主要依靠社区力量在进行维护，同时也非常欢迎更多社区开发人员共同参与到 Taro UI 的迭代中来。 Taro UI 有没有 Vue 版本目前，Taro 官方没有推出 Vue 版本的 Taro UI 库，但在社区中有 Vue 版本的解决方案，如果使用 Vue 进行开发可以尝试 taro-ui-vue。 为什么 Taro 3 打包出来的应用体积巨大很多朋友会发现 Taro 3 的项目在预览的时候打包出来的包大小相比 Taro 1/2 要大上很多，然后非常紧张用了 Taro 3 会不会导致自己的主包超限。 诚然，在预览的时候 Taro 3 默认生成的包会比较大，主要是因为为了方便调试，预览时引用的 React 和 Vue 用的是调试用库，而且同时预览时会生成 sourceMap，这就导致预览时生成的包会大很多，但是在打包生产包（去掉 –watch）时，最终生成包还是会很小的，对线上不会有太大影响，同时 Taro 团队也正在尝试不断优化生产包大小，进一步优化 Taro 性能。 如果想要在预览时降低包大小，可以设置 NODE_ENV 为 production 来开启压缩，例如编译微信小程序 12345# Mac$ NODE_ENV=production taro build --type weapp --watch# Windows$ set NODE_ENV=production &amp;&amp; taro build --type weapp --watch 在 Taro 3 中使用小程序原生页面及组件在 Taro 3 中依然可以像 Taro 1/2 那样引入小程序原生页面及组件，且使用方式大体一致，不过在某些情况有些细微差别，比如 slot 的使用，在 Taro 1/2 中可以直接使用 slot 标签，而在 Taro 3 中则需要从 @tarojs/components 中引入 Slot 组件然后再进行使用。 1234567891011121314151617181920212223242526272829import Taro from '@tarojs/taro'import React, &#123; Component &#125; from 'react'import &#123; View, Text, Slot &#125; from '@tarojs/components'export default class Index extends Component &#123; state = &#123; show: false, date: '' &#125; render () &#123; const &#123; show, date &#125; = this.state return ( &lt;View className='index'&gt; &lt;van-button type='primary' onClick=&#123;this.showCalendar&#125;&gt;显示日历&lt;/van-button&gt; &lt;van-calendar show=&#123;show&#125; showConfirm type='range' onClose=&#123;this.closeCalendar&#125; onConfirm=&#123;this.onConfirm&#125; &gt; &lt;Slot name='title'&gt; &lt;View&gt;Hello world&lt;/View&gt; &lt;/Slot&gt; &lt;/van-calendar&gt; &lt;/View&gt; ) &#125;&#125; 具体使用情况可以参考项目 taro3-vant-sample。 有哪些 Taro 官方的示例项目目前 Taro 3 的社区示例项目还在完善中，Taro 官方则分别针对 React 和 Vue 提供了示例的组件库项目以供参考，安装最新版本的 Taro CLI，在创建项目时选择社区优质模板源创建即可进行体验。 同时，Taro 官方还提供了一个 TodoMVC 项目以供参考学习，React 和 Vue 示例分别在 react 和 vue 分支上。 Taro 物料市场中哪些物料能在 Taro 3 中使用目前 Taro 物料市场没有做好针对物料的版本区分，我们会尽快启动这一项工作，为每个物料打上版本标识，当下要识别哪些物料能在 Taro 3 中使用，只能通过物料本身的 Taro 依赖项来进行识别。 再聊聊 Taro 的近期动作Taro 社区及官方团队目前主要在集中人力做以下几项工作 实现支持平台与框架的自定义扩展细心的朋友应该已经发现，进入 Taro 3 时代，Taro 的推广 Slogan 已经由「多端统一开发解决方案」变成了「开放式跨端跨框架解决方案」，那么这两者之间有何差异呢？ 可以看出「开放式跨端跨框架解决方案」包含了多端统一开发的特性，同时支持跨框架开发，而且更重要的是能够成为一个开放式的解决方案，我们希望开发者可以根据 Taro 提供的 API 开发一个插件就能实现自己去为 Taro 扩展更多平台与前端框架的支持，例如未来有些新的平台推出小程序，或者有人希望能在 Taro 中使用 Angular 等更多的前端框架，那么就可以通过 Taro 的开放式机制来自行扩展，而不用等待 Taro 官方来进行支持，Taro 将只作为一个跨端适配的平台，所有的可能性都可以让社区自己去自由发掘。 实现小程序与 Web 的同构在当前 Taro 的设计下，使用 Taro 开发必须使用 Taro 标准组件库中的组件，而不能直接使用大家熟悉的 HTML 标签。我们正在努力打破这一藩篱，寻求支持让开发人员可以直接使用 HTML 标签来开发小程序的方案。 这样，既能进一步让 Taro 的开发体验接近 Web， 同时也能让一些 Web 生态资源可以直接运行在小程序中，极大降低从 Web 迁移到小程序的成本。 说说缺席的 Taro 3 RN 支持很多朋友在升级到 Taro 3 之后都会发出疑问：RN 是不再支持了吗？ Taro 3 没有支持 RN 适配，让很多使用 Taro 开发 RN 应用的朋友措手不及，经常在群里能看到上述灵魂拷问。 事实上 Taro 并没有抛弃 RN，目前 Taro 3 RN 适配工作已经由 「58 同城」开发团队接管，进行适配支持，目前这项工作已经正在紧锣密鼓进行，相信不久的将来就能看到在 Taro 3 中 RN 的支持王者归来。而这一次的通力协作也意味着 Taro 核心团队正不断成长为一个跨公司的团队，在未来一定会有更多灵感的碰撞，为社区开发者带来更多精彩的功能。 总结一下从目前的业界反馈与 Taro 自身规划来看，Taro 3 是一个非常值得尝试和期待的版本，已经有非常多的开发者开始使用 Taro 3 开发应用，在未来我们也会不断完善功能与文档，为大家带来更棒的开发体验。升级到 Taro 3 的过程或许稍显艰辛，但有任何问题，欢迎大家通过交流群和 GitHub issues 向我们进行反馈。 同时，诚挚邀请您与 Taro 官方团队交流您的使用情况，您的反馈是 Taro 前进的动力！请戳此完成 Taro 使用调研问卷，提交问卷，将有可能获得 Taro 团队的红包哦！！感谢一路相伴，Taro 有你更精彩！","pubDate":"Mon, 31 Aug 2020 16:00:00 GMT","guid":"https://aotu.io/notes/2020/08/31/taro-versions/","category":"移动开发"},{"title":"三分钟打造七夕专属的插件化脚手架","link":"https://aotu.io/notes/2020/08/25/valentine-plugin-cli/","description":"背景七夕节将至，你是否还因没有找到合适的表白机会而苦恼，还是说在纠结于为伴侣挑选合适的情人节礼物。那么今天你来对地方了。相信在读完这篇文章后，你就可以自己动手打造出一个专属于他/她/它的七夕专属插件化脚手架，通过本篇文章，不仅可以轻松拉近你与你爱人的距离，还能顺便学会插件化脚手架的相关知识。 温馨提醒本篇文章需要一定的命令行知识，若在阅读本篇文章时有任何的疑惑，可以通过自行搜索相关内容或者阅读以下的文章来解惑：https://aotu.io/notes/2016/08/09/command-line-development/index.html 废话不多说，直接进入正题 项目目录结构1234567891011121314151617181920.├── lerna.json├── package.json├── packages│ ├── cli // 七夕专属插件化cli│ │ ├── api │ │ │ ├── commandAPI.js │ │ │ ├── operateHooks.js │ │ │ └── share-utils.js│ │ ├── bin │ │ │ └── valentine│ │ ├── commands│ │ │ └── happy.js│ │ └── package.json│ └── confession // confession插件│ ├── command.config.js│ └── package.json├── scripts│ └── np.js // 用于批量部署发布脚手架和插件的定制脚本└── yarn.lock 编写插件化脚手架项目代码新建七夕项目 新建一个名为valentine的空目录并进入该目录，通过执行yarn init -y初始化目录（没安装yarn的需要安装一下yarn），同时保证node版本&gt;=10。 由于这个项目不仅有我们的核心脚手架，还存在着一些“用于表明心意”的插件，因此我们将使用monorepo的仓库结构，并安装lerna来进行仓库的管理，这里使用lerna是因为lerna能对多个packages进行统一的版本的管理。在目录下执行yarn add --dev lerna。 在目录下新建lerna.json文件，对lerna进行以下配置： 12345678&#123; \"packages\": [ \"packages/*\" ], \"version\": \"0.0.1\", \"npmClient\": \"yarn\", \"useWorkspaces\": true&#125; 在项目根目录的package.json下添加以下配置： 123456&#123; \"private\": true, \"workspaces\": [ \"packages/*\" ]&#125; 在项目的根目录下新建一个名为packages的文件夹，里面用来存放我们的核心脚手架以及插件的package。 all right，万事俱备~ 初始化脚手架package目录 进入packages文件夹，新建一个名为cli的文件夹，我们主要在这个文件夹内，对我们的脚手架核心逻辑进行编写。 进入到cli文件夹内，新建package.json文件，添加如下内容： 12345678910111213141516171819&#123; \"name\": \"@o2team/valentine-cli\", \"version\": \"0.0.1\", \"main\": \"index.js\", \"license\": \"MIT\", \"bin\": &#123; \"valentine\": \"./bin/valentine\" &#125;, \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"author\": \"\", \"description\": \"\", \"dependencies\": &#123; \"chalk\": \"^4.1.0\", \"commander\": \"^5.1.0\", \"tapable\": \"^1.1.3\" &#125;&#125; 在cli文件夹内新建bin文件夹，并进入bin文件夹内新建valentine文件，通过chmod +x ./valentine为其添加可执行权限，并在文件内写入简单的代码： 12#!/usr/bin/env nodeconsole.log('-------- 情人节快乐 --------') 在项目根目录下打开终端，运行./packages/cli/bin/valentine，顺利的话，你将在终端看到“情人节快乐”。 完善脚手架核心逻辑当然，只能打印出一个如此简单的祝福，是完全不能达不到我们开始的预期的，甚至不能称得上是一个脚手架。 不过不要着急，接下来，容我先稍微介绍一下插件化脚手架的要点，并在接下来的文章中对这些要点进行实现。 插件化的核心要点一般来说，要实现插件化，我们需要关心以下三点： 插件的安装和卸载 插件的获取和管理 插件间的通信 而由于我们目前需要插件化的是脚手架，因此我们可以通过项目依赖的方式来实现插件的安装和卸载，而脚手架本身只需要在它执行命令的项目的依赖内寻找需要加载的插件即可。 最后valentine内的大致逻辑应变为：1234567891011#!/usr/bin/env nodeconst &#123; getAllCommands,&#125; = require('../api/commandAPI.js')console.log('-------- 情人节快乐 --------')// 获取所有的命令（预设+插件）getAllCommands().forEach(cwd =&gt; &#123; // 插件注册命令行&#125;) 编写获取插件逻辑接下来，我们去实现getAllCommands的逻辑： 首先我们在cli文件夹内新建一个名为api的文件夹，用于在里面存放一些获取和加载插件的逻辑，并在api文件夹内新建commandAPI.js文件。 在commandAPI.js文件内实现getAllCommands的逻辑：123456789101112131415161718192021222324252627const fs = require('fs')const path = require('path')// 获取所有命令行命令，包括预设的以及插件的module.exports.getAllCommands = () =&gt; &#123; const cwdFns = [] const localCwdPath = path.join(__dirname, '..', 'commands') const localCwdNames = [...fs.readdirSync(localCwdPath)] localCwdNames.forEach(name =&gt; &#123; const cwdPath = path.join(localCwdPath, name) cwdFns.push(require(cwdPath)) &#125;) const &#123; getAllPluginIdOfPackageJson &#125; = require('./share-utils') getAllPluginIdOfPackageJson().forEach(name =&gt; &#123; const command = path.join(process.cwd(), 'node_modules', name, 'command.config.js') try &#123; const cwd = require(command) cwdFns.push(cwd) &#125; catch (error) &#123; console.log(`$&#123;command&#125; 不存在`) &#125; &#125;) return cwdFns&#125; 在阅读上述代码的时候，你也许会有几点疑问： localCwd是什么？为什么需要获取它？localCwd是脚手架除了插件外原本所包含的一些命令功能，为了保证引入的一致性，因此它与插件的结构本质上是相同的，所以会在获取插件命令的时候一并获取。 share-utils文件所导出的函数做了什么？是如何实现的？share-utils所导出的getAllPluginIdOfPackageJson函数主要是利用正则来匹配当前项目下符合插件命名的依赖，并把这些依赖整合导出，供脚手架使用。 12345678910111213141516171819202122const fs = require('fs')const path = require('path')const pkPluginRE = /^(@o2team\\/)valentine-plugin-/ exports.pkPluginRE = pkPluginRE exports.getAllPluginIdOfPackageJson = () =&gt; &#123; const pkgJsonPath = path.join(process.cwd(), 'package.json') const deps = &#123;&#125; const plugins = [] if (fs.existsSync(pkgJsonPath)) &#123; const pkg = require(pkgJsonPath) Object.assign(deps, pkg.devDependencies || &#123;&#125;, pkg.dependencies || &#123;&#125;) Object.keys(deps).forEach(dep =&gt; &#123; pkPluginRE.test(dep) &amp;&amp; plugins.push(dep) &#125;) &#125; return plugins &#125; 这个getAllCommands函数的整体逻辑是怎么样的？getAllCommands的其实一共做了三件事情： 一，获取脚手架内置的命令功能； 二，匹配当前项目下符合插件命名的依赖，对这些依赖进行整合并导出； 三，遍历这些插件依赖，与内置的命令功能一起，将它们的注册函数cwd导入到一个数组内，并将该数组导出。 编写注册插件和解析命令逻辑至此，我们的脚手架已经可以拿到与当前项目有关的所有插件的注册函数了，接下来我们只需要给这些注册函数传入我们的注册命令以及相关帮助函数，并在注册完成后对终端输入的命令进行解析，那么这个七夕专属的插件化脚手架就基本完成了。 同样的，我们需要改写一下cli/bin/目录下的valentine文件，改写内容如下：1234567891011121314151617#!/usr/bin/env nodeconst &#123; injectCommand, getAllCommands, commandComplete&#125; = require('../api/commandAPI.js')console.log('-------- 情人节快乐 --------')// 获取所有的命令（预设+插件）getAllCommands().forEach(cwd =&gt; &#123; // 插件注册命令行 cwd(&#123; injectCommand &#125;)&#125;)// 命令行注册完成commandComplete() 在commandAPI.js文件内添加injectCommand函数和commandComplete函数，这两个函数的逻辑并不复杂，相信读者阅读一次就能轻松理解:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475const fs = require('fs')const path = require('path')const program = require('commander')const packageConfig = require('../package.json')let status = 'pending'let cliConfig = &#123; name: '小屁', hobby: '减肥' &#125;const commandNames = ['-V', '--version', '-h', '--help']program .usage('&lt;command&gt; [options]') .version(packageConfig.version)module.exports.operateHooks = operateHooks// 为每个命令的注入函数提供所需的参数，如program等对象module.exports.injectCommand = (cmd) =&gt; &#123; if (status === 'done') return console.error('注册命令行时机已经是 done，请提前注册～') if (typeof cmd !== 'function') return console.error(cmd, '必须是一个函数') cmd(&#123; program, cliConfig &#125;)&#125;// 注册完所有命令后，检测当前命令是否存在，并更改脚手架状态module.exports.commandComplete = function() &#123; commandValidate() parseArgv() status = 'done'&#125;function parseArgv() &#123; program.parse(process.argv) program.commands.forEach(c =&gt; c.on('--help', () =&gt; console.log()))&#125;function commandValidate() &#123; program.commands.map(command =&gt; commandNames.push(command._name)) const commandName = process.argv[2] if (commandName &amp;&amp; !commandNames.includes(commandName)) &#123; console.log(chalk.red(` 没有找到 $&#123;process.argv[2]&#125; 命令 \\n`)) program.help() &#125; if (!process.argv[2]) &#123; program.help() &#125;&#125;// 获取所有命令行命令，包括预设的以及插件的module.exports.getAllCommands = () =&gt; &#123; const cwdFns = [] const localCwdPath = path.join(__dirname, '..', 'commands') const localCwdNames = [...fs.readdirSync(localCwdPath)] localCwdNames.forEach(name =&gt; &#123; const cwdPath = path.join(localCwdPath, name) cwdFns.push(require(cwdPath)) &#125;) const &#123; getAllPluginIdOfPackageJson &#125; = require('./share-utils') getAllPluginIdOfPackageJson().forEach(name =&gt; &#123; const command = path.join(process.cwd(), 'node_modules', name, 'command.config.js') try &#123; const cwd = require(command) cwdFns.push(cwd) &#125; catch (error) &#123; console.log(`$&#123;command&#125; 不存在`) &#125; &#125;) return cwdFns&#125; 编写内置插件至此，我们的插件化脚手架已经可以投入使用了，让我们来试着写一个内置的插件，在cli目录下，新建一个commands文件夹，在里面新建一个happy.js，写入如下代码：123456789101112131415module.exports = (&#123; injectCommand, operateHooks &#125;) =&gt; &#123; const &#123; hooksMap, createHook &#125; = operateHooks createHook('happyStartHook') injectCommand(function(&#123; program, cliConfig &#125;) &#123; program .command('happy') .description('情人节祝福') .action(async () =&gt; &#123; const &#123; name, hobby &#125; = cliConfig await hooksMap.happyStartHook.promise() console.log(`喜欢$&#123;hobby&#125;的$&#123;name&#125;, 祝你情人节快乐~`) &#125;) &#125;)&#125; 然后我们在cli目录下启动终端，并运行./bin/valentine happy，你将看到如下的输出： 编写非内置插件接着，我们将新建一个非内置的插件，并随后讲解插件间是如何做到通信的。首先，我们需要新建一个package，即进入到packages目录，新建一个confession文件夹，进入confession文件夹，新建package.json文件，和cli类似的写入以下内容：1234567891011&#123; \"name\": \"@o2team/valentine-plugin-confession\", \"version\": \"0.0.1\", \"main\": \"index.js\", \"license\": \"MIT\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"author\": \"\", \"description\": \"\"&#125; 在这里需要注意，package.json里的name字段可以是自定义的，但一定要和之前脚手架的share-utils内定义的正则相匹配，以便被脚手架获取插件时识别。之后，新建一个名为command.config.js的文件，同样的，写入注册函数的内容：123456789101112131415161718192021module.exports = (&#123; injectCommand &#125;) =&gt; &#123; injectCommand(function(&#123; program &#125;) &#123; program .command('love') .description('情人节表白') .action(() =&gt; &#123; logLove() &#125;) &#125;)&#125;function logLove () &#123; console.log(` ____ __ ____ _ ________ __ ______ __ __ / _/ / / / __ \\\\ | / / ____/ \\\\ \\\\/ / __ \\\\/ / / / / / / / / / / / | / / __/ \\\\ / / / / / / / _/ / / /___/ /_/ /| |/ / /___ / / /_/ / /_/ / /___/ /_____/\\\\____/ |___/_____/ /_/\\\\____/\\\\____/ `)&#125; 一个“情人节表白”插件就这样完成了，接着我们将这两个package都上传至npm，并安装到一个新的项目中，在项目下执行./node_modules/.bin/valentine love，便能看到confession插件命令被执行了： 完成插件间的通讯接下来，我们希望每次valentine happy命令被执行时，能先执行插件valentine love命令，这个时候，我们就需要往我们的插件化脚手架中加入组件的通信机制了。在这里，我们会使用tapable来实现插件间的通信，tapable是一个类似于Node.js中的EventEmitter的库，但更专注于自定义事件的触发和处理。具体的用法希望读者可以自行搜索，这里就不多介绍。 关于tapable的使用，有兴趣的同学可以戳这里了解一下： 戳这里 我们在api目录下新建一个名为operateHooks的js文件，在文件内写入以下内容：1234567891011121314151617181920212223242526272829const &#123; AsyncSeriesHook &#125; = require('tapable')module.exports = class OperateHooks &#123; constructor () &#123; this.hooksMap = &#123;&#125; this.hooksTapList = [] this.tapHook = this.tapHook.bind(this) this.bindHooks = this.bindHooks.bind(this) this.createHook = this.createHook.bind(this) &#125; createHook (nameSpace) &#123; this.hooksMap[nameSpace] = new AsyncSeriesHook() &#125; tapHook (hookName, eventName, cb) &#123; this.hooksTapList.push(&#123; hookName, eventName, cb &#125;) &#125; bindHooks () &#123; this.hooksTapList.forEach(hook =&gt; &#123; const &#123; hookName, eventName, cb &#125; = hook this.hooksMap[hookName].tapPromise(eventName, async () =&gt; &#123; await cb() &#125;) &#125;) &#125;&#125; 之后，在commandAPI中，对OperateHooks类进行实例化，并在commandComplete执行operateHooks实例的bindHooks方法，最后导出该实例。12345678910const operateHooks = new OperateHooks()module.exports.operateHooks = operateHooksmodule.exports.commandComplete = function() &#123; commandValidate() operateHooks.bindHooks() parseArgv() status = 'done'&#125; 在valentine文件中引入该实例，在进行插件命令注册时将该实例作为参数传入。123456789101112131415161718#!/usr/bin/env nodeconst &#123; injectCommand, getAllCommands, commandComplete, operateHooks&#125; = require('../api/commandAPI.js')console.log('-------- 情人节快乐 --------')// 获取所有的命令（预设+插件）getAllCommands().forEach(cwd =&gt; &#123; // 插件注册命令行 cwd(&#123; injectCommand, operateHooks &#125;)&#125;)// 命令行注册完成commandComplete() 最后分别在happy.js和confession/command.config.js对operateHooks实例进行对应钩子的创建和绑定即可：12345678910111213141516// happy.jsmodule.exports = (&#123; injectCommand, operateHooks &#125;) =&gt; &#123; const &#123; hooksMap, createHook &#125; = operateHooks createHook('happyStartHook') injectCommand(function(&#123; program, cliConfig &#125;) &#123; program .command('happy') .description('情人节祝福') .action(async () =&gt; &#123; const &#123; name, hobby &#125; = cliConfig await hooksMap.happyStartHook.promise() console.log(`喜欢$&#123;hobby&#125;的$&#123;name&#125;, 祝你情人节快乐~`) &#125;) &#125;)&#125; 12345678910111213141516171819202122232425// confession/command.config.jsmodule.exports = (&#123; injectCommand, operateHooks &#125;) =&gt; &#123; operateHooks.tapHook('happyStartHook', 'love', async () =&gt; &#123; logLove() &#125;) injectCommand(function(&#123; program &#125;) &#123; program .command('love') .description('情人节表白') .action(() =&gt; &#123; logLove() &#125;) &#125;)&#125;function logLove () &#123; console.log(` ____ __ ____ _ ________ __ ______ __ __ / _/ / / / __ \\\\ | / / ____/ \\\\ \\\\/ / __ \\\\/ / / / / / / / / / / / | / / __/ \\\\ / / / / / / / _/ / / /___/ /_/ /| |/ / /___ / / /_/ / /_/ / /___/ /_____/\\\\____/ |___/_____/ /_/\\\\____/\\\\____/ `)&#125; 待优化项目前这个插件化脚手架还存在着一些问题和可优化点： 插件的获取是通过正则匹配来进行的，这样的做法在依赖较多的仓库中效率会非常低下。 目前插件的获取形式在遇到monorepo形态的项目时，会引发项目跟目录和命令执行目录不一致的问题。 目前插件只支持项目插件，缺少了全局插件的支持。 这些优化项的可实现方法很多，由于考虑到篇幅问题，希望读者可以自己去思考，然后自行解决和优化。 最后但是，不管怎么说，一个七夕专属的插件化脚手架可以说已经完成了，最终效果： 快点拿着它和你最爱的那个他/她/它表白吧~ 项目仓库戳这里","pubDate":"Tue, 25 Aug 2020 07:21:00 GMT","guid":"https://aotu.io/notes/2020/08/25/valentine-plugin-cli/","category":"Web开发"},{"title":"京喜小程序体验评分优化实践","link":"https://aotu.io/notes/2020/08/25/jx-audit-grade-optimization/","description":"背景体验评分 Audits 是微信开发者工具内置的一项功能，会在小程序运行过程中实时检查，分析出一些可能导致体验不好的地方，并且定位出哪里有问题，以及给出一些优化建议。 京喜小程序作为京东战略级业务，拥有千万级别的流量入口，经过长时间的业务迭代，代码逻辑已经十分复杂臃肿，有迫切的性能优化需求。因此，结合体验评分功能，以京喜首页做试点，我们进行了一次体验评分的优化实践。目的是探索小程序体验评分的指标原则：拿到100分的小程序应该是什么样子的；同时希望借此给项目优化提供更多思路。 我会按照「了解首页评分现状，分析扣分项规则，解决扣分项」这个思路来介绍，就让我们开始吧～ 京喜首页评分现状打开小程序开发者工具-调试器-Audits，点击运行，操作页面滚一滚点一点，然后点击结束。 评分结果会根据评测页面内容差异、操作习惯、有无缓存有一定浮动，下图是京喜首页的一次评分：总分68，性能、体验、最佳实践都有扣分，合计8项扣分项，后面我们来逐条分析这些扣分项。 扣分项分析和优化1、使用了过大的 WXML 节点数目 得分标准：页面 WXML 节点少于 1000 个，节点树深度少于 30 层，子节点数不大于 60 个。 页面节点指标的意义在于，过大的节点数，过多过深的节点组成，都会增加内存使用，样式重排时间更长，影响体验。 现有节点2500+，想要进行优化，首先需要了解页面各个模块的节点数分布。 如何统计每个模块的节点数呢？可以使用「控制变量法」，利用性能评测工具中，节点数超过1000时会列出节点总数的能力，我们可以在总指标超过1000的情况下，每次隐藏一个模块： ​ 目标模块节点数 = 原总节点数 - 当前节点数 （实测节点数会有小范围浮动，可以测3次取平均值） 首页的模块分析图如下： ​ （第一屏） （第二屏） 简化数据如下： 观察列表可以得到两个信息：首页分为展示状态互斥的第一屏和第二屏；列表模块的节点数是大头。 因此，我们得到优化的两个方向： 页面元素按需加载，不展示时不渲染 长列表减少元素个数 第一个优化项可以通过变量控制组件显示隐藏，按需加载卸载。 第二个优化项首先想到的是减少列表接口分页数值，比如一次请求20条数据改为请求5条。但是如果接口不支持自定义分页，还可以实现更小的分页拉取吗？ 那就自己写一个分页方法的代理吧～ 思路如下： 上方为原始请求，每次20条数据，下方为代理请求的实现，每次返回5条。灰色虚线框是真实的请求数据动作，通过维护一个全量数据，需要哪页取哪页，这是示例代码： 通过以上两个优化，可以成功的把首页的页面节点数瘦身一下了，最后我们成功达到 wxml 节点总数不大于1000的目标。 2、存在图片太大而有效显示区域较小 得分标准：图片宽高乘积 &lt;= 实际显示宽高乘积 * (设备像素比 ^ 2) 简单理解是图片尺寸太大而展示尺寸太小，导致浪费网络请求时间和内存资源。 解决方案：cdn服务商一般都支持通过参数获取不同尺寸的图片，前端可以包装一个公共方法，根据页面元素尺寸拉取合适大小的图片。 此外，补充一下图片体积的内容，除了关注图片尺寸，具体的体积大小其实更值得关注，有以下两个点可以了解下： 图片类型的选择大有文章，jpg/png/gif 还有 webp 应该怎么选呢？先放一张 google 的图 这张图里未考虑 webp，加上 webp 其他类型竞争力瞬间不足了，移动端 androd 支持率基本可用，可以考虑根据设备类型渐进式使用： 利用一些压缩技术对图片进行压缩，png 推荐 https://tinypng.com/ ，压缩尺寸可观，但对图片显示质量影响甚微。 3、存在可点击元素的响应区域过小 得分标准：可点击元素的宽高都不小于 20px 移动端操作全靠手指，过小的交互区域会带来不好的体验，可以通过增大元素响应热区的方式来优化，以下方式都可以： padding 透明的border box-shadow 4、对网络请求做必要的缓存得分标准：3 分钟以内同一个url请求不出现两次回包大于 128KB 且一模一样的内容 这一项的理由是，发起网络请求总会让用户等待，可能造成不好的体验，应尽量避免多余的请求，比如对同样的请求进行缓存。 优化方式： 善用小程序的 storage 能力，做好更新和过期管理后，尽可能缓存请求到的数据。 针对确实需要多次请求的日志类接口，可以通过在参数内添加随机数或者时间戳的方式进行区分，避免误判。 5、存在短时间内发起太多的请求得分标准：通过wx.request发起的耗时超过 300ms 的请求并发数不超过 10 个。 不同于上一项，这一项关注的是接口并发数： wx.request （HTTP 连接）的最大并发限制是 10 个 wx.connectSocket （WebSocket 连接）的最大并发限制是 5 个 优化方式： 计算逻辑后移， 接口聚合 对于职责类似的网络请求，最好采用节流的方式，先在一定时间间隔内收集数据，再合并到一个请求体中发送给服务端 6、存在未绑定在wxml上的变量 得分标准：setData传入的所有数据都在模板渲染中有相关依赖 这一项考察的是 data 冗余的问题，小程序设计了渲染和逻辑分离的双线程，两边通讯通过 evaluateJavascript 转换字符串再进行拼接实现，需要非常小心两个线程之间通讯的数据量。因此，未绑定wxml的变量，最好优化成不使用 setData。 根据使用场景，可以做的优化有： 与页面展示无关的内部变量，可以挂载在组件实例上，比如维护一个 this.privateData 对象 使用小程序新版本支持的「纯数据字段」：该字段不会被传递到 wxml 内，配置正则划定它的匹配范围，可以正常使用 setData 方法，具体用法参见文档：https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/pure-data.html 但是，如果你像我一样遇到上面策略无法覆盖的场景呢？ 需要修改旧代码，配置纯数据字段的正则影响太大 京喜首页使用了 Taro 做多端适配，Taro 编译复杂逻辑的数组后会出现「影子变量」去代理逻辑，原本的数组变量被架空导致扣分 那么还有一个终极 hack 的方法： 这样 list 会被判断为有绑定节点，就不会扣分了 7、发起太多的图片请求得分标准：同域名耗时超过 100ms 的图片请求并发数不超过 20 个 最后这一项也是图片相关，发起太多图片请求会触发浏览器并行加载的限制，可能导致图片加载慢，用户一直处于等待中。 优化方式： 雪碧图 图片懒加载：小程序 Image 组件支持通过配置 lazy-load 参数来实现懒加载（https://developers.weixin.qq.com/miniprogram/dev/component/image.html ），具体判定逻辑是图片进入上下三屏就开始加载。如果需要更可控的实现，可以自己构建组件来处理。 总结做完这些优化，再测一下体验评分： 以上就是京喜首页在小程序体验评分优化方面进行的实践内容了。 总结一下，小程序性能评分可以从指标和实际数据上给我们的项目优化提供一些建议，本文主要从评分角度去分析了各种优化可能，希望能为各位小程序开发者带来参考价值。 参考资料[1] 小程序开发文档：https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B [2] Images: Your easiest page speed win: https://searchengineland.com/images-easiest-page-speed-win-269742 [3] Tiny Png: https://tinypng.com/","pubDate":"Tue, 25 Aug 2020 02:36:00 GMT","guid":"https://aotu.io/notes/2020/08/25/jx-audit-grade-optimization/","category":"小程序"},{"title":"Design Tokens —— 设计与开发碰撞的火花","link":"https://aotu.io/notes/2020/08/18/design-tokens/","description":"前言在前端的开发的过程中，和前端合作最紧密的职位应该就是设计师了。在业务流程中，设计师将自己的交互稿、视觉稿以 1px 以内误差的期望交给开发者。但在这个过程中有几个不方便的地方： 设计稿可拆解为布局、图案、文字、颜色等。其中布局、文字以及颜色这三者的样式编码需要花费前端开发者大量的时间。虽说近几年随着蓝湖等设计协同工作平台的诞生，可以在平台上获取到部分 css 代码，但是依然不能满足 web、iOS、Android 等多平台的情况； 设计稿的更新无法及时在开发者的代码中体现，一是因为开发首先需要拿到新的设计稿，再根据标注甚至肉眼判断区别后更新代码；另一方面，设计稿中看似简单的改动可能导致较大范围的代码改动，例如字体大小等。 为了解决上述的问题，完善设计和开发之间的协作流程，Design Tokens 应运而生。 什么是 Design Tokens在了解 Design Tokens 之前，需要先了解一下 Design System （即设计系统）的概念。这个概念在设计和开发的沟通流程中已经流行许久，在团队设计体系工程化的过程中不可或缺。 A Design System is the single source of truth which groups all the elements that will allow the teams to design, realize and develop a product. 设计系统能够保证项目中设计稿与开发代码的一致——设计师将设计稿件中的内容组件化，在这个系统中上传每个组件的样式、文字属性、颜色色值等。而开发者可以通过这个系统获取自己需要的组件内容。但是这样仅仅是实现了一个协作平台，那么如何解决前文提到的两个问题呢？ Design Tokens 就是解决问题的核心。 Design tokens are the visual design atoms of the design system. Design Tokens 统一了样式属性和前端语言，把每种属性都当成是一个前端变量。 举个例子，将一种颜色色值传到系统中，然后转换成 token ，前端就可以直接取这个变量使用。即使是色值被修改，当变量名不变时，对整体代码是毫无影响的，开发者要做的仅仅是重新导入一份 token。 其中 token 的语言类型可以是 css、scss、yml 等。 如何开发 Design Tokens在已知 Design Tokens 本质是一种变量的情况下，我们需要做的就是将颜色色值和文字属性变成对应的变量。 其中文字属性有比较特别的地方，它除了要把 font-family、font-size 等转换成变量之外，还需要将这些变量集合在一个 mixin 里面，方便整体使用。 所以我们需要完成的事情有如下四步，获取属性、生成变量、生成 mixin 、输出结果。其中获取属性不用多说，直接从数据库中拿到色值和文字的数据，然后分别写入 json 文件保存即可。 1.生成变量我们转换的变量类型有 css、scss、less、stylus、json、yaml、Android、iOS 八种，其中 css、scss、less、stylus、Android 这五种通过 Theo 库来实现，其余为代码手动实现。 Theo先来介绍一下 Theo,一个能够对样式进行 transform 和 format，随后输出对应变量的库。它的实现原理大致为，先将 json 文件中的值进行处理——色值处理为 rgb 或者 rgba，其余样式属性的数值进行单位统一。随后将处理过的值依据一定规则写入一个新的对象中。这个对象就是 Design Tokens。 直接上代码： 123456789101112131415161718192021static async formatWebOrtAndroid (type: string) &#123; const res = await theo .convert(&#123; transform: &#123; // 这里是类型，可以是 web或者是 android type: 'web', file: path.resolve(__dirname, 'data.json'), &#125;, format: &#123; // 这里是需要输出的变量语言类型，css、scss、less、stylus、Android 等 type, &#125; &#125;) .then(data =&gt; &#123; // 这里可以根据自己的需求进行数据处理 return data &#125;) .catch(error =&gt; console.log(`Something went wrong: $&#123;error&#125;`)) return res&#125; 自定义方法其余的 json、yaml、iOS 这三种需要我们手动实现。json 和 yaml 的实现非常简单，只需要稍微处理一下数据为我们需要的格式，然后写入 json 或者 yaml 文件即可。 iOS 略微复杂，它支持 Objective-c 和 Swift 两种类型的语言，所以要分别处理这两种语言。 Objective-c 需要分为 .h 和 .m 两个文件，对色值进行如下处理： 12345678910// 先将变量名称写入let colorsH += `- (UIColor *)$&#123;colorName&#125;;\\n`// 处理对应的变量名称下的色值let colorsM += `- (UIColor *)$&#123;colorName&#125; &#123;return [UIColor colorWithRed:($&#123;red&#125;)/255 green:($&#123;green&#125;)/255 blue:($&#123;blue&#125;)/255 alpha:($&#123;alpha&#125;)];&#125;\\n\\n`// 处理首尾colorsH = `@interface UIColor (Colors)\\n\\n$&#123;colorsH&#125;\\n@end`colorsM = `#import \"designTokenColor.h\"\\n\\n@implementation UIColor (Colors)\\n\\n$&#123;colorsM&#125;\\n@end\\n` Swift 的处理方法类似，直接上代码： 12345// 先将变量名称写入，并处理色值let colorsSwift += `class func $&#123;colorName&#125;() -&gt; UIColor&#123;\\nreturn UIColor( red: ($&#123;red&#125;)/255, green: ($&#123;green&#125;)/255, blue: ($&#123;blue&#125;)/255, alpha: ($&#123;alpha&#125;) );&#125;\\n\\n`colorsSwift = `import UIKit;\\n\\nextension UIColor&#123;\\n\\n$&#123;colorsSwift&#125;\\n&#125;\\n` 其实上述的自定义方法也可以直接定义在 Theo 中，因为 Theo 支持注册自定义 transform 事件以及自定义 format 事件，并且可以对获取到的数据进行二次处理。 2.生成 mixinmixin 是 scss 中的名称，其实就是变量的集合，能够使得一系列属性能够被整体应用。由于 Theo 没有提供对应方法，所以我们这边采用手动生成的方式。目前只针对我们需要使用的文字属性进行了构建。 我们在第一步时已经生成了所有属性的变量，所以在构建 mixin 时只需将对应变量组合在一起即可，工作量并不大。但是由于需要构建的语言类型较多，针对不同语言要输出不同格式，所以依然写了部分相似代码。 以下为不同语言下的内容生成代码： css 12345678910111213--aotu: &#123; font-family: var(--aotu-font-family); font-size: var(--aotu-font-size); font-style: var(--aotu-font-style); font-weight: var(--aotu-font-weight); letter-spacing: var(--aotu-letter-spacing); line-height: var(--aotu-line-height); opacity: var(--aotu-opacity); text-align: var(--aotu-text-align); color: var(--aotu-text-color); text-decoration: var(--aotu-text-decoration); text-transform: var(--aotu-text-transform);&#125;; scss 12345678910111213@mixin aotu () &#123; font-family: $aotu-font-family; font-size: $aotu-font-size; font-style: $aotu-font-style; font-weight: $aotu-font-weight; letter-spacing: $aotu-letter-spacing; line-height: $aotu-line-height; opacity: $aotu-opacity; text-align: $aotu-text-align; color: $aotu-text-color; text-decoration: $aotu-text-decoration; text-transform: $aotu-text-transform;&#125; less 12345678910111213.aotu () &#123; font-family: @aotu-font-family; font-size: @aotu-font-size; font-style: @aotu-font-style; font-weight: @aotu-font-weight; letter-spacing: @aotu-letter-spacing; line-height: @aotu-line-height; opacity: @aotu-opacity; text-align: @aotu-text-align; color: @aotu-text-color; text-decoration: @aotu-text-decoration; text-transform: @aotu-text-transform;&#125; Android 12345678910111213// 这里采用的是一个对象，这个对象中包含了各种数值&lt;style name=$&#123;aotu.name&#125;&gt; &lt;item name=\"android:fontFamily\"&gt;$&#123;aotu.fontFamily&#125;&lt;/item&gt; &lt;item name=\"android:textSize\"&gt;$&#123;aotu.fontSize&#125;&lt;/item&gt; &lt;item name=\"android:letterSpacing\"&gt;$&#123;aotu.letterSpacing&#125;&lt;/item&gt; &lt;item name=\"android:lineHeight\"&gt;$&#123;aotu.lineHeight&#125;&lt;/item&gt; &lt;item name=\"android:textStyle\"&gt;$&#123;aotu.fontStyle&#125;&lt;/item&gt; &lt;item name=\"android:textFontWeight\"&gt;$&#123;aotu.fontWeight&#125;&lt;/item&gt; &lt;item name=\"android:gravity\"&gt;$&#123;aotu.textAlign&#125;&lt;/item&gt; &lt;item name=\"android:textAllCaps\"&gt;$&#123;aotu.textTransform === 'uppercase'&#125;&lt;/item&gt; &lt;item name=\"android:alpha\"&gt;$&#123;aotu.opacity&#125;&lt;/item&gt; &lt;item name=\"android:textColor\"&gt;$&#123;aotu.color&#125;&lt;/item&gt;&lt;/style&gt; 至此，Design Tokens 的生成已经完成。 3.输出结果我们将输出的各种语言结果保存在不同文件中，上传到服务器，将内容和获取链接返回给用户。用户可以直接通过链接下载文件进行使用，也可手动复制内容到自己的项目中进行使用。当设计师改变设计稿时，他们需要重新上传组件内容，Design Tokens 的内容也会随之改变。而对于开发者来说，只需要重新导入一个新的链接，就可以直接完成大量代码的更新，大大提升了设计师以及开发者的效率，减少了开发者的重复工作，降低了双方沟通成本和版本迭代成本。 Design Tokens 应用Design Tokens 已经被应用在凹凸的工作流中。 一个项目开启的时候，需要先在内部夸克平台创建一个项目，项目成员包括设计师与前端开发。随后设计师使用夸克平台提供的 Sketch 插件将项目中需要的色值和本文样式都保存到项目中。以下为插件中展示效果： 设计师完成上述步骤后，开发者进入夸克平台，在对应项目中可查看色值和文字样式。其中可以看到每个属性对应的变量名，并且可以对变量名作出修改。 所有的 Design Tokens 会集中展示在单独页面中，其中包括了下载链接，开发者直接通过链接下载内容，然后应用到自己的项目代码中即可。 总结Design System 可能会是将来设计师与开发者合作的一种模式，目前相应的应用还不是非常广泛。并且一些小项目中，大家更倾向于口头交流、文件交流等，而不是花时间先去构建一个设计系统。但是随着公司或者部门项目扩张，积累变多，一个完善的设计系统以及高效的沟通平台将会是必须的。Design System 以及 Design Tokens 给我们带来了新的方式和新的可能，我们将会继续探索它。","pubDate":"Tue, 18 Aug 2020 11:44:02 GMT","guid":"https://aotu.io/notes/2020/08/18/design-tokens/","category":"Web开发"},{"title":"使用react-docgen自动生成组件文档","link":"https://aotu.io/notes/2020/07/27/how-to-use-react-docgen/","description":"背景最近在接到一个开发 React 组件库的需求，组件库在开发过程中，刚写完一个组件打算给同事用，同事立马来了个灵魂拷问“啊？这个组件怎么用”。emmm，我寻思直接告诉它下一次又忘了，还是老老实实写个文档吧。 文档写到一半，@#%#¥……#@麻烦死了。这么多组件，每个组件都需要有对应的文档，写起来太耗时了，手写文档比写个组件还麻烦。为了能快点完（xia）成（ban）任（hui）务（jia）。于是研究下那些优秀的组件库到底是怎么做的，看了下京东凹凸实验室的Quark夸克组件库的文档生成，大受启发，以下内容是讲讲关于如何优雅地偷懒并把组件文档都做好的。 为什么要自动生成文档聊这个事情之前，我们先看看文档希望长什么样子 组件文档需要什么内容 提供组件的介绍说明 提供组件的属性列表 propTypes 提供组件调用的案例 usage 提供组件调用的演示案例/源码 如果要把这些内容都通过 markdown 去写，写完耗费的时间可能比做一个简单的组件还多，为了把更多的精力投入到开发更优质的组件当中，我们需要文档生成自动化。 文档自动化后能为我们带来什么？ 统一文档格式，抹平不同开发者写文档的格式差异 节省写文档的时间来做更多有意（tou）义（lan）的事情 我们拿一个小案例来尝试一下 react-docgen开始进入正题，先简单介绍下文档自动生成的主角 react-docgen ，官方对于它的介绍是这样的： react-docgen 是一个 CLI 和工具箱，可帮助从 React 组件中提取信息并从中生成文档。它使用 ast 类型和@ babel / parser 将源解析为 AST，并提供处理此 AST 的方法以提取所需的信息。输出/返回值是一个 JSON blob / JavaScript 对象。 简单来说就是：它能提取组件的相关信息 安装用 yarn 或 npm 安装模块： 123yarn add react-docgen --devnpm install --save-dev react-docgen 关于它的 API 可以参考官方文档 https://www.npmjs.com/package/react-docgen 偷偷再分享一个高级版的 react-styleguidist https://github.com/styleguidist/react-styleguidist 例子我们先写一个人物的组件，里面包含 姓名、爱好、事件回调 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// ./Persion/index.jsximport React, &#123; Component &#125; from 'react'import PropTypes from 'prop-types'/*** 人物组件* @description 这是关于人物组件的描述内容* @class Persion* @extends &#123;Component&#125;*/class Persion extends Component &#123; /** * 处理睡觉的回调 * @param &#123;string&#125; name 姓名 */ handleSleep = (name) =&gt; &#123; console.log(`$&#123;name&#125; 开始睡觉`) this.props.onSleep() &#125; render() &#123; const &#123; name, hobbies &#125; = this.props return ( &lt;div onClick=&#123;this.handleSleep.bind(this, name)&#125;&gt; &lt;p&gt;姓名：&#123;name&#125;&lt;/p&gt; &lt;p&gt;爱好：&#123;hobbies.join(',')&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;Persion.propTypes = &#123; /** * 姓名 */ name: PropTypes.string.isRequired, /** * 爱好 */ hobbies: PropTypes.array, /** * 睡觉的事件回调 */ onSleep: PropTypes.func&#125;Persion.defaultProps = &#123; name: '张三', hobbies: ['睡觉', '打王者']&#125;export default Persion 我们定义了一个人物的组件，在组件类注释中描述了组件的基本信息, 同时在propTypes和defaultTypes中也对组件的属性参数进行了定义和属性注释 组件的基本信息都写的差不多了，那么我们先开始使用react-docgen去提取组件的相关信息。 12345678910111213// ./docgen.jsconst path = require('path')const fs = require('fs-extra')const reactDocs = require('react-docgen')const prettier = require('prettier')// 读取文件内容const content = fs.readFileSync(path.resolve('./Persion/index.jsx'), 'utf-8')// 提取组件信息const componentInfo = reactDocs.parse(content)// 打印信息console.log(componentInfo) 这里写了一个简单的读取文件和解析的过程，并把提取到的信息打印出来，以下是组件信息提取后的内容 componentInfo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&#123; \"description\":\" 人物组件 @description 这是关于人物组件的描述内容 @class Persion @extends &#123;Component&#125;\" , \"displayName\":\"Persion\", \"methods\":[ &#123; \"name\":\"handleSleep\", \"docblock\":\" 处理睡觉的回调 @param name 姓名 \", \"modifiers\":[ ], \"params\":[ &#123; \"name\":\"name\", \"description\":\"姓名\", \"type\":&#123; \"name\":\"string\" &#125;, \"optional\":false &#125; ], \"returns\":null, \"description\":\"处理睡觉的回调\" &#125; ], \"props\":&#123; \"name\":&#123; \"type\":&#123; \"name\":\"string\" &#125;, \"required\":false, \"description\":\"姓名\", \"defaultValue\":&#123; \"value\":\"'张三'\", \"computed\":false &#125; &#125;, \"hobbies\":&#123; \"type\":&#123; \"name\":\"array\" &#125;, \"required\":false, \"description\":\"爱好\", \"defaultValue\":&#123; \"value\":\"['睡觉', '打王者']\", \"computed\":false &#125; &#125;, \"onSleep\":&#123; \"type\":&#123; \"name\":\"func\" &#125;, \"required\":false, \"description\":\"睡觉的事件回调\" &#125; &#125;&#125; 关于 react-docgen 提取的信息中，解释下下面几个参数 displayName 组件名称 description 组件的类注释 methods 组件定义的方法 props 组件的属性参数 其中这里的props是我们组件文档的核心内容，在提取的内容中，已经涵盖了属性的 属性名、属性描述、类型、默认值、是否必传。这些内容满足我们阅读组件文档所需要的属性信息。 有了所需的componentInfo信息之后，下一步我们需要把它转换成 markdown （至于为什么要用 markdown 我就不解释了 8） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// ./docgen.js// 生成markdown文档fs.writeFileSync(path.resolve('./Persion/index.md'), commentToMarkDown(componentInfo))// 把react-docgen提取的信息转换成markdown格式function commentToMarkDown(componentInfo) &#123; let &#123; props &#125; = componentInfo const markdownInfo = renderMarkDown(props) // 使用prettier美化格式 const content = prettier.format(markdownInfo, &#123; parser: 'markdown' &#125;) return content&#125;function renderMarkDown(props) &#123; return `## 参数 Props | 属性 | 类型 | 默认值 | 必填 | 描述 | | --- | --- | --- | --- | ---| $&#123;Object.keys(props) .map((key) =&gt; renderProp(key, props[key])) .join('')&#125; `&#125;function getType(type) &#123; const handler = &#123; enum: (type) =&gt; type.value.map((item) =&gt; item.value.replace(/'/g, '')).join(' \\\\| '), union: (type) =&gt; type.value.map((item) =&gt; item.name).join(' \\\\| ') &#125; if (typeof handler[type.name] === 'function') &#123; return handler[type.name](type).replace(/\\|/g, '') &#125; else &#123; return type.name.replace(/\\|/g, '') &#125;&#125;// 渲染1行属性function renderProp( name, &#123; type = &#123; name: '-' &#125;, defaultValue = &#123; value: '-' &#125;, required, description &#125;) &#123; return `| $&#123;name&#125; | $&#123;getType(type)&#125; | $&#123;defaultValue.value.replace( /\\|/g, '&lt;span&gt;|&lt;/span&gt;' )&#125; | $&#123;required ? '✓' : '✗'&#125; | $&#123;description || '-'&#125; | `&#125; 上面的转换 markdown 的代码其实做的事情比较少，主要是以下几个步骤 遍历props对象中的每个属性， 解析属性prop，提取属性名、类型、默认值、必填、描述、生成对应的 markdown 表格行。 生成 markdown 内容，通过prettier美化 markdown 代码。 经过转换后最终生成我们这个 markdown 的文件 1234567## 参数 Props| 属性 | 类型 | 默认值 | 必填 | 描述 || ------- | ------ | ------------------ | ---- | -------------- || name | string | '张三' | ✗ | 姓名 || hobbies | array | ['睡觉', '打王者'] | ✗ | 爱好 || onSleep | func | - | ✗ | 睡觉的事件回调 | 拓展优化这个案例只简单讲述了如何解析props并生成 markdown 的参数 Props模块的流程，在现实项目中，以上流程还有很多可以优化的空间，我们还可以通过很多自定义规则进行各种骚操作。 比如我们不希望把参数的数据属性（name、hobbies）和回调属性（onSleep）都放到同一个 Props 表格中，我们希望可以进行属性上的分类。 在属性描述的注释中，我们可以通过 @xx （或者 ¥%#@^!【】……你喜欢就好）进行不同的描述定义和分类，最终在属性解析的步骤中进行信息的深度的拆分解析分类，生成更加复杂多元的文档。 经过一些改造后，我们通过在注释中添加不同规则的定义描述，得到更优雅美观的文档模块 1234567891011121314151617Persion.propTypes = &#123; /** * @text 姓名 * @category data */ name: PropTypes.string.isRequired, /** * @text 爱好 * @category data */ hobbies: PropTypes.array, /** * @text 睡觉的事件回调 * @category event */ onSleep: PropTypes.func&#125; 123456789101112## 数据 Data| 属性 | 类型 | 默认值 | 必填 | 描述 || ------- | ------ | ------------------ | ---- | ---- || name | string | '张三' | ✗ | 姓名 || hobbies | array | ['睡觉', '打王者'] | ✗ | 爱好 |## 事件 Event| 属性 | 类型 | 默认值 | 必填 | 描述 || ------- | ---- | ------ | ---- | -------------- || onSleep | func | - | ✗ | 睡觉的事件回调 | 当然还有很多比如description或者methods等都可以进行不同的解析并生成对应的markdown模块，数据信息提取出来了，其实最终怎么进行ast解析取决自身的具体业务要求。 小结在日常开发的过程中，我们除了组件的代码编写外，还有很多流程上、边角上的工作需要做，这些事情往往都比较琐碎又必须要做。我们多借助工具去解决我们的工作中那些零星简单的任务，从而达到高（jiu）效（xiang）完（kuai）成（dian）工（xia）作（ban）的目标。开发者都是懒惰的（可能只有我？？），不然怎么会有这么多自动化的产物呢～ 参考资料：[1] react-docgen 仓库文档 https://github.com/reactjs/react-docgen#readme","pubDate":"Mon, 27 Jul 2020 01:00:00 GMT","guid":"https://aotu.io/notes/2020/07/27/how-to-use-react-docgen/","category":"经验分享"},{"title":"几种移动端多平台元素垂直居中解决方案总结","link":"https://aotu.io/notes/2020/07/24/line-height-in-all-hardware/","description":"前言在PC时代，垂直居中就是一个会引起很多讨论的问题，例如经典问题：如何在任何容器里，让任意行数的元素都能垂直居中，相信很多同学对于这个问题还记忆尤深。如今移动端已经成为了我们的主要平台，随之而来的问题也更加复杂。 而作为大促前端，我们的问题更加复杂，我们需要兼容大量不同平台的手机，例如：安卓4.4系统、IOS8、IOS9等等远古手机。可能有同学很好奇为何还需要花费时间去兼容这些手机，原因很简单：数据支撑，京东大促的用户量级非常巨大，虽然这些手机用户占比很少，但是当用户基数达到一定数量时，即使占比很小，数量也是很可观的，对应而来的就是各种客诉，所以我们必须兼容这些手机。 本文将从以下场景讨论问题的解决方案。 主要诉求： 文字小于12px在安卓和ios表现不同； 文字在一定宽度下自适应，超过一定宽度需要截断； 文字配图标或者其他元素； 不使用JS，纯CSS； dom节点只有2层，比如 1&lt;div&gt;&lt;span&gt;任何元素&lt;span&gt;&lt;span class=\"tag\"&gt;内容&lt;/span&gt;&lt;/div&gt;； 必须兼容IOS9及以下和安卓4.4.4，所以首先被排除的方法就是flex布局； PS. 本文不讨论PC下的展示效果 主要问题： 假如设计稿高度为28px，我们如果把行高写成28px，那么在IOS和安卓下，必然是会出bug的，相信实践过的朋友都知道，同样的行高，IOS下没什么问题，但是在安卓下，文字是偏上的，如图所示： 经典问题了，怎么解决呢，根据网上的经验，都是建议使用flex布局的align-items来布局，但是这种布局不支持4.4.4的安卓手机，所以不行，同理grid也是不行。 方法一：table布局我尝试使用了table来进行布局，如果不考虑截断的问题，是可行的，缺点是必须2层结构，否则无法实现文字截断的效果，效果如下： 代码如下：1&lt;div class=\"word\"&gt;&lt;span&gt;文字文字文字文字文字文字&lt;/span&gt;&lt;/div&gt; 1234567891011121314151617.word &#123; font-size: 10px; background: red; color: white; display: inline-table; padding: 0 10px; table-layout: fixed; width: 100px;&#125;.word span &#123; display: table-cell; height: 22px; vertical-align: middle; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125; PS:table布局同样适用于2行纯文字，但是无法截断。 方法二：line-height: normal我们还可以使用line-height: normal的方法来实现，效果如下：代码如下：1234567891011121314.word &#123; font-size: 10px; background: red; color: white; display: inline-block; padding: 3px 10px; width: 100px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125;.word span &#123; line-height: normal;&#125; 缺点：必须多套一层结构 PS:line-height: normal的元素不能设置高度，只能使用padding或者margin来模拟高度 方法三：？？？我们都知道，安卓下的文字是偏上的，所以我就把line-height加高了几个像素，奇迹发生了，安卓下居中了，IOS基本没变，绝了！经过试验，line-height值需要比height值大2px即可，IOS对这个值的敏感度非常小，只要不大于这个值，就几乎不变。 安卓：IOS：1234567891011121314&lt;div class=\"word\"&gt;文字文字文字文字文字文字&lt;/div&gt;.word &#123; font-size: 10px; background: red; color: white; display: inline-block; padding: 0 10px; line-height: 24px; height: 22px; width: 100px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125; 这个方法的应用场景在哪呢，文字+icon+需要截断+自定义宽度，经过研究，我发现，这种情况下，如果不使用js或者hack，是不可能使用纯CSS的办法完美解决的，所以使用该方法，可以保证在所有安卓和IOS的差距保持在一个设计师可以接受的范围内。 效果如下：安卓：IOS：代码如下：12345678910111213141516171819202122232425262728293031.word &#123; display: inline-block; border-radius: 4px; color: #fff; background: #E8220E; text-align: left; overflow: hidden; font-size: 20px; max-width: 180px; white-space: nowrap; vertical-align: top; padding: 0 6px 0 6px; height: 28px; line-height: 32px; &amp;__pre &#123; display: inline-block; vertical-align: top; padding-right: 4px; line-height: 30px; &#125; &amp;__text &#123; display: inline-block; vertical-align: top; width: calc(100% - 20px); text-overflow: ellipsis; white-space: nowrap; overflow: hidden; table-layout: fixed; &#125;&#125; 该方法使用了calc来计算整体宽度，来实现文字截断。这种方法能够兼容一行下的大部分情况，支持图标+文字、文字+文字。缺点：IOS下可能还是会稍偏一点点，但是根据我们设计师的反馈，该误差可以接受，且该方法支持一行多个同时出现。 总结 根据实践，大部分情况下，方法3是覆盖面比较广的方法，line-height的值 &gt; height的值即可； 如果只有一行文字，建议使用line-height: normal； 多行文字建议使用table布局，控制字数，因为无法截断；","pubDate":"Fri, 24 Jul 2020 10:00:00 GMT","guid":"https://aotu.io/notes/2020/07/24/line-height-in-all-hardware/","category":"经验分享"}]}